<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="generator" content="Hexo 4.2.0"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Matrix</title><meta property="og:type" content="blog"><meta property="og:title" content="Matrix"><meta property="og:url" content="http://timemachine.top/"><meta property="og:site_name" content="Matrix"><meta property="og:locale" content="zh_CN"><meta property="article:author" content="CCYYZZNN"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="http://timemachine.top/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://timemachine.top"},"headline":"Matrix","image":["http://timemachine.top/img/og_image.png"],"author":{"@type":"Person","name":"CCYYZZNN"},"description":null}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="Matrix" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item is-active" href="/">主页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><div class="card-image"><a class="image is-7by3" href="/passages/%E3%80%90JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%91%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/"><img class="thumbnail" src="https://s2.ax1x.com/2019/08/19/mlQ5rj.jpg" alt="【JS高级程序设计】第五章 引用类型"></a></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-04-06T14:04:03.000Z" title="2020-04-06T14:04:03.000Z">2020-04-06</time><span class="level-item"><a class="link-muted" href="/categories/javascript/">javascript</a></span><span class="level-item">1 小时 读完 (大约 12995 个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/passages/%E3%80%90JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%91%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/">【JS高级程序设计】第五章 引用类型</a></h1><div class="content"><blockquote>
<p>引用类型的值（对象）是引用类型的一个实例。在 ECMAScript 中，引用类型是一种数据结构， 用于将数据和功能组织在一起。它也常被称为类，但这种称呼并不妥当。尽管 ECMAScript 从技术上讲是一门面向对象的语言，但它不具备传统的面向对象语言所支持的类和接口等基本结构。引 用类型有时候也被称为对象定义，因为它们描述的是一类对象所具有的属性和方法。</p>
</blockquote>
<p>如前所述，对象是某个特定引用类型的实例。新对象是使用 new 操作符后跟一个构造函数来创建的。 构造函数本身就是一个函数，只不过该函数是出于创建新对象的目的而定义的。</p>
<p><code>var person = new Object();</code></p>
<h1 id="5-1-Object-类型"><a href="#5-1-Object-类型" class="headerlink" title="5.1 Object 类型"></a>5.1 Object 类型</h1><blockquote>
<p>到目前为止， 我们看到的大多数引用类型值都是 Object 类型的实例；而且， Object 也是 ECMAScript 中使用最多的一个类型。虽然 Object 的实例不具备多少功能，但对于在应用程序中存储 和传输数据而言，它们确实是非常理想的选择。</p>
</blockquote>
<p>创建 Object 实例的方式有两种。第一种是使用 new 操作符后跟 Object 构造函数</p>
<pre><code class="js">var person = new Object()
person.name = &#39;tom&#39;
person.age = 18</code></pre>
<p>另一种方式是使用对象字面量表示法。对象字面量是对象定义的一种简写形式，目的在于简化创建 包含大量属性的对象的过程。下面这个例子就使用了对象字面量语法定义了与前面那个例子中相同的 person 对象：</p>
<pre><code class="js">var person = {
  name : &#39;tom&#39;,
  age : 18
}</code></pre>
<p>在使用对象字面量语法时，属性名也可以使用字符串</p>
<pre><code class="js">var person = {
  &quot;name&quot; : &#39;tom&#39;,
  &quot;age&quot; : 18,
  5 : true
}</code></pre>
<p>一般来说，访问对象属性时使用的都是点表示法，这也是很多面向对象语言中通用的语法。不过， 在 JavaScript 也可以使用方括号表示法来访问对象的属性。在使用方括号语法时，应该将要访问的属性 以字符串的形式放在方括号中</p>
<p>如果属性名中包含会导致语法错误的字符，或者属性名使用的是关键字或保留字，也可以使用方括 号表示法。</p>
<p><code>person[&quot;first name&quot;] = &quot;Nicholas&quot;;</code></p>
<h1 id="5-2-Array类型"><a href="#5-2-Array类型" class="headerlink" title="5.2 Array类型"></a>5.2 Array类型</h1><p>除了 Object 之外，Array 类型恐怕是 ECMAScript 中最常用的类型了。而且，ECMAScript 中 的数组与其他多数语言中的数组有着相当大的区别。虽然 ECMAScript 数组与其他语言中的数组都是 数据的有序列表，但与其他语言不同的是，ECMAScript 数组的每一项可以保存任何类型的数据。 也 就是说，可以用数组的第一个位置来保存字符串，用第二位置来保存数值，用第三个位置来保存对象， 以此类推，而且，ECMAScript 数组的大小是可以动态调整的，即可以随着数据的添加自动增长以容 纳新增数据</p>
<p>创建数组的方法1:</p>
<p><code>var arr = new Array()</code></p>
<p>如果预先知道数组要保存的项目数量，也可以给构造函数传递该数量，而该数量会自动变成 length 属性的值。</p>
<p><code>var arr = new Array(20)</code>// 创建了一个长度为20的数组</p>
<p>也可以向 Array 构造函数传递数组中应该包含的项。以下代码创建了一个包含 3 个字符串值的数组</p>
<p><code>var colors = new Array(&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;)</code></p>
<blockquote>
<p>当然，给构造函数传递一个值也可以创建数组。但这时候问题就复杂一点了，因为如果传递的是数 值，则会按照该数值创建包含给定项数的数组；而如果传递的是其他类型的参数，则会创建包含那个值 的只有一项的数组。</p>
</blockquote>
<pre><code class="js">var arr = new Array(3) //创建一个3个长度的数组
var arr = new Array(&#39;sa&#39;) //创建为长度为1的sa</code></pre>
<blockquote>
<p>另外，在使用 Array 构造函数时也可以省略 new 操作符</p>
</blockquote>
<h2 id="5-2-1-检测数组"><a href="#5-2-1-检测数组" class="headerlink" title="5.2.1 检测数组"></a>5.2.1 检测数组</h2><blockquote>
<p>instanceof 操作符的问题在于，它假定只有一个全局执行环境。如果网页中包含多个框架，那实 际上就存在两个以上不同的全局执行环境，从而存在两个以上不同版本的 Array 构造函数。如果你从 一个框架向另一个框架传入一个数组，那么传入的数组与在第二个框架中原生创建的数组分别具有各自 不同的构造函数。</p>
</blockquote>
<p>为了解决这个问题，ECMAScript 5 新增了 Array.isArray()方法。这个方法的目的是最终确定某 个值到底是不是数组，而不管它是在哪个全局执行环境中创建的。</p>
<p><code>Array.isArray([]) //true</code></p>
<h2 id="5-2-2-转换方法"><a href="#5-2-2-转换方法" class="headerlink" title="5.2.2 转换方法"></a>5.2.2 转换方法</h2><p>如前所述，所有对象都具有 toLocaleString()、toString()和 valueOf()方法。其中，调用 数组的 toString()方法会返回由数组中每个值的字符串形式拼接而成的一个以逗号分隔的字符串。而 调用 valueOf()返回的还是数组。实际上，为了创建这个字符串会调用数组每一项的 toString()方 法。</p>
<pre><code class="js">var colors = [&#39;red&#39;,&#39;blue&#39;,&#39;green&#39;]
alert(colors.toString()) // red,blue,green
alert(colors.valueOf()) // red,blue,green
alert(colors) // red,blue,green</code></pre>
<p>在这里，我们首先显式地调用了 toString()方法，以便返回数组的字符串表示，每个值的字符串 表示拼接成了一个字符串，中间以逗号分隔。接着调用 valueOf()方法，而最后一行代码直接将数组 传递给了 alert()。由于 alert()要接收字符串参数，所以它会在后台调用 toString()方法，由此 会得到与直接调用 toString()方法相同的结果。</p>
<p>另外，toLocaleString()方法经常也会返回与 toString()和 valueOf()方法相同的值，但也 不总是如此。当调用数组的 toLocaleString()方法时，它也会创建一个数组值的以逗号分隔的字符 串。而与前两个方法唯一的不同之处在于，这一次为了取得每一项的值，调用的是每一项的 toLocaleString()方法，而不是 toString()方法。</p>
<pre><code class="js">var val = {
  toString : function () {
    return &#39;1&#39;
  },
  toLocalString : function () {
    return &#39;-1&#39;
  }
}

var val1 = {
  toString : function () {
     return &#39;2&#39;
  },
  toLocalString : function () {
    return &#39;-2&#39;
  }
}

var content = [val,val1]
content.toString() // 1 ,2
content.toLocalString() // -1 ,-2 调用每项的toLocalString
content // 1 ,2 默认调用toString 方法</code></pre>
<blockquote>
<p>数组继承的 toLocaleString()、toString()和 valueOf()方法，在默认情况下都会以逗号分隔的字 符串的形式返回数组项。而如果使用 join()方法，则可以使用不同的分隔符来构建这个字符串。join()方 法只接收一个参数，即用作分隔符的字符串，然后返回包含所有数组项的字符串。</p>
</blockquote>
<pre><code class="js">var colors = [&#39;red&#39;,&#39;blue&#39;,&#39;green&#39;]
colors.join(&quot; | &quot;) // red | blue | green</code></pre>
<blockquote>
<p>如果数组中的某一项的值是 null 或者 undefined ， 那么该值在 join() 、 toLocaleString()、toString()和 valueOf()方法返回的结果中以空字符串表示。</p>
</blockquote>
<h2 id="5-2-3-栈方法"><a href="#5-2-3-栈方法" class="headerlink" title="5.2.3 栈方法"></a>5.2.3 栈方法</h2><p>ECMAScript 数组也提供了一种让数组的行为类似于其他数据结构的方法。具体说来，数组可以表 现得就像栈一样，后者是一种可以限制插入和删除项的数据结构。栈是一种 LIFO（Last-In-First-Out， 后进先出）的数据结构，也就是最新添加的项最早被移除。而栈中项的插入（叫做推入）和移除（叫做 弹出），只发生在一个位置——栈的顶部。ECMAScript 为数组专门提供了 push()和 pop()方法，以便 实现类似栈的行为。</p>
<p>push()方法可以接收任意数量的参数，把它们逐个添加到数组末尾，并返回修改后数组的长度。而 pop()方法则从数组末尾移除最后一项，减少数组的 length 值，然后返回移除的项。</p>
<pre><code class="js">var colors = new Array();
var count = colors.push(&quot;red&quot;, &quot;green&quot;);
alert(count ) //2
count = colors.push(&quot;black&quot;);
alert(count) //3
var item = colors.pop(); //取得最后一项
alert(item) //black
alert(color.length) //2</code></pre>
<h2 id="5-2-4-队列方法"><a href="#5-2-4-队列方法" class="headerlink" title="5.2.4 队列方法"></a>5.2.4 队列方法</h2><p>由于 push()是向数组末端添加项的方法， 因此要模拟队列只需一个从数组前端取得项的方法。实现这一操作的数组方法就是 shift()，它能够移 除数组中的第一个项并返回该项，同时将数组长度减 1。结合使用 shift()和 push()方法，可以像使 用队列一样使用数组。</p>
<pre><code class="js">var color = new Array()
var count = color.push(&#39;red&#39;,&#39;green&#39;)
alert(count) // 2

var item = color.shift()
alert(item) // red
color.length //1</code></pre>
<p>ECMAScript 还为数组提供了一个 unshift()方法。顾名思义，unshift()与 shift()的用途相反： 它能在数组前端添加任意个项并返回新数组的长度。因此，同时使用 unshift()和 pop()方法，可以 从相反的方向来模拟队列，即在数组的前端添加项，从数组末端移除项</p>
<h2 id="5-2-5-重新排序方法"><a href="#5-2-5-重新排序方法" class="headerlink" title="5.2.5 重新排序方法"></a>5.2.5 重新排序方法</h2><ul>
<li>reverse()</li>
<li>sort()</li>
</ul>
<ol>
<li>reverse 反转数组</li>
</ol>
<pre><code class="js">var number = [1,2,3,4,5]
number.reverse()
number // [5,4,3,2,1]</code></pre>
<ol start="2">
<li>sort方法</li>
</ol>
<p>在默认情况下，sort()方法按升序排列数组项——即最小的值位于最前面，最大的值排在最后面。 为了实现排序，sort()方法会调用每个数组项的 toString()转型方法，然后比较得到的字符串，以 确定如何排序。即使数组中的每一项都是数值，sort()方法比较的也是字符串</p>
<pre><code class="js">var values = [0, 1, 5, 10, 15];
values.sort();
alert(values) // //0,1,10,15,5</code></pre>
<blockquote>
<p>比较函数接收两个参数，如果第一个参数应该位于第二个之前则返回一个负数，如果两个参数相等 则返回 0，如果第一个参数应该位于第二个之后则返回一个正数。</p>
</blockquote>
<pre><code class="js">function compare(val1,val2){
  if(val1 &lt; val2){
    return -1
  }else if(val1 &gt; val2){
      return 1         
  }else{
    return 0
  }
}</code></pre>
<p>对于数值类型或者其 valueOf()方法会返回数值类型的对象类型，可以使用一个更简单的比较函 数。这个函数只要用第二个值减第一个值即可。</p>
<pre><code class="js">function compare(value1, value2){ return value2 - value1; }</code></pre>
<p>由于比较函数通过返回一个小于零、等于零或大于零的值来影响排序结果，因此减法操作就可以适 当地处理所有这些情况。</p>
<h2 id="5-2-6-操作方法"><a href="#5-2-6-操作方法" class="headerlink" title="5.2.6 操作方法"></a>5.2.6 操作方法</h2><p>ECMAScript 为操作已经包含在数组中的项提供了很多方法。其中，concat()方法可以基于当前数 组中的所有项创建一个新数组。具体来说，这个方法会先创建当前数组一个副本，然后将接收到的参数 添加到这个副本的末尾，最后返回新构建的数组。在没有给 concat()方法传递参数的情况下，它只是 复制当前数组并返回副本。如果传递给 concat()方法的是一或多个数组，则该方法会将这些数组中的 每一项都添加到结果数组中。如果传递的值不是数组，这些值就会被简单地添加到结果数组的末尾。</p>
<pre><code class="js">var colors = [&#39;red&#39; , &#39;green&#39; ,&#39;blue&#39;]
var colors2 = colors.concat(&#39;1&#39;,[&#39;2&#39;,&#39;3&#39;])

colors // [&#39;red&#39; , &#39;green&#39; ,&#39;blue&#39;]
colors2 // [&#39;red&#39; , &#39;green&#39; ,&#39;blue&#39; , &#39;1&#39;,&#39;2&#39;,&#39;3&#39;]</code></pre>
<p>下一个方法是 slice()，它能够基于当前数组中的一或多个项创建一个新数组。slice()方法可以 接受一或两个参数，即要返回项的起始和结束位置。在只有一个参数的情况下，slice()方法返回从该 参数指定位置开始到当前数组末尾的所有项。如果有两个参数，该方法返回起始和结束位置之间的项—但不包括结束位置的项。注意，slice()方法不会影响原始数组。</p>
<pre><code class="js">var colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;yellow&quot;, &quot;purple&quot;];
var colors2 = colors.slice(1);
var colors3 = colors.slice(1,4);
alert(colors2) // green到purple
alert(colors3) // green 到yellow</code></pre>
<p>下面我们来介绍 splice()方法，这个方法恐怕要算是最强大的数组方法了，它有很多种用法。 splice()的主要用途是向数组的中部插入项，但使用这种方法的方式则有如下 3 种。</p>
<ul>
<li>删除：可以删除任意数量的项，只需指定 2 个参数：要删除的第一项的位置和要删除的项数。 例如，splice(0,2)会删除数组中的前两项。</li>
<li>插入：可以向指定位置插入任意数量的项，只需提供 3 个参数：起始位置、0（要删除的项数） 和要插入的项。 如果要插入多个项， 可以再传入第四、第五， 以至任意多个项。 例如， splice(2,0,”red”,”green”)会从当前数组的位置 2 开始插入字符串”red”和”green”。</li>
<li>替换：可以向指定位置插入任意数量的项，且同时删除任意数量的项，只需指定 3 个参数：起 始位置、要删除的项数和要插入的任意数量的项。插入的项数不必与删除的项数相等。例如， splice (2,1,”red”,”green”)会删除当前数组位置 2 的项，然后再从位置 2 开始插入字符串 “red”和”green”。</li>
</ul>
<blockquote>
<p>splice()方法始终都会返回一个数组，该数组中包含从原始数组中删除的项（如果没有删除任何 项，则返回一个空数组）。</p>
</blockquote>
<h2 id="5-2-7-位置方法"><a href="#5-2-7-位置方法" class="headerlink" title="5.2.7 位置方法"></a>5.2.7 位置方法</h2><p>ECMAScript 5 为数组实例添加了两个位置方法：indexOf()和 lastIndexOf()。这两个方法都接收 两个参数：要查找的项和（可选的）表示查找起点位置的索引。其中，indexOf()方法从数组的开头（位 置 0）开始向后查找，lastIndexOf()方法则从数组的末尾开始向前查找。</p>
<p>这两个方法都返回要查找的项在数组中的位置，或者在没找到的情况下返回1。在比较第一个参数 与数组中的每一项时，会使用全等操作符；也就是说，要求查找的项必须严格相等（就像使用===一样）。</p>
<h2 id="5-2-8-迭代方法"><a href="#5-2-8-迭代方法" class="headerlink" title="5.2.8 迭代方法"></a>5.2.8 迭代方法</h2><p>ECMAScript 5 为数组定义了 5 个迭代方法。每个方法都接收两个参数：要在每一项上运行的函数和（可选的）运行该函数的作用域对象——影响 this 的值。传入这些方法中的函数会接收三个参数：数 组项的值、该项在数组中的位置和数组对象本身。根据使用的方法不同，这个函数执行后的返回值可能 会也可能不会影响方法的返回值。</p>
<ul>
<li><p>every()  用于查询数组中的项是否满足某个条件，如果全部为true则返回true，否则返回false</p>
</li>
<li><p>some() 用于查询数组中的项是否满足某个条件，如果一个为true则返回true</p>
<pre><code class="js">var numbers = [1,2,3,4,5,4,3,2,1];
var everyResult = numbers.every(function(item, index, array){
return (item &gt; 2); }); // false 因为有小于2的值

var someResult = numbers.some(function(item,index,array){
  return (item &gt; 2)
})//true 因为有大于2的值</code></pre>
</li>
<li><p>filter()函数，它利用指定的函数确定是否在返回的数组中包含某一项。返回过滤的数组（过滤器）</p>
<pre><code class="js">var numbers = [1,2,3,4,5,4,3,2,1];
var filterResult = numbers.filter(function(item,index,array){
  return item &gt; 2
})
filterResult // [3,4,5,4,3]</code></pre>
</li>
<li><p>map()也返回一个数组，而这个数组的每一项都是在原始数组中的对应项上运行传入函数的结果。(遍历并返回数组)</p>
<pre><code class="js">var numbers = [1,2,3,4,5,4,3,2,1];
var mapResult = numbers.map(function(item,index,array){
  return item * 2
})
mapResult // [2,3,6,8,10,8,6,4,2]</code></pre>
</li>
<li><p>forEach()，它只是对数组中的每一项运行传入的函数。</p>
<pre><code class="js">//简单复制数组
var numbers = [1,2,3,4,5,4,3,2,1]
var newGroup = []
numbers.forEach(function(item,index,array){
  newGroup.push(item)
})
newGroup //[1,2,3,4,5,4,3,2,1]</code></pre>
</li>
</ul>
<h2 id="5-2-9-归并方法"><a href="#5-2-9-归并方法" class="headerlink" title="5.2.9 归并方法"></a>5.2.9 归并方法</h2><p>ECMAScript 5 还新增了两个归并数组的方法：reduce()和 reduceRight()。这两个方法都会迭 代数组的所有项，然后构建一个最终返回的值。其中，reduce()方法从数组的第一项开始，逐个遍历 到最后。而 reduceRight()则从数组的最后一项开始，向前遍历到第一项。</p>
<blockquote>
<p>reduce()和 reduceRight()的函数接收 4 个参数：前一个值、当前值、项的索引和数组对象。</p>
</blockquote>
<p> 这 个函数返回的任何值都会作为第一个参数自动传给下一项。第一次迭代发生在数组的第二项上，因此第 一个参数是数组的第一项，第二个参数就是数组的第二项。</p>
<pre><code class="js">var numbers = [1,2,3,4,5]
var sum = numbers.reduce(function(pre,cur,index,array){
  return pre + cur
})
sum //15</code></pre>
<p>第一次执行回调函数，prev 是 1，cur 是 2。第二次，prev 是 3（1 加 2 的结果），cur 是 3（数组 的第三项）。这个过程会持续到把数组中的每一项都访问一遍，最后返回结果。</p>
<p>reduceRight()的作用类似，只不过方向相反而已。</p>
<pre><code class="js">var values = [1,2,3,4,5]; 
var sum = values.reduceRight(function(prev, cur, index, array){ return prev + cur; }); alert(sum); //15</code></pre>
<h1 id="5-3-Date类型"><a href="#5-3-Date类型" class="headerlink" title="5.3 Date类型"></a>5.3 Date类型</h1><p>ECMAScript 中的 Date 类型是在早期 Java 中的 java.util.Date 类基础上构建的。为此，Date 类型使用自 UTC（Coordinated Universal Time，国际协调时间）1970 年 1 月 1 日午夜（零时）开始经过 的毫秒数来保存日期。</p>
<p>在使用这种数据存储格式的条件下，Date 类型保存的日期能够精确到 1970 年 1 月 1 日之前或之后的 285 616 年。</p>
<p>创建日期对象 <code>var time = new Date()</code></p>
<p>在调用 Date 构造函数而不传递参数的情况下，新创建的对象自动获得当前日期和时间。如果想根 据特定的日期和时间创建日期对象，必须传入表示该日期的毫秒数（即从 UTC 时间 1970 年 1 月 1 日午 夜起至该日期止经过的毫秒数）。为了简化这一计算过程，ECMAScript 提供了两个方法：Date.parse() 和 Date.UTC()。</p>
<ul>
<li><p>Date.parse() 接受一个日期字符串，反馈一个相应日期的毫秒数</p>
<pre><code class="js">var ms = Date.parse(&#39;1993-09-28&#39;)
var birthDay = new Date(ms)
birthDay //Tue Sep 28 1993 08:00:00 GMT+0800 (中国标准时间)

//与下面类似
var birthDay = new Date(&#39;1993-09-28&#39;)</code></pre>
<blockquote>
<p>ECMA-262 没有定义 Date.parse()应该支持哪种日期格式，因此这个方法的行为因实现 而异，而且通常是因地区而异。</p>
</blockquote>
</li>
<li><p>Date.UTC()方法同样也返回表示日期的毫秒数，但它与 Date.parse()在构建值时使用不同的信息。</p>
<blockquote>
<p>Date.UTC()的参数分别是年份、基于 0 的月份（一月是 0，二月是 1，以此类推）、月 （1 到 31）、小时数（0 到 23）、分钟、秒以及毫秒数。</p>
<p>在这些参数中，只有前两个参数（年和月）是必 需的。如果没有提供月中的天数，则假设天数为 1；如果省略其他参数，则统统假设为 0。</p>
</blockquote>
<pre><code class="js">// GMT 时间 2000 年 1 月 1 日午夜零时
var y2k = new Date(Date.UTC(2000, 0));
//类似于
var y2k = new Date(2000, 0);

// GMT 时间 2005 年 5 月 5 日下午 5:55:55
var allFives = new Date(Date.UTC(2005, 4, 5, 17, 55, 55));
//类似于
var allFives = new Date(2005, 4, 5, 17, 55, 55);</code></pre>
</li>
<li><p>ECMAScript 5 添加了 Data.now()方法，返回表示调用这个方法时的日期和时间的毫秒数。这个方 法简化了使用 Data 对象分析代码的工作。</p>
<pre><code class="js">var start = Date.now()
dosomething()
var stop = Date.now()

//可以用以下替换
var start = +new Date() //+号替换成字符串 调用new Date().valueOf()
dosomething()
var stop = +new Date()</code></pre>
</li>
</ul>
<h2 id="5-3-2-📅日期格式化"><a href="#5-3-2-📅日期格式化" class="headerlink" title="5.3.2 📅日期格式化"></a>5.3.2 📅日期格式化</h2><ul>
<li>toDateString()——以特定于实现的格式显示星期几、月、日和年；</li>
<li>toTimeString()——以特定于实现的格式显示时、分、秒和时区；</li>
<li>toLocaleDateString()——以特定于地区的格式显示星期几、月、日和年；</li>
<li>toLocaleTimeString()——以特定于实现的格式显示时、分、秒；</li>
<li>toUTCString()——以特定于实现的格式完整的 UTC 日期。</li>
</ul>
<blockquote>
<p>ECMAScript 推荐现在编写的代码一律使用 toUTCString()方法。</p>
</blockquote>
<h1 id="5-4-RegExp-类型"><a href="#5-4-RegExp-类型" class="headerlink" title="5.4 RegExp 类型"></a>5.4 RegExp 类型</h1><p>ECMAScript 通过 RegExp 类型来支持正则表达式。使用下面类似 Perl 的语法，就可以创建一个正 则表达式。</p>
<p><code>var expression = / pattern / flags ;</code></p>
<p>其中的模式（pattern）部分可以是任何简单或复杂的正则表达式，可以包含字符类、限定符、分组、 向前查找以及反向引用。每个正则表达式都可带有一或多个标志（flags），用以标明正则表达式的行为。 正则表达式的匹配模式支持下列 3 个标志。</p>
<ol>
<li>g：表示全局（global）模式，即模式将被应用于所有字符串，而非在发现第一个匹配项时立即 停止；</li>
<li>i：表示不区分大小写（case-insensitive）模式，即在确定匹配项时忽略模式与字符串的大小写；</li>
<li>m：表示多行（multiline）模式，即在到达一行文本末尾时还会继续查找下一行中是否存在与模 式匹配的项。</li>
</ol>
<p>一个正则表达式就是一个模式与上述 3 个标志的组合体。不同组合产生不同结果。</p>
<pre><code class="js">/* * 匹配字符串中所有&quot;at&quot;的实例 */
var pattern1 = /at/g;

/* * 匹配第一个&quot;bat&quot;或&quot;cat&quot;，不区分大小写 */
var pattern2 = /[bc]at/i;

/* * 匹配所有以&quot;at&quot;结尾的 3 个字符的组合，不区分大小写 */
var pattern3 = /.at/gi;</code></pre>
<p>前面举的这些例子都是以字面量形式来定义的正则表达式。另一种创建正则表达式的方式是使用 RegExp 构造函数，它接收两个参数：一个是要匹配的字符串模式，另一个是可选的标志字符串。可以 使用字面量定义的任何表达式，都可以使用构造函数来定义，</p>
<pre><code class="js">/* * 匹配第一个&quot;bat&quot;或&quot;cat&quot;，不区分大小写 */
var pattern1 = /[bc]at/i;
//使用构造函数创建正则表达式
var pattern1 = new RegExp(&quot;[bc]at&quot;,&quot;i&quot;)</code></pre>
<h2 id="5-4-1-RegExp实例属性"><a href="#5-4-1-RegExp实例属性" class="headerlink" title="5.4.1 RegExp实例属性"></a>5.4.1 RegExp实例属性</h2><p>RegExp 的每个实例都具有下列属性，通过这些属性可以取得有关模式的各种信息</p>
<ul>
<li>global：布尔值，表示是否设置了 g 标志</li>
<li>ignoreCase：布尔值，表示是否设置了 i 标志。</li>
<li>lastIndex：整数，表示开始搜索下一个匹配项的字符位置，从 0 算起。</li>
<li>multiline：布尔值，表示是否设置了 m 标志</li>
<li>source：正则表达式的字符串表示，按照字面量形式而非传入构造函数中的字符串模式返回。</li>
</ul>
<h1 id="5-5-Function-类型"><a href="#5-5-Function-类型" class="headerlink" title="5.5 Function 类型"></a>5.5 Function 类型</h1><p>说起来 ECMAScript 中什么最有意思，我想那莫过于函数了——而有意思的根源，则在于函数实际 上是对象。每个函数都是 Function 类型的实例，而且都与其他引用类型一样具有属性和方法。由于函 数是对象，因此函数名实际上也是一个指向函数对象的指针，不会与某个函数绑定。函数通常是使用函 数声明语法定义的</p>
<p>函数的三种创建方式：</p>
<pre><code class="js">//函数声明
function sum(num1,num2){
  return num1 + num2
}

//函数表达式
var sum = function(num1,num2){
  return num1 + num2
}

//Function 构造函数生成
var sum = new Function(&#39;num1&#39;,&#39;num2&#39;,&#39;return num1 + num2&#39;)</code></pre>
<pre><code class="js">function sum(num1, num2){ return num1 + num2; }
alert(sum(10,10));//20

var anotherSum = sum;
alert(anotherSum(10,10)); //20

sum = null; 
alert(anotherSum(10,10)); //20
</code></pre>
<blockquote>
<p>以上代码首先定义了一个名为 sum()的函数，用于求两个值的和。然后，又声明了变量 anotherSum， 并将其设置为与 sum 相等（将 sum 的值赋给 anotherSum）。注意，使用不带圆括号的函数名是访问函 数指针，而非调用函数。此时，anotherSum 和 sum 就都指向了同一个函数，因此 anotherSum()也 可以被调用并返回结果。即使将 sum 设置为 null，让它与函数“断绝关系”，但仍然可以正常调用 anotherSum()。</p>
</blockquote>
<h2 id="5-5-1-没有重载（深入理解）"><a href="#5-5-1-没有重载（深入理解）" class="headerlink" title="5.5.1 没有重载（深入理解）"></a>5.5.1 没有重载（深入理解）</h2><p>将函数名想象为指针，也有助于理解为什么 ECMAScript 中没有函数重载的概念。（重复声明的函数会被覆盖）</p>
<pre><code class="js">function addSomeNum(num){
  return num + 100
}

function addSomeNum(num){
  return num + 200
}

addSomeNum(100) //300</code></pre>
<p>函数被覆盖。函数表达式也是如此。</p>
<h2 id="5-5-2-函数声明与函数表达式"><a href="#5-5-2-函数声明与函数表达式" class="headerlink" title="5.5.2 函数声明与函数表达式"></a>5.5.2 函数声明与函数表达式</h2><p>本节到目前为止，我们一直没有对函数声明和函数表达式加以区别。而实际上，解析器在向执行环 境中加载数据时，对函数声明和函数表达式并非一视同仁。解析器会率先读取函数声明，并使其在执行 任何代码之前可用（可以访问）；至于函数表达式，则必须等到解析器执行到它所在的代码行，才会真 正被解释执行。</p>
<pre><code class="js">alert(sum(10,10));
function sum(num1, num2){ return num1 + num2; }</code></pre>
<blockquote>
<p>上述代码可以运行。因为在代码开始执行之前，解析器就已经通过一个名为函数声明提升 （function declaration hoisting）的过程，读取并将函数声明添加到执行环境中。对代码求值时，JavaScript 引擎在第一遍会声明函数并将它们放到源代码树的顶部。所以，即使声明函数的代码在调用它的代码后 面，JavaScript 引擎也能把函数声明提升到顶部。</p>
</blockquote>
<p>如果改变为函数表达式则会出现错误</p>
<pre><code class="js">alert(sum(10,10))
var sum = function(num1,num2){
  return num1 + num2
}</code></pre>
<p>原因在于函数位于一个初始化语句中，而不是一个函数声 明。换句话说，在执行到函数所在的语句之前，变量 sum 中不会保存有对函数的引用；而且，由于第一 行代码就会导致“unexpected identifier”（意外标识符）错误，实际上也不会执行到下一行。</p>
<h2 id="5-5-3-作为值的函数"><a href="#5-5-3-作为值的函数" class="headerlink" title="5.5.3 作为值的函数"></a>5.5.3 作为值的函数</h2><p>因为 ECMAScript 中的函数名本身就是变量，所以函数也可以作为值来使用。也就是说，不仅可以 像传递参数一样把一个函数传递给另一个函数，而且可以将一个函数作为另一个函数的结果返回。</p>
<pre><code class="js">function execFunction(fn,params){
  return fn(params)
}

function addSomeNum(num){
  return num + 10
}

execFunction(addSomeNum,10) //20</code></pre>
<p>当然，可以从一个函数中返回另一个函数，而且这也是极为有用的一种技术。例如，假设有一个 对象数组，我们想要根据某个对象属性对数组进行排序。而传递给数组 sort()方法的比较函数要接收 两个参数，即要比较的值。可是，我们需要一种方式来指明按照哪个属性来排序。要解决这个问题， 可以定义一个函数，它接收一个属性名，然后根据这个属性名来创建一个比较函数，下面就是这个函 数的定义。</p>
<pre><code class="js">function compare(objectName){
  return function(obj1,obj2){
    var val1 = obj1[objectName]
    var val2 = obj2[objectName]
    if(val1 &gt; val2){
           return -1
       }else if(val1 &lt; val2){
        return 1
       }else{
         return 0
       }
  }
}

//实例
var data = [{name: &quot;Zachary&quot;, age: 28}, {name: &quot;Nicholas&quot;, age: 29}];
data.sort(compare(&quot;name&quot;)); alert(data[0].name); //Nicholas

data.sort(compare(&quot;age&quot;)); alert(data[0].name); //Zachary</code></pre>
<h2 id="5-5-4-函数内部属性"><a href="#5-5-4-函数内部属性" class="headerlink" title="5.5.4 函数内部属性"></a>5.5.4 函数内部属性</h2><p>在函数内部，有两个特殊的对象：arguments 和 this。其中，arguments 在第 3 章曾经介绍过， 它是一个类数组对象，包含着传入函数中的所有参数。虽然 arguments 的主要用途是保存函数参数， 但这个对象还有一个名叫 callee 的属性，该属性是一个指针，指向拥有这个 arguments 对象的函数。</p>
<pre><code class="js">function factorial(num){ if (num &lt;=1) { return 1; } else { return num * factorial(num-1) } }</code></pre>
<p>定义阶乘函数一般都要用到递归算法；如上面的代码所示，在函数有名字，而且名字以后也不会变 的情况下，这样定义没有问题。但问题是这个函数的执行与函数名 factorial 紧紧耦合在了一起。为 了消除这种紧密耦合的现象，可以像下面这样使用 arguments.callee。</p>
<pre><code class="js">function factorial(num){ if (num &lt;=1) { return 1; } else { return num * arguments.callee(num-1) } }</code></pre>
<blockquote>
<p>在这个重写后的 factorial()函数的函数体内，没有再引用函数名 factorial。这样，无论引用 函数时使用的是什么名字，都可以保证正常完成递归调用。</p>
</blockquote>
<pre><code class="js">var trueFactorial = factorial;
factorial = function(){ return 0; };
alert(trueFactorial(5)); //120
alert(factorial(5));//0</code></pre>
<p>函数内部的另一个特殊对象是 this，其行为与 Java 和 C#中的 this 大致类似。换句话说，this 引用的是函数据以执行的环境对象——或者也可以说是 this 值（当在网页的全局作用域中调用函数时， this 对象引用的就是 window）。</p>
<pre><code class="js">window.color = &#39;red&#39;
var o = {
  color : &quot;blue&quot;
}
function sayColor(){
  return this.color
}

sayColor() // red
o.sayColor = sayColor 
o.sayColor() // blue</code></pre>
<p>上面这个函数 sayColor()是在全局作用域中定义的，它引用了 this 对象。由于在调用函数之前， this 的值并不确定，因此 this 可能会在代码执行过程中引用不同的对象。当在全局作用域中调用 sayColor() 时， this 引用的是全局对象 window ；换句话说， 对 this.color 求值会转换成对 window.color 求值，于是结果就返回了”red”。而当把这个函数赋给对象 o 并调用 o.sayColor() 时，this 引用的是对象 o，因此对 this.color 求值会转换成对 o.color 求值，结果就返回了”blue”。</p>
<p>caller属性。这个属性保存着当前函数的引用对象（是谁来调用这个函数）</p>
<pre><code class="js">function myFunc(){
  if(arguments.callee.caller == &#39;null&#39;){
    console.log(&quot;调用我的人是全局环境&quot;)
  }else{
    console.log(&quot;调用我的人是&quot; + arguments.callee.caller)
  }
}

myFunc() // 调用我的人是全局环境
function test(){
    return myFunc()
}
test() // 调用我的人是test 打印test函数
</code></pre>
<h2 id="5-5-5-函数属性和方法"><a href="#5-5-5-函数属性和方法" class="headerlink" title="5.5.5 函数属性和方法"></a>5.5.5 函数属性和方法</h2><p>ECMAScript 中的函数是对象，因此函数也有属性和方法。每个函数都包含两个 属性：length 和 prototype。其中，length 属性表示函数希望接收的命名参数的个数</p>
<pre><code class="js">function sayName(name){ alert(name); }
function sum(num1, num2){ return num1 + num2; }
function sayHi(){ alert(&quot;hi&quot;); }
alert(sayName.length);  //1
alert(sum.length);  //2
alert(sayHi.length); //0</code></pre>
<p>在 ECMAScript 核心所定义的全部属性中， 最耐人寻味的就要数 prototype 属性了。 对于 ECMAScript 中的引用类型而言，prototype 是保存它们所有实例方法的真正所在。换句话说，诸如 toString()和 valueOf()等方法实际上都保存在 prototype 名下，只不过是通过各自对象的实例访 问罢了。在创建自定义引用类型以及实现继承时，prototype 属性的作用是极为重要的（第 6 章将详 细介绍）。在 ECMAScript 5 中，prototype 属性是不可枚举的，因此使用 for-in 无法发现。</p>
<p>每个函数都包含两个非继承而来的方法：apply()和 call()。这两个方法的用途都是在特定的作 用域中调用函数，实际上等于设置函数体内 this 对象的值。首先，apply()方法接收两个参数：一个 是在其中运行函数的作用域，另一个是参数数组。其中，第二个参数可以是 Array 的实例，也可以是 arguments 对象。</p>
<pre><code class="js">function sum(num1,num2){
  return num1 + num2
}

function sumCall(num1,num2){
  return sum.call(this,[num1,num2])
}

function sumCall2(num1,num2){
  return sum.call(this,arguments)
}

sumCall(10,10) //20
sumCall2(10,10) //20</code></pre>
<p>call()方法与 apply()方法的作用相同，它们的区别仅在于接收参数的方式不同。对于 call() 方法而言，第一个参数是 this 值没有变化，变化的是其余参数都直接传递给函数。换句话说，在使用 call()方法时，传递给函数的参数必须逐个列举出来</p>
<p>事实上，传递参数并非 apply()和 call()真正的用武之地；它们真正强大的地方是能够扩充函数 赖以运行的作用域。</p>
<pre><code class="js">window.color = &#39;red&#39;
var o = {
  color: &#39;blue&#39;
}
function sayColor(){
  return this.color
}

sayColor() // red
sayColor.call(window) //red
sayColor.call(o) //blue</code></pre>
<p>而 sayColor.call(this)和 sayColor.call(window)，则是两 种显式地在全局作用域中调用函数的方式，结果当然都会显示”red”。但是，当运行 sayColor.call(o) 时，函数的执行环境就不一样了，因为此时函数体内的 this 对象指向了 o，于是结果显示的是”blue”。</p>
<p>使用 call()（或 apply()）来扩充作用域的最大好处，就是对象不需要与方法有任何耦合关系。 在前面例子的第一个版本中，我们是先将 sayColor()函数放到了对象 o 中，然后再通过 o 来调用它的； 而在这里重写的例子中，就不需要先前那个多余的步骤了。</p>
<pre><code class="js">//bind
window.color = &#39;red&#39;
var o = {
  color: &#39;blue&#39;
}
function sayColor(){
  return this.color
}

var objectBind = sayColor.bind(o)
objectBind() // blue</code></pre>
<h2 id="5-6-基本包装类型"><a href="#5-6-基本包装类型" class="headerlink" title="5.6 基本包装类型"></a>5.6 基本包装类型</h2><p>为了便于操作基本类型值， ECMAScript 还提供了 3 个特殊的引用类型：Boolean、Number 和 String。这些类型与本章介绍的其他引用类型相似，但同时也具有与各自的基本类型相应的特殊行为。 实际上，每当读取一个基本类型值的时候，后台就会创建一个对应的基本包装类型的对象，从而让我们 能够调用一些方法来操作这些数据。</p>
<pre><code class="js">var s1 = &quot;some text&quot;;
var s2 = s1.substring(2);</code></pre>
<p>这个例子中的变量 s1 包含一个字符串， 字符串当然是基本类型值。 而下一行调用了 s1 的 substring()方法，并将返回的结果保存在了 s2 中。我们知道，基本类型值不是对象，因而从逻辑上 讲它们不应该有方法（尽管如我们所愿，它们确实有方法）。其实，为了让我们实现这种直观的操作， 后台已经自动完成了一系列的处理。当第二行代码访问 s1 时，访问过程处于一种读取模式，也就是要 从内存中读取这个字符串的值。而在读取模式中访问字符串时，后台都会自动完成下列处理。</p>
<ol>
<li>创建 String 类型的一个实例；</li>
<li>在实例上调用指定的方法；</li>
<li>销毁这个实例。</li>
</ol>
<p>引用类型与基本包装类型的主要区别就是对象的生存期。使用 new 操作符创建的引用类型的实例， 在执行流离开当前作用域之前都一直保存在内存中。而自动创建的基本包装类型的对象，则只存在于一 行代码的执行瞬间，然后立即被销毁。这意味着我们不能在运行时为基本类型值添加属性和方法。</p>
<h2 id="5-6-1-Boolean类型"><a href="#5-6-1-Boolean类型" class="headerlink" title="5.6.1 Boolean类型"></a>5.6.1 Boolean类型</h2><p>Boolean 类型是与布尔值对应的引用类型。要创建 Boolean 对象，可以像下面这样调用 Boolean 构造函数并传入 true 或 false 值。</p>
<p><code>var booleanObject = new Boolean(true);</code></p>
<p>Boolean 类型的实例重写了 valueOf()方法，返回基本类型值 true 或 false；重写了 toString() 方法，返回字符串”true”和”false”。可是，Boolean 对象在 ECMAScript 中的用处不大，因为它经 常会造成人们的误解。其中最常见的问题就是在布尔表达式中使用 Boolean 对象</p>
<pre><code class="js">var falseObj = new Boolean(false)
var result = falseObj &amp;&amp; true 
result // true 此时falseObj没有进行求值  仅仅是把falseObj当成一个 obj对象

var falseValue = false;
result = falseValue &amp;&amp; true;
alert(result); //false</code></pre>
<blockquote>
<p>基本类型与引用类型的布尔值还有两个区别。首先，typeof 操作符对基本类型返回”boolean”， 而对引用类型返回”object”。其次，由于 Boolean 对象是 Boolean 类型的实例，所以使用 instanceof 操作符测试 Boolean 对象会返回 true，而测试基本类型的布尔值则返回 false。</p>
</blockquote>
<h2 id="5-6-2-Number类型"><a href="#5-6-2-Number类型" class="headerlink" title="5.6.2 Number类型"></a>5.6.2 Number类型</h2><p>Number 是与数字值对应的引用类型。要创建 Number 对象，可以在调用 Number 构造函数时向其 中传递相应的数值。</p>
<p><code>var num = new Number(10)</code></p>
<p>与 Boolean 类型一样，Number 类型也重写了 valueOf()、toLocaleString()和 toString() 方法。重写后的 valueOf()方法返回对象表示的基本类型的数值，另外两个方法则返回字符串形式的数值。我们在第 3 章还介绍过，可以为 toString()方法传递一个表示基数的参数，告诉它返回几进制 数值的字符串形式，如下面的例子所示。</p>
<pre><code class="js">var num = 10
alert(num.toString()); // 10
alert(num.toString(2)); // 1010
alert(num.toString(8)); //12
alert(num.toString(10)); //10
alert(num.toString(16)); //a</code></pre>
<p>除了继承的方法之外，Number 类型还提供了一些用于将数值格式化为字符串的方法。</p>
<p> 其中，toFixed()方法会按照指定的小数位返回数值的字符串表示</p>
<pre><code class="js">var num = new Number(10)
num.toFixed(2) // 10.00

var a = 10.005
a.toFixed(2) // 10.01</code></pre>
<h2 id="5-6-3-String-类型"><a href="#5-6-3-String-类型" class="headerlink" title="5.6.3 String 类型"></a>5.6.3 String 类型</h2><p>String 类型是字符串的对象包装类型，可以像下面这样使用 String 构造函数来创建。</p>
<p><code>var str = new String(&#39;hello world&#39;)</code></p>
<p>String 对象的方法也可以在所有基本的字符串值中访问到。其中，继承的 valueOf()、toLocaleString()和 toString()方法，都返回对象所表示的基本字符串值。</p>
<p>String 类型的每个实例都有一个 length 属性，表示字符串中包含多个字符。</p>
<pre><code class="js">var str = &#39;hello world&#39;
str.length  // 11</code></pre>
<p>String 类型提供了很多方法，用于辅助完成对 ECMAScript 中字符串的解析和操作。</p>
<ol>
<li>字符方法</li>
</ol>
<p>两个用于访问字符串中特定字符的方法是：charAt()和 charCodeAt()。这两个方法都接收一个 参数，即基于 0 的字符位置。其中，charAt()方法以单字符字符串的形式返回给定位置的那个字符 （ECMAScript 中没有字符类型）。</p>
<pre><code class="js">var str = &#39;hello world&#39;
str.charAt(1) // e
str.charCodeAt(1) // 101 输出的是&quot;101&quot;，也就是小写字母&quot;e&quot;的字符编码</code></pre>
<p>ECMAScript 5 还定义了另一个访问个别字符的方法。在支持此方法的浏览器中，可以使用方括号加数 字索引来访问字符串中的特定字符</p>
<pre><code class="js">var str = &#39;hello world&#39;
str[1] // e</code></pre>
<ol start="2">
<li>字符串操作方法</li>
</ol>
<p><code>concat()</code>  拼接字符串,返回一个新字符串</p>
<pre><code class="js">var str = &#39;hello &#39;
var result = str.concat(&#39;world&#39;)
result // hello world
str // hello</code></pre>
<blockquote>
<p>concat()方法可以接受任意多个参数，也就是说可以通过它 拼接任意多个字符串。</p>
</blockquote>
<pre><code class="js">var str = &#39;hello &#39;
var result = str.concat(&#39;world&#39;,&#39;~&#39;)
result // hello world~</code></pre>
<p>ECMAScript 还提供了三个基于子字符串创建新字符串的方法：slice()、substr()和 substring()。 这三个方法都会返回被操作字符串的一个子字符串，而且也都接受一或两个参数。</p>
<pre><code class="js">var str = &#39;hello world&#39;

str.slice(3) // lo world
str.substr(3) // lo world
str.substring(3)// lo world

str.slice(3,7) // lo w
str.substr(3,7) //lo worl
str.substring(3,7) //lo w</code></pre>
<p>在传递给这些方法的参数是负值的情况下，它们的行为就不尽相同了。其中，slice()方法会将传 入的负值与字符串的长度相加，substr()方法将负的第一个参数加上字符串的长度，而将负的第二个 参数转换为 0。最后，substring()方法会把所有负值参数都转换为 0。</p>
<ol start="3">
<li>字符串位置方法</li>
</ol>
<p>有两个可以从字符串中查找子字符串的方法：indexOf()和 lastIndexOf()。这两个方法都是从 一个字符串中搜索给定的子字符串，然后返子字符串的位置（如果没有找到该子字符串，则返回-1）。 这两个方法的区别在于：indexOf()方法从字符串的开头向后搜索子字符串，而 lastIndexOf()方法 是从字符串的末尾向前搜索子字符串。</p>
<pre><code class="js">var stringValue = &quot;hello world&quot;;
alert(stringValue.indexOf(&quot;o&quot;));  //4
alert(stringValue.lastIndexOf(&quot;o&quot;)); // 7</code></pre>
<p>这两个方法都可以接收可选的第二个参数， 表示从字符串中的哪个位置开始搜索。 换句话说， indexOf()会从该参数指定的位置向后搜索，忽略该位置之前的所有字符；而 lastIndexOf()则会从 指定的位置向前搜索，忽略该位置之后的所有字符。</p>
<pre><code class="js">var stringValue = &quot;hello world&quot;;
alert(stringValue.indexOf(&quot;o&quot;, 6)); //7
alert(stringValue.lastIndexOf(&quot;o&quot;, 6)); //4</code></pre>
<ol start="4">
<li>trim()方法</li>
</ol>
<p>ECMAScript 5 为所有字符串定义了 trim()方法。这个方法会创建一个字符串的副本，删除前置及 后缀的所有空格，然后返回结果。</p>
<pre><code class="js">var str = &#39;  hello world  &#39;
var newStr = str.trim() 
newStr // hello wold 去除了两端空格
str //  hello world  原字符串</code></pre>
<ol start="5">
<li>字符串大小写转换方法</li>
</ol>
<p>toLowerCase()  全部转换为小写</p>
<p>toUpperCase() 全部转换为大写</p>
<p>返回一个新的字符串</p>
<pre><code class="js">var str = &#39;hello world&#39;
var newStr = str.toUpperCase() //HELLO WORLD</code></pre>
<ol start="6">
<li>字符串的模式匹配方法</li>
</ol>
<p>String 类型定义了几个用于在字符串中匹配模式的方法。第一个方法就是 match()，在字符串上 调用这个方法，本质上与调用 RegExp 的exec()方法相同。match()方法只接受一个参数，要么是一 个正则表达式，要么是一个 RegExp 对象。</p>
<pre><code class="js">var text = &quot;cat, bat, sat, fat&quot;;
var pattern = /.at/;
var matches = text.match(pattern);
alert(matches.index); // 0
alert(matches[0]); //cat
alert(pattern.lastIndex); //0</code></pre>
<p>另一个用于查找模式的方法是 search()。这个方法的唯一参数与 match()方法的参数相同：由字 符串或 RegExp 对象指定的一个正则表达式。search()方法返回字符串中第一个匹配项的索引；如果没 有找到匹配项，则返回-1。而且，search()方法始终是从字符串开头向后查找模式。</p>
<pre><code class="js">var text = &quot;cat, bat, sat, fat&quot;;
var pos = text.search(/at/)
pos // 1</code></pre>
<p>这个例子中的 search()方法返回 1，即”at”在字符串中第一次出现的位置。</p>
<p>为了简化替换子字符串的操作，ECMAScript 提供了 replace()方法。这个方法接受两个参数：第 一个参数可以是一个 RegExp 对象或者一个字符串（这个字符串不会被转换成正则表达式），第二个参 数可以是一个字符串或者一个函数。如果第一个参数是字符串，那么只会替换第一个子字符串。要想替 换所有子字符串，唯一的办法就是提供一个正则表达式，而且要指定全局（g）标志</p>
<pre><code class="js">var text = &quot;cat, bat, sat, fat&quot;;
text.replace(/at/g,&#39;on&#39;)
text // con,bon,son,fon</code></pre>
<p>最后一个与模式匹配有关的方法是 split()，这个方法可以基于指定的分隔符将一个字符串分割成 多个子字符串，并将结果放在一个数组中。分隔符可以是字符串，也可以是一个 RegExp 对象（这个方 法不会将字符串看成正则表达式）。split()方法可以接受可选的第二个参数，用于指定数组的大小， 以便确保返回的数组不会超过既定大小。</p>
<pre><code class="js">var colorText = &quot;red,blue,green,yellow&quot;;
var colors1 = colorText.split(&quot;,&quot;); //[&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;yellow&quot;]
var colors2 = colorText.split(&quot;,&quot;, 2); //[&quot;red&quot;, &quot;blue&quot;] 
</code></pre>
<p>localeCompare()方法  fromCharCode()方法  有需要再看</p>
<h1 id="5-7-单体内置对象"><a href="#5-7-单体内置对象" class="headerlink" title="5.7 单体内置对象"></a>5.7 单体内置对象</h1><p>单体内置对象：Global 和 Math。</p>
<h2 id="5-7-1-Global对象"><a href="#5-7-1-Global对象" class="headerlink" title="5.7.1 Global对象"></a>5.7.1 Global对象</h2><p>Global（全局）对象可以说是 ECMAScript 中最特别的一个对象了，因为不管你从什么角度上看， 这个对象都是不存在的。ECMAScript 中的 Global 对象在某种意义上是作为一个终极的“兜底儿对象” 来定义的。换句话说，不属于任何其他对象的属性和方法，最终都是它的属性和方法。事实上，没有全 局变量或全局函数；所有在全局作用域中定义的属性和函数，都是 Global 对象的属性。本书前面介绍 过的那些函数，诸如 isNaN()、isFinite()、parseInt()以及 parseFloat()，实际上全都是 Global 对象的方法。除此之外，Global 对象还包含其他一些方法。</p>
<ol>
<li>URI 编码方法</li>
</ol>
<p>Global 对象的 encodeURI() 和 encodeURIComponent() 方法可以对 URI（Uniform Resource Identifiers，通用资源标识符）进行编码，以便发送给浏览器。有效的 URI 中不能包含某些字符，例如 空格。而这两个 URI 编码方法就可以对 URI 进行编码，它们用特殊的 UTF-8 编码替换所有无效的字符， 从而让浏览器能够接受和理解。</p>
<p>其中，encodeURI()主要用于整个 URI（例如，<a href="http://www.wrox.com/illegal">http://www.wrox.com/illegal</a> value.htm），而 encodeURIComponent()主要用于对 URI 中的某一段（例如前面 URI 中的 illegal value.htm）进行编码。 它们的主要区别在于，encodeURI()不会对本身属于 URI 的特殊字符进行编码，例如冒号、正斜杠、 问号和井字号；而 encodeURIComponent()则会对它发现的任何非标准字符进行编码。</p>
<pre><code class="js">var uri = &quot;http://www.wrox.com/illegal value.htm#start&quot;;
alert(encodeURI(uri)); //&quot;http://www.wrox.com/illegal%20value.htm#start&quot;
alert(encodeURIComponent(uri)); // //&quot;http%3A%2F%2Fwww.wrox.com%2Fillegal%20value.htm%23start&quot;</code></pre>
<p>使用 encodeURI() 编码后的结果是除了空格之外的其他字符都原封不动， 只有空格被替换成了 %20。而 encodeURIComponent()方法则会使用对应的编码替换所有非字母数字字符。这也正是可以 对整个 URI 使用 encodeURI()，而只能对附加在现有 URI 后面的字符串使用 encodeURIComponent() 的原因所在。</p>
<p>与 encodeURI() 和 encodeURIComponent() 方法对应的两个方法分别是 decodeURI() 和 decodeURIComponent()。其中，decodeURI()只能对使用 encodeURI()替换的字符进行解码。例如， 它可将%20 替换成一个空格，但不会对%23 作任何处理，因为%23 表示井字号（#），而井字号不是使用 encodeURI()替换的。同样地，decodeURIComponent()能够解码使用 encodeURIComponent()编码的所有字符，即它可以解码任何特殊字符的编码。</p>
<ol start="2">
<li>eval()方法</li>
</ol>
<p>现在，我们介绍最后一个——大概也是整个 ECMAScript 语言中最强大的一个方法：eval()。eval() 方法就像是一个完整的 ECMAScript 解析器，它只接受一个参数，即要执行的 ECMAScript（或 JavaScript） 字符串。</p>
<p><code>eval(&#39;alert(&#39;hi&#39;)&#39;)</code>等同于<code>alert(&#39;hi&#39;)</code></p>
<p>当解析器发现代码中调用 eval()方法时，它会将传入的参数当作实际的 ECMAScript 语句来解析， 然后把执行结果插入到原位置。通过 eval()执行的代码被认为是包含该次调用的执行环境的一部分， 因此被执行的代码具有与该执行环境相同的作用域链。这意味着通过 eval()执行的代码可以引用在包 含环境中定义的变量</p>
<pre><code class="js">var msg = &quot;hello world&quot;;
eval(&#39;alert(msg)&#39;)  //hello world</code></pre>
<p>可见，变量 msg 是在 eval()调用的环境之外定义的，但其中调用的 alert()仍然能够显示”hello world”。这是因为上面第二行代码最终被替换成了一行真正的代码。同样地，我们也可以在 eval() 调用中定义一个函数，然后再在该调用的外部代码中引用这个函数：</p>
<pre><code class="js">eval(&quot;function sayHi() { alert(&#39;hi&#39;); }&quot;);
sayHi();</code></pre>
<blockquote>
<p>在 eval()中创建的任何变量或函数都不会被提升，因为在解析代码的时候，它们被包含在一个字 符串中；它们只在 eval()执行的时候创建。</p>
</blockquote>
<ol start="3">
<li>Global 对象的属性</li>
</ol>
<p>Global 对象还包含一些属性， 其中一部分属性已经在本书前面介绍过了。 例如， 特殊的值 undefined、NaN 以及 Infinity 都是 Global 对象的属性。此外，所有原生引用类型的构造函数，像 Object 和 Function，也都是 Global 对象的属性。下表列出了 Global 对象的所有属性。</p>
<ol start="4">
<li>window 对象</li>
</ol>
<p>ECMAScript 虽然没有指出如何直接访问 Global 对象，但 Web 浏览器都是将这个全局对象作为 window 对象的一部分加以实现的。因此，在全局作用域中声明的所有变量和函数，就都成为了 window 对象的属性。</p>
<p>取得全局对象的方法</p>
<pre><code class="js">var global = function(){
  return this
}()</code></pre>
<h2 id="5-7-2-Math对象"><a href="#5-7-2-Math对象" class="headerlink" title="5.7.2 Math对象"></a>5.7.2 Math对象</h2><p>ECMAScript 还为保存数学公式和信息提供了一个公共位置，即 Math 对象。与我们在 JavaScript 直 接编写的计算功能相比，Math 对象提供的计算功能执行起来要快得多。Math 对象中还提供了辅助完成 这些计算的属性和方法。</p>
<ol>
<li>Math 对象的属性</li>
</ol>
<p>Math.E 自然对数的底数</p>
<ol start="2">
<li>min()和max()方法</li>
</ol>
<p>Math 对象还包含许多方法，用于辅助完成简单和复杂的数学计算。</p>
<pre><code class="js">var max = Math.max(3, 54, 32, 16);
//54
var min = Math.min(3, 54, 32, 16);
//3</code></pre>
<p>要找到数组中的最大或最小值，可以像下面这样使用 apply()方法。</p>
<pre><code class="js">var values = [1, 2, 3, 4, 5, 6, 7, 8];
var max = Math.max.apply(Math,values)
//这个技巧的关键是把 Math 对象作为 apply()的第一个参数，从而正确地设置 this 值。然后，可 以将任何数组作为第二个参数。</code></pre>
<ol start="3">
<li>舍入方法</li>
</ol>
<ul>
<li>Math.ceil()  执行向上舍入，即它总是将数值向上舍入为最接近的整数；</li>
<li>Math.floor()执行向下舍入，即它总是将数值向下舍入为最接近的整数；</li>
<li>Math.round() 执行标准舍入，即它总是将数值四舍五 上学到的舍入规则）。</li>
</ul>
<ol start="4">
<li>random()方法</li>
</ol>
<p>Math.random()方法返回大于等于 0 小于 1 的一个随机数。对于某些站点来说，这个方法非常实用， 12 因为可以利用它来随机显示一些名人名言和新闻事件。套用下面的公式，就可以利用 Math.random() 从某个整数范围内随机选择一个值。</p>
<p><code>值 = Math.floor(Math.random() * 可能值的总数 + 第一个可能的值)</code></p>
</div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/passages/%E3%80%90JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%91%E7%AC%AC%E5%85%AD%E7%AB%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"><img class="thumbnail" src="https://s2.ax1x.com/2019/08/19/mlQ5rj.jpg" alt="【JS高级程序设计】第六章 面向对象的程序设计"></a></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-04-06T14:04:03.000Z" title="2020-04-06T14:04:03.000Z">2020-04-06</time><span class="level-item"><a class="link-muted" href="/categories/javascript/">javascript</a></span><span class="level-item">37 分钟 读完 (大约 5581 个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/passages/%E3%80%90JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%91%E7%AC%AC%E5%85%AD%E7%AB%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">【JS高级程序设计】第六章 面向对象的程序设计</a></h1><div class="content"><p>面向对象（Object-Oriented，OO）的语言有一个标志，那就是它们都有类的概念，而通过类可 以创建任意多个具有相同属性和方法的对象。前面提到过，ECMAScript 中没有类的概念，因 此它的对象也与基于类的语言中的对象有所不同。</p>
<h1 id="6-1-理解对象"><a href="#6-1-理解对象" class="headerlink" title="6.1  理解对象"></a>6.1  理解对象</h1><p>简单创建一个对象</p>
<pre><code class="js">var person = new Object()
person.name = &#39;chenyu&#39;
person.age = 25
person.sayName = function(){
  return this.name
}</code></pre>
<p>使用字面量创建对象</p>
<pre><code class="js">var person = {
  name: &quot;chenyu&quot;,
  age:25,
  sayName:function(){
    return this.name
  }
}</code></pre>
<h2 id="6-1-1-属性类型"><a href="#6-1-1-属性类型" class="headerlink" title="6.1.1 属性类型"></a>6.1.1 属性类型</h2><p>ECMAScript 中有两种属性：数据属性和访问器属性。</p>
<ol>
<li>数据属性</li>
</ol>
<ul>
<li>[[Configurable]]：表示能否通过 delete 删除属性从而重新定义属性，能否修改属性的特 性，或者能否把属性修改为访问器属性。像前面例子中那样直接在对象上定义的属性，它们的 这个特性默认值为 true。</li>
<li>[[Enumerable]]：表示能否通过 for-in 循环返回属性。像前面例子中那样直接在对象上定 义的属性，它们的这个特性默认值为 true。</li>
<li>[[Writable]]：表示能否修改属性的值。像前面例子中那样直接在对象上定义的属性，它们的 这个特性默认值为 true。</li>
<li>[[Value]]：包含这个属性的数据值。读取属性值的时候，从这个位置读；写入属性值的时候， 把新值保存在这个位置。这个特性的默认值为 undefined。</li>
</ul>
<p>对于像前面例子中那样直接在对象上定义的属性，它们的[[Configurable]]、[[Enumerable]] 和[[Writable]]特性都被设置为 true，而[[Value]]特性被设置为指定的值。</p>
<p>要修改属性默认的特性，必须使用 ECMAScript 5 的 Object.defineProperty()方法。这个方法 接收三个参数：属性所在的对象、属性的名字和一个描述符对象。其中，描述符（descriptor）对象的属 性必须是：configurable、enumerable、writable 和 value。设置其中的一或多个值，可以修改 对应的特性值。</p>
<pre><code class="js">var person = {}
Object.defineProperty(&#39;person&#39;,&#39;name&#39;,{
  value:&quot;chenyu&quot;,
  writable:false
})

person.name // chenyu
person.name = &#39;test&#39; 
person.name // chenyu</code></pre>
<p>类似的规则也适用于不可配置的属性。</p>
<pre><code class="js">var person = {}
Object.defineProperty(&#39;person&#39;,&#39;name&#39;,{
  value:&quot;chenyu&quot;,
  configurable:false
})

person.name // chenyu
person.name = &#39;test&#39; 
delete person.name //false
person.name // chenyu</code></pre>
<p>一旦把属性定义为不可配置的， 就不能再把它变回可配置了。</p>
<p>此时，再调用 Object.defineProperty()方法修改除 writable 之外 的特性，都会导致错误</p>
<blockquote>
<p>在调用 Object.defineProperty() 方法时， 如果不指定， configurable 、 enumerable 和 writable 特性的默认值都是 false。多数情况下，可能都没有必要利用 Object.defineProperty() 方法提供的这些高级功能。不过，理解这些概念对理解 JavaScript 对象却非常有用。</p>
</blockquote>
<ol start="2">
<li>访问器属性</li>
</ol>
<p>访问器属性不包含数据值；它们包含一对儿 getter 和 setter 函数（不过，这两个函数都不是必需的）。 在读取访问器属性时，会调用 getter 函数，这个函数负责返回有效的值；在写入访问器属性时，会调用 setter 函数并传入新值，这个函数负责决定如何处理数据。访问器属性有如下 4 个特性。</p>
<ul>
<li>[[Configurable]]：表示能否通过 delete 删除属性从而重新定义属性，能否修改属性的特 性， 或者能否把属性修改为数据属性。 对于直接在对象上定义的属性， 这个特性的默认值为 true。</li>
<li>[[Enumerable]]：表示能否通过 for-in 循环返回属性。对于直接在对象上定义的属性，这 个特性的默认值为 true。</li>
<li>[[Get]]：在读取属性时调用的函数。默认值为 undefined。</li>
<li>[[Set]]：在写入属性时调用的函数。默认值为 undefined。</li>
</ul>
<pre><code class="js">var book = { _year: 2004, edition: 1 };
Object.defineProperty(book,&#39;year&#39;,{
  get:function(){
    return this._year
  },
  set:function(newValue){
    if(newValue &gt; this._year){
       this._year = newValue
      this.edition += newValue - 2004
       }
  }
})</code></pre>
<p>以上代码创建了一个 book 对象，并给它定义两个默认的属性：_year 和 edition。_year 前面 的下划线是一种常用的记号，用于表示只能通过对象方法访问的属性。而访问器属性 year 则包含一个 getter 函数和一个 setter 函数。getter 函数返回_year 的值，setter 函数通过计算来确定正确的版本。因此， 把 year 属性修改为 2005 会导致_year 变成 2005，而 edition 变为 2。这是使用访问器属性的常见方 式，即设置一个属性的值会导致其他属性发生变化。</p>
<p>不一定非要同时指定 getter 和 setter。只指定 getter 意味着属性是不能写，尝试写入属性会被忽略。 在严格模式下，尝试写入只指定了 getter 函数的属性会抛出错误。类似地，只指定 setter 函数的属性也 不能读，否则在非严格模式下会返回 undefined，而在严格模式下会抛出错误。</p>
<blockquote>
<p>支持 ECMAScript 5 的这个方法的浏览器有 IE9+（IE8 只是部分实现）、Firefox 4+、Safari 5+、Opera 12+ 和 Chrome 。 在 这 个 方 法 之 前 ， 要 创 建 访 问 器 属 性 ， 一 般 都 使 用 两 个 非 标 准 的 方 法 ： __defineGetter__()和__defineSetter__()。这两个方法最初是由 Firefox 引入的，后来 Safari 3、 Chrome 1 和 Opera 9.5 也给出了相同的实现。</p>
</blockquote>
<h2 id="6-1-2-定义多个属性"><a href="#6-1-2-定义多个属性" class="headerlink" title="6.1.2 定义多个属性"></a>6.1.2 定义多个属性</h2><p>由于为对象定义多个属性的可能性很大， ECMAScript 5 又定义了一个 Object.defineProperties()方法。利用这个方法可以通过描述符一次定义多个属性。这个方法接收两个对象参数：第一 个对象是要添加和修改其属性的对象，第二个对象的属性与第一个对象中要添加或修改的属性一一对 应。</p>
<pre><code class="js">var person  = {}
Object.defineProperties(person,{
  _year:{
    value:2004
  },
  edition:{
    value:1
  },
  name:{
    value:&#39;chenyu&#39;,
    configurable:false
  },
  year:{
    get:function(){
      return this._year
    },
    set:function(newValue){
      if(newValue &gt; 2004){
             this._year = newValue,
            this.edition += newValue - 2004
         }
    }
  }
})</code></pre>
<h2 id="6-1-3-读取属性的特性"><a href="#6-1-3-读取属性的特性" class="headerlink" title="6.1.3 读取属性的特性"></a>6.1.3 读取属性的特性</h2><p>使用 ECMAScript 5 的 Object.getOwnPropertyDescriptor()方法，可以取得给定属性的描述符。这个方法接收两个参数：属性所在的对象和要读取其描述符的属性名称。返回值是一个对象，如果 是访问器属性，这个对象的属性有 configurable、enumerable、get 和 set；如果是数据属性，这 个对象的属性有 configurable、enumerable、writable 和 value</p>
<pre><code class="js">var person  = {}
Object.defineProperties(person,{
  _year:{
    value:2004
  },
  edition:{
    value:1
  },
  name:{
    value:&#39;chenyu&#39;,
    configurable:false
  },
  year:{
    get:function(){
      return this._year
    },
    set:function(newValue){
      if(newValue &gt; 2004){
             this._year = newValue,
            this.edition += newValue - 2004
         }
    }
  }
})

var properties = Object.getOwnPropertyDescriptor(book,&#39;name&#39;) 
// {value: &quot;chenyu&quot;, writable: false, enumerable: false, configurable: false}
Object.getOwnPropertyDescriptor(person,&#39;year&#39;)
//{enumerable: false, configurable: false, get: ƒ, set: ƒ}</code></pre>
<h1 id="6-2-创建对象"><a href="#6-2-创建对象" class="headerlink" title="6.2 创建对象"></a>6.2 创建对象</h1><p>虽然 Object 构造函数或对象字面量都可以用来创建单个对象，但这些方式有个明显的缺点：使用同 一个接口创建很多对象，会产生大量的重复代码。为解决这个问题，人们开始使用工厂模式的一种变体。</p>
<h2 id="6-2-1-工厂模式（用于创建出相似的对象）"><a href="#6-2-1-工厂模式（用于创建出相似的对象）" class="headerlink" title="6.2.1 工厂模式（用于创建出相似的对象）"></a>6.2.1 工厂模式（用于创建出相似的对象）</h2><p>工厂模式是软件工程领域一种广为人知的设计模式，这种模式抽象了创建具体对象的过程，考虑到在 ECMAScript 中无法创建类，开发人员 就发明了一种函数，用函数来封装以特定接口创建对象的细节。</p>
<pre><code class="js">function createPerson(name,age,job){
  var o = new Object()
  o.name = name
  o.age = age
  o.job = job
  o.sayName = function(){
    alert(this.name)
  }
  return o
}

var tom = createPerson(&#39;tom&#39;,20,&#39;The engineer&#39;)
var jerry = createPerson(&#39;jerry&#39;,20,&#39;mouse&#39;)</code></pre>
<p>函数 createPerson()能够根据接受的参数来构建一个包含所有必要信息的 Person 对象。可以无 数次地调用这个函数，而每次它都会返回一个包含三个属性一个方法的对象。工厂模式虽然解决了创建 多个相似对象的问题，但却没有解决对象识别的问题（即怎样知道一个对象的类型）。随着 JavaScript 的发展，又一个新模式出现了。</p>
<h2 id="6-2-2-构造函数模式（区别对象的类型）"><a href="#6-2-2-构造函数模式（区别对象的类型）" class="headerlink" title="6.2.2 构造函数模式（区别对象的类型）"></a>6.2.2 构造函数模式（区别对象的类型）</h2><p>上述代码可以改写成：</p>
<pre><code class="js">function Person(name,age,job){
  this.name = name
  this.age = age
  this.job = job
  this.sayName = function(){
    alert(this.name)
  }
}
var tom = new Person(&#39;tom&#39;,20,&#39;The engineer&#39;)
var jerry = new Person(&#39;jerry&#39;,20,&#39;mouse&#39;)</code></pre>
<p>创建了两个实例对象Tom、Jerry，他们都有一个构造函数属性指向构造函数</p>
<pre><code class="js">tom.constructor  == Person
jerry.constructor  == Person</code></pre>
<p>在这个例子中，Person()函数取代了 createPerson()函数。我们注意到，Person()中的代码 除了与 createPerson()中相同的部分外，还存在以下不同之处：</p>
<ul>
<li>没有显式地创建对象；</li>
<li>直接将属性和方法赋给了 this 对象；</li>
<li>没有 return 语句</li>
</ul>
<blockquote>
<p>此外，还应该注意到函数名 Person 使用的是大写字母 P。按照惯例，构造函数始终都应该以一个 大写字母开头，而非构造函数则应该以一个小写字母开头。这个做法借鉴自其他 OO 语言，主要是为了 区别于 ECMAScript 中的其他函数；因为构造函数本身也是函数，只不过可以用来创建对象而已。</p>
</blockquote>
<p>要创建 Person 的新实例，必须使用 new 操作符。以这种方式调用构造函数实际上会经历以下 4 个步骤：</p>
<ol>
<li>创建一个新对象；</li>
<li>将函数的作用域赋值给新对象，当前的this会指向新对象</li>
<li>执行构造函数中的代码（为这个新对象添加属性）；</li>
<li>返回新对象</li>
</ol>
<p>对象的 constructor 属性最初是用来标识对象类型的。但是，提到检测对象类型，还是 instanceof 操作符要更可靠一些。我们在这个例子中创建的所有对象既是 Object 的实例，同时也是 Person 的实例，这一点通过 instanceof 操作符可以得到验证。</p>
<pre><code class="js">tom instanceof Object // true
tom instanceof Person // true
jerry instanceof Object // true
jerry instanceof Person // true</code></pre>
<p>创建自定义的构造函数意味着将来可以将它的实例标识为一种特定的类型；而这正是构造函数模式 胜过工厂模式的地方。在这个例子中，person1 和 person2 之所以同时是 Object 的实例，是因为所 有对象均继承自 Object。</p>
<ol>
<li>将构造函数当作函数</li>
</ol>
<p>构造函数与其他函数的唯一区别，就在于调用它们的方式不同。不过，构造函数毕竟也是函数，不 存在定义构造函数的特殊语法。任何函数，只要通过 new 操作符来调用，那它就可以作为构造函数；而 任何函数，如果不通过 new 操作符来调用，那它跟普通函数也不会有什么两样。例如，前面例子中定义 的 Person()函数可以通过下列任何一种方式来调用。</p>
<pre><code class="js">// 当作构造函数使用
var person = new Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;); 
person.sayName();  //&quot;Nicholas&quot;

//当作普通函数使用
Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;); 
window.name  // Nicholas

//在另一个对象的作用域中调用
var o = new Object
Person.call(o,&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;)
o.name // Nicholas</code></pre>
<p>这个例子中的前两行代码展示了构造函数的典型用法，即使用 new 操作符来创建一个新对象。接下 来的两行代码展示了不使用 new 操作符调用 Person()会出现什么结果：属性和方法都被添加给 window 对象了。有读者可能还记得，当在全局作用域中调用一个函数时，this 对象总是指向 Global 对象（在 浏览器中就是 window 对象）。因此，在调用完函数之后，可以通过 window 对象来调用 sayName()方 法，并且还返回了”Greg”。最后，也可以使用 call()（或者 apply()）在某个特殊对象的作用域中 调用 Person()函数。这里是在对象 o 的作用域中调用的，因此调用后 o 就拥有了所有属性和 sayName() 方法。</p>
<ol start="2">
<li>构造函数的问题</li>
</ol>
<p>构造函数模式虽然好用，但也并非没有缺点。使用构造函数的主要问题，就是每个方法都要在每个 实例上重新创建一遍。在前面的例子中，person1 和 person2 都有一个名为 sayName()的方法，但那 两个方法不是同一个 Function 的实例。不要忘了——ECMAScript 中的函数是对象，因此每定义一个 函数，也就是实例化了一个对象。从逻辑角度讲，此时的构造函数也可以这样定义。</p>
<pre><code class="js">function Person(name, age, job){ this.name = name; this.age = age; this.job = job; this.sayName = new Function(&quot;alert(this.name)&quot;); // 与声明函数在逻辑上是等价的 }</code></pre>
<p>从这个角度上来看构造函数，更容易明白每个 Person 实例都包含一个不同的 Function 实例（以 显示 name 属性）的本质。说明白些，以这种方式创建函数，会导致不同的作用域链和标识符解析，但 创建 Function 新实例的机制仍然是相同的。</p>
<pre><code class="js">tom.sayName == jerry.sayName // false</code></pre>
<pre><code class="js">function Person(name, age, job){ this.name = name; this.age = age; this.job = job; this.sayName = sayName; }
function sayName(){
  alert(this.name)
}
var person1 = new Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;); 
var person2 = new Person(&quot;Greg&quot;, 27, &quot;Doctor&quot;);
person1.sayName == person2.sayName // true</code></pre>
<p>在这个例子中，我们把 sayName()函数的定义转移到了构造函数外部。而在构造函数内部，我们 将 sayName 属性设置成等于全局的 sayName 函数。这样一来，由于 sayName 包含的是一个指向函数 的指针，因此 person1 和 person2 对象就共享了在全局作用域中定义的同一个 sayName()函数。这 样做确实解决了两个函数做同一件事的问题，可是新问题又来了：在全局作用域中定义的函数实际上只 能被某个对象调用，这让全局作用域有点名不副实。而更让人无法接受的是：如果对象需要定义很多方 法，那么就要定义很多个全局函数，于是我们这个自定义的引用类型就丝毫没有封装性可言了。好在， 这些问题可以通过使用原型模式来解决。</p>
<h2 id="6-2-3-原型模式"><a href="#6-2-3-原型模式" class="headerlink" title="6.2.3 原型模式"></a>6.2.3 原型模式</h2><p>我们创建的每个函数都有一个 prototype（原型）属性，这个属性是一个指针，指向一个对象， 而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。如果按照字面意思来理解，那 么 prototype 就是通过调用构造函数而创建的那个对象实例的原型对象。使用原型对象的好处是可以 让所有对象实例共享它所包含的属性和方法。换句话说，不必在构造函数中定义对象实例的信息，而是 可以将这些信息直接添加到原型对象中，如下面的例子所示。</p>
<pre><code class="js">function Person(){ }
Person.prototype.name = &quot;Nicholas&quot;;
Person.prototype.age = 29; 
Person.prototype.job = &quot;Software Engineer&quot;; 
Person.prototype.sayName = function(){ alert(this.name); };
var person1 = new Person(); person1.sayName(); //&quot;Nicholas&quot;
var person2 = new Person();
person2.sayName(); //&quot;Nicholas&quot;
alert(person1.sayName == person2.sayName);//true</code></pre>
<p>在此，我们将 sayName()方法和所有属性直接添加到了 Person 的 prototype 属性中，构造函数 变成了空函数。即使如此，也仍然可以通过调用构造函数来创建新对象，而且新对象还会具有相同的属 性和方法。但与构造函数模式不同的是，新对象的这些属性和方法是由所有实例共享的。换句话说， person1 和 person2 访问的都是同一组属性和同一个 sayName()函数。要理解原型模式的工作原理， 必须先理解 ECMAScript 中原型对象的性质。</p>
<ol>
<li>理解原型对象</li>
</ol>
<p>无论什么时候，只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个 prototype 属性，这个属性指向函数的原型对象。在默认情况下，所有原型对象都会自动获得一个 constructor （构造函数）属性，这个属性包含一个指向 prototype 属性所在函数的指针。就拿前面的例子来说， Person.prototype. constructor 指向 Person。而通过这个构造函数，我们还可继续为原型对象 添加其他属性和方法。</p>
<p>创建了自定义的构造函数之后，其原型对象默认只会取得 constructor 属性；至于其他方法，则 都是从 Object 继承而来的。当调用构造函数创建一个新实例后，该实例的内部将包含一个指针（内部 属性），指向构造函数的原型对象。ECMA-262 第 5 版中管这个指针叫[[Prototype]]。虽然在脚本中 没有标准的方式访问 [[Prototype]] ， 但 Firefox、Safari 和 Chrome 在每个对象上都支持一个属性 <strong>proto</strong>；而在其他实现中，这个属性对脚本则是完全不可见的。<strong><em>不过，要明确的真正重要的一点就 是，这个连接存在于实例与构造函数的原型对象之间，而不是存在于实例与构造函数之间。</em></strong></p>
<p>虽然在所有实现中都无法访问到[[Prototype]]，但可以通过 isPrototypeOf()方法来确定对象之 间是否存在这种关系。 从本质上讲， 如果 [[Prototype]] 指向调用 isPrototypeOf() 方法的对象 （Person.prototype），那么这个方法就返回 true</p>
<pre><code class="js">Person.prototype.isProtytypeOf(person1) //true
Person.prototype.isPrototypeOf(person2) // true</code></pre>
<p>ECMAScript 5 增加了一个新方法，叫 Object.getPrototypeOf()，在所有支持的实现中，这个 方法返回[[Prototype]]的值。例如：</p>
<pre><code class="js">Object.getPrototypeOf(person1) == Person.prototype //true

Object.getPrototypeOf(person1).name //Nicholas</code></pre>
<blockquote>
<p>使用 Object.getPrototypeOf() 可以方便地取得一个对象的原型，而这在利用原型实现继承（本章稍后会讨论）的情况下是非常重要的。</p>
</blockquote>
<p>​    每当代码读取某个对象的某个属性时，都会执行一次搜索，目标是具有给定名字的属性。搜索首先 从对象实例本身开始。如果在实例中找到了具有给定名字的属性，则返回该属性的值；如果没有找到， 则继续搜索指针指向的原型对象，在原型对象中查找具有给定名字的属性。如果在原型对象中找到了这 个属性，则返回该属性的值。也就是说，在我们调用 person1.sayName()的时候，会先后执行两次搜 索。首先，解析器会问：“实例 person1 有 sayName 属性吗？”答：“没有。”然后，它继续搜索，再 问：“person1 的原型有 sayName 属性吗？”答：“有。”于是，它就读取那个保存在原型对象中的函 数。当我们调用 person2.sayName()时，将会重现相同的搜索过程，得到相同的结果。而这正是多个 对象实例共享原型所保存的属性和方法的基本原理。</p>
<blockquote>
<p>前面提到过，原型最初只包含 constructor 属性，而该属性也是共享的，因此 可以通过对象实例访问。</p>
</blockquote>
<p>如果在实例对象中定义的属性名与原型对象中的属性名冲突，则会屏蔽原型对象中的属性值</p>
<pre><code class="js">function Person(){}
Person.prototype,name = &#39;Nicholas&#39;
Person.prototype.age = 20
Person.prototype.sayName = function(){
  return this.name
}

var person1 = new Person()
var person2 = new Person()
person1.name // &#39;Nicholas&#39;
person1.name = &#39;chenyu&#39; 
person1.name // chenyu
person2.name // &#39;Nicholas&#39;</code></pre>
<p>在这个例子中，person1 的 name 被一个新值给屏蔽了。但无论访问 person1.name 还是访问 person2.name 都能够正常地返回值，即分别是”Greg”（来自对象实例）和”Nicholas”（来自原型）。 当在 alert()中访问 person1.name 时，需要读取它的值，因此就会在这个实例上搜索一个名为 name 的属性。这个属性确实存在，于是就返回它的值而不必再搜索原型了。当以同样的方式访问 person2. name 时，并没有在实例上发现该属性，因此就会继续搜索原型，结果在那里找到了 name 属性。</p>
<p>当为对象实例添加一个属性时，这个属性就会屏蔽原型对象中保存的同名属性；换句话说，添加这 个属性只会阻止我们访问原型中的那个属性，但不会修改那个属性。即使将这个属性设置为 null，也 只会在实例中设置这个属性，而不会恢复其指向原型的连接。不过，使用 delete 操作符则可以完全删 除实例属性，从而让我们能够重新访问原型中的属性，</p>
<pre><code class="js">delete person1.name 
person1.name // &quot;Nicholas&quot;</code></pre>
<p>使用 hasOwnProperty()方法可以检测一个属性是存在于实例中，还是存在于原型中。这个方法（不 要忘了它是从 Object 继承来的）只在给定属性存在于对象实例中时，才会返回 true。</p>
<p>## </p>
</div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/passages/%E3%80%90JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%91%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%8F%98%E9%87%8F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%86%85%E5%AD%98%E9%97%AE%E9%A2%98/"><img class="thumbnail" src="https://s2.ax1x.com/2019/08/19/mlQ5rj.jpg" alt="【JS高级程序设计】第四章 变量、作用域和内存问题"></a></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-04-05T15:37:18.000Z" title="2020-04-05T15:37:18.000Z">2020-04-05</time><span class="level-item"><a class="link-muted" href="/categories/javascript/">javascript</a></span><span class="level-item">39 分钟 读完 (大约 5820 个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/passages/%E3%80%90JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%91%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%8F%98%E9%87%8F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%86%85%E5%AD%98%E9%97%AE%E9%A2%98/">【JS高级程序设计】第四章 变量、作用域和内存问题</a></h1><div class="content"><h1 id="4-1基本类型和引用类型的值"><a href="#4-1基本类型和引用类型的值" class="headerlink" title="4.1基本类型和引用类型的值"></a>4.1基本类型和引用类型的值</h1><p>基本类型：</p>
<ul>
<li>undefined</li>
<li>null</li>
<li>Boolean</li>
<li>Number</li>
<li>String</li>
</ul>
<p>引用类型：</p>
<ul>
<li>Object</li>
<li>Function</li>
<li>Array</li>
</ul>
<p>引用类型的值是保存在内存中的对象。与其他语言不同，JavaScript 不允许直接访问内存中的位置， 也就是说不能直接操作对象的内存空间。在操作对象时，实际上是在操作对象的引用而不是实际的对象。 为此，引用类型的值是按引用访问的</div><a class="article-more button is-small size-small" href="/passages/%E3%80%90JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%91%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%8F%98%E9%87%8F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%86%85%E5%AD%98%E9%97%AE%E9%A2%98/#more">阅读更多</a></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/passages/%E3%80%90JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%91%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"><img class="thumbnail" src="https://s2.ax1x.com/2019/08/19/mlQ5rj.jpg" alt="【JS高级程序设计】第三章 基本概念"></a></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-04-01T13:38:17.000Z" title="2020-04-01T13:38:17.000Z">2020-04-01</time><span class="level-item"><a class="link-muted" href="/categories/javascript/">javascript</a></span><span class="level-item">1 小时 读完 (大约 8409 个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/passages/%E3%80%90JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%91%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/">【JS高级程序设计】第三章 基本概念</a></h1><div class="content"><h1 id="3-1语法"><a href="#3-1语法" class="headerlink" title="3.1语法"></a>3.1语法</h1><ul>
<li><p>区分大小写</p>
</li>
<li><p>不能使用关键字/保留字</p>
</li>
<li><p>统一的命名规则</p>
<blockquote>
<p>第一个字符必须是一个字母、下划线（_）或一个美元符号（$）；  其他字符可以是字母、下划线、美元符号或数字。 标识符中的字母也可以包含扩展的 ASCII 或 Unicode 字母字符（如 À 和 Æ），但我们不推荐这样做。</p>
<p><code>ECMAScript</code> 标识符采用<strong>驼峰大小写</strong>格式：</p>
<p>firstSecond myCar doSomethingImportant</p>
<p>虽然没有谁强制要求必须采用这种格式，但为了与 ECMAScript 内置的函数和对象命名格式保持一 致，可以将其当作一种最佳实践。</div><a class="article-more button is-small size-small" href="/passages/%E3%80%90JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%91%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/#more">阅读更多</a></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/passages/%E3%80%90JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%91%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%9C%A8HTML%E4%B8%AD%E4%BD%BF%E7%94%A8JavaScript/"><img class="thumbnail" src="https://s2.ax1x.com/2019/08/19/mlQ5rj.jpg" alt="【JS高级程序设计】 第二章 使用JavaScript"></a></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-04-01T09:31:16.000Z" title="2020-04-01T09:31:16.000Z">2020-04-01</time><span class="level-item"><a class="link-muted" href="/categories/javascript/">javascript</a></span><span class="level-item">11 分钟 读完 (大约 1578 个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/passages/%E3%80%90JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%91%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%9C%A8HTML%E4%B8%AD%E4%BD%BF%E7%94%A8JavaScript/">【JS高级程序设计】 第二章 使用JavaScript</a></h1><div class="content"><h1 id="2-1-“script”元素"><a href="#2-1-“script”元素" class="headerlink" title="2.1 “script”元素"></a>2.1 “script”元素</h1><p>向 HTML 页面中插入 JavaScript 的主要方法，就是使用&lt;/script&gt;元素。这个元素由 Netscape 创造 并在 Netscape Navigator 2 中首先实现。后来，这个元素被加入到正式的 HTML 规范中。HTML 4.01 为 &lt;/script&gt;定义了下列 6 个属性：</div><a class="article-more button is-small size-small" href="/passages/%E3%80%90JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%91%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%9C%A8HTML%E4%B8%AD%E4%BD%BF%E7%94%A8JavaScript/#more">阅读更多</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-03-13T09:25:11.000Z" title="2020-03-13T09:25:11.000Z">2020-03-13</time><span class="level-item"><a class="link-muted" href="/categories/centos/">centos</a></span><span class="level-item">3 分钟 读完 (大约 389 个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/passages/CentOS-%E9%98%B2%E7%81%AB%E5%A2%99-%E5%90%AF%E5%8A%A8-%E5%81%9C%E6%AD%A2-%E9%87%8D%E5%90%AF-%E6%B0%B8%E4%B9%85%E5%BC%80%E5%90%AF%E7%AB%AF%E5%8F%A3/">CentOS 防火墙 启动/停止/重启/永久开启端口</a></h1><div class="content"><pre><code class="bash"># &gt;&gt;&gt; 开启端口
firewall-cmd --zone=public --add-port=8000/tcp --permanent
#  命令含义：
--zone #作用域
--add-port=80/tcp #添加端口，格式为：端口/通讯协议
--permanent #永久生效，没有此参数重启后失效
# &gt;&gt;&gt; 重启防火墙
firewall-cmd --reload                          ##重启防火墙
firewall-cmd --state                           ##查看防火墙状态，是否是running
firewall-cmd --reload                          ##重新载入配置，比如添加规则之后，需要执行此命令
firewall-cmd --get-zones                       ##列出支持的zone
firewall-cmd --get-services                    ##列出支持的服务，在列表中的服务是放行的
firewall-cmd --query-service ftp               ##查看ftp服务是否支持，返回yes或者no
firewall-cmd --add-service=ftp                 ##临时开放ftp服务
firewall-cmd --add-service=ftp --permanent     ##永久开放ftp服务
firewall-cmd --remove-service=ftp --permanent  ##永久移除ftp服务
firewall-cmd --add-port=80/tcp --permanent     ##永久添加80端口 
iptables -L -n                                 ##查看规则，这个命令是和iptables的相同的
man firewall-cmd                               ##查看帮助</code></pre></div><a class="article-more button is-small size-small" href="/passages/CentOS-%E9%98%B2%E7%81%AB%E5%A2%99-%E5%90%AF%E5%8A%A8-%E5%81%9C%E6%AD%A2-%E9%87%8D%E5%90%AF-%E6%B0%B8%E4%B9%85%E5%BC%80%E5%90%AF%E7%AB%AF%E5%8F%A3/#more">阅读更多</a></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/passages/JavaScript-this/"><img class="thumbnail" src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7t524tjguj30zk0m87pc.jpg" alt="JavaScript this"></a></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2019-10-10T07:27:58.000Z" title="2019-10-10T07:27:58.000Z">2019-10-10</time><span class="level-item"><a class="link-muted" href="/categories/javascript/">javascript</a></span><span class="level-item">5 分钟 读完 (大约 761 个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/passages/JavaScript-this/">JavaScript this</a></h1><div class="content"><h2 id="this指向"><a href="#this指向" class="headerlink" title="this指向"></a>this指向</h2><p>在浏览器环境中，当前的全局this为window对象</div><a class="article-more button is-small size-small" href="/passages/JavaScript-this/#more">阅读更多</a></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/passages/JavaScript-%E5%87%BD%E6%95%B0/"><img class="thumbnail" src="https://tva1.sinaimg.cn/large/006y8mN6gy1g7sdp2drvjj30zk0m8e0z.jpg" alt="JavaScript 函数"></a></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2019-10-09T13:55:12.000Z" title="2019-10-09T13:55:12.000Z">2019-10-09</time><span class="level-item"><a class="link-muted" href="/categories/javascript/">javascript</a></span><span class="level-item">5 分钟 读完 (大约 772 个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/passages/JavaScript-%E5%87%BD%E6%95%B0/">JavaScript 函数</a></h1><div class="content"><h3 id="函数概念"><a href="#函数概念" class="headerlink" title="函数概念"></a>函数概念</h3><blockquote>
<p>函数是一块 JavaScript代码,被定义一次,但可执行和调用多次。JS中的函数也是对象,所以JS函数可以像其它对象那样操作和传递，所以我们也常叫JS中的函数为函数对象。</div><a class="article-more button is-small size-small" href="/passages/JavaScript-%E5%87%BD%E6%95%B0/#more">阅读更多</a></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/passages/JavaScript-%E6%95%B0%E7%BB%84/"><img class="thumbnail" src="https://tva1.sinaimg.cn/large/006y8mN6gy1g7sdsatyh4j30zk0m8h6s.jpg" alt="JavaScript 数组"></a></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2019-10-08T13:31:48.000Z" title="2019-10-08T13:31:48.000Z">2019-10-08</time><span class="level-item"><a class="link-muted" href="/categories/javascript/">javascript</a></span><span class="level-item">7 分钟 读完 (大约 1022 个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/passages/JavaScript-%E6%95%B0%E7%BB%84/">JavaScript 数组</a></h1><div class="content"><h3 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h3><blockquote>
<p>数组是特殊的Object，包含很多方法，创建数组的方法有很多：</p>
</blockquote>
<pre><code class="js">//数组的创建
var arr  = new Array(100) //创建一个长度为100的数组,所有的值都为undefined
var arr1 = new Array(&#39;1&#39;,&#39;2&#39;,true) //创建一个包含数值和固定下标的字符串
var arr2 = [] //快捷创建一个数组 </code></pre>
<h3 id="数组的方法"><a href="#数组的方法" class="headerlink" title="数组的方法"></a>数组的方法</h3><blockquote>
<p>获取所有的数组方法: Array.prototype   所有在原型链上的方法</div><a class="article-more button is-small size-small" href="/passages/JavaScript-%E6%95%B0%E7%BB%84/#more">阅读更多</a></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/passages/JavaScript-%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9/"><img class="thumbnail" src="https://tva1.sinaimg.cn/large/006y8mN6gy1g7se0zy0mej30zk0m8wzm.jpg" alt="JavaScript 重要知识点"></a></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2019-09-10T02:18:26.000Z" title="2019-09-10T02:18:26.000Z">2019-09-10</time><span class="level-item"><a class="link-muted" href="/categories/javascript/">javascript</a></span><span class="level-item">8 分钟 读完 (大约 1204 个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/passages/JavaScript-%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9/">JavaScript 重要知识点</a></h1><div class="content"><h3 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h3></div><a class="article-more button is-small size-small" href="/passages/JavaScript-%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9/#more">阅读更多</a></article></div><nav class="pagination is-centered mt-4" role="navigation" aria-label="pagination"><div class="pagination-previous is-invisible is-hidden-mobile"><a href="/page/0/">上一页</a></div><div class="pagination-next"><a href="/page/2/">下一页</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link is-current" href="/">1</a></li><li><a class="pagination-link" href="/page/2/">2</a></li></ul></nav></div><!--!--><div class="column column-right is-4-tablet is-4-desktop is-4-widescreen  order-3"><div class="card widget"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="is-rounded" src="https://avatars0.githubusercontent.com/u/29906331?s=460&amp;u=801fa238d3ef38451f6efdb19618e2e6a9125cdc&amp;v=4" alt="麦吹克斯"></figure><p class="title is-size-4 is-block line-height-inherit">麦吹克斯</p><p class="is-size-6 is-block">学习JavaScript，折腾MacOS</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>🌍一个地球</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">20</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">3</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">26</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="http://www.timemachine.top" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/CCYYZZNN"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com/CCYYZZNN"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><!--!--><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/categories/centos/"><span class="level-start"><span class="level-item">centos</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/javascript/"><span class="level-start"><span class="level-item">javascript</span></span><span class="level-end"><span class="level-item tag">17</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/macos/"><span class="level-start"><span class="level-item">macos</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><a class="media-left" href="/passages/%E3%80%90JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%91%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/"><p class="image is-64x64"><img class="thumbnail" src="https://s2.ax1x.com/2019/08/19/mlQ5rj.jpg" alt="【JS高级程序设计】第五章 引用类型"></p></a><div class="media-content size-small"><p><time dateTime="2020-04-06T14:04:03.000Z">2020-04-06</time></p><p class="title is-6"><a class="link-muted" href="/passages/%E3%80%90JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%91%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/">【JS高级程序设计】第五章 引用类型</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/javascript/">javascript</a></p></div></article><article class="media"><a class="media-left" href="/passages/%E3%80%90JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%91%E7%AC%AC%E5%85%AD%E7%AB%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"><p class="image is-64x64"><img class="thumbnail" src="https://s2.ax1x.com/2019/08/19/mlQ5rj.jpg" alt="【JS高级程序设计】第六章 面向对象的程序设计"></p></a><div class="media-content size-small"><p><time dateTime="2020-04-06T14:04:03.000Z">2020-04-06</time></p><p class="title is-6"><a class="link-muted" href="/passages/%E3%80%90JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%91%E7%AC%AC%E5%85%AD%E7%AB%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">【JS高级程序设计】第六章 面向对象的程序设计</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/javascript/">javascript</a></p></div></article><article class="media"><a class="media-left" href="/passages/%E3%80%90JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%91%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%8F%98%E9%87%8F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%86%85%E5%AD%98%E9%97%AE%E9%A2%98/"><p class="image is-64x64"><img class="thumbnail" src="https://s2.ax1x.com/2019/08/19/mlQ5rj.jpg" alt="【JS高级程序设计】第四章 变量、作用域和内存问题"></p></a><div class="media-content size-small"><p><time dateTime="2020-04-05T15:37:18.000Z">2020-04-05</time></p><p class="title is-6"><a class="link-muted" href="/passages/%E3%80%90JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%91%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%8F%98%E9%87%8F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%86%85%E5%AD%98%E9%97%AE%E9%A2%98/">【JS高级程序设计】第四章 变量、作用域和内存问题</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/javascript/">javascript</a></p></div></article><article class="media"><a class="media-left" href="/passages/%E3%80%90JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%91%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"><p class="image is-64x64"><img class="thumbnail" src="https://s2.ax1x.com/2019/08/19/mlQ5rj.jpg" alt="【JS高级程序设计】第三章 基本概念"></p></a><div class="media-content size-small"><p><time dateTime="2020-04-01T13:38:17.000Z">2020-04-01</time></p><p class="title is-6"><a class="link-muted" href="/passages/%E3%80%90JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%91%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/">【JS高级程序设计】第三章 基本概念</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/javascript/">javascript</a></p></div></article><article class="media"><a class="media-left" href="/passages/%E3%80%90JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%91%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%9C%A8HTML%E4%B8%AD%E4%BD%BF%E7%94%A8JavaScript/"><p class="image is-64x64"><img class="thumbnail" src="https://s2.ax1x.com/2019/08/19/mlQ5rj.jpg" alt="【JS高级程序设计】 第二章 使用JavaScript"></p></a><div class="media-content size-small"><p><time dateTime="2020-04-01T09:31:16.000Z">2020-04-01</time></p><p class="title is-6"><a class="link-muted" href="/passages/%E3%80%90JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%91%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%9C%A8HTML%E4%B8%AD%E4%BD%BF%E7%94%A8JavaScript/">【JS高级程序设计】 第二章 使用JavaScript</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/javascript/">javascript</a></p></div></article></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/archives/2020/04/"><span class="level-start"><span class="level-item">四月 2020</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/03/"><span class="level-start"><span class="level-item">三月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/10/"><span class="level-start"><span class="level-item">十月 2019</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/09/"><span class="level-start"><span class="level-item">九月 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/08/"><span class="level-start"><span class="level-item">八月 2019</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Array/"><span class="tag">Array</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CentOS/"><span class="tag">CentOS</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/DOM/"><span class="tag">DOM</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/DOM%E6%93%8D%E4%BD%9C/"><span class="tag">DOM操作</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/DOM%E6%96%87%E6%A1%A3%E5%AF%B9%E8%B1%A1/"><span class="tag">DOM文档对象</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/DOM%E7%BB%93%E6%9E%84/"><span class="tag">DOM结构</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/DOM%E8%8A%82%E7%82%B9%E6%93%8D%E4%BD%9C/"><span class="tag">DOM节点操作</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Function/"><span class="tag">Function</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/HTML%E6%A0%87%E8%AE%B0/"><span class="tag">HTML标记</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/JS%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"><span class="tag">JS基本概念</span><span class="tag is-grey-lightest">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/JavaScript/"><span class="tag">JavaScript</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"><span class="tag">JavaScript高级程序设计</span><span class="tag is-grey-lightest">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Javascript/"><span class="tag">Javascript</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/MacOS-%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/"><span class="tag">MacOS 常用软件</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/TNT-%E7%A0%B4%E8%A7%A3%E7%89%88/"><span class="tag">TNT 破解版</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/javascript-dom-%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/"><span class="tag">javascript-dom-编程艺术</span><span class="tag is-grey-lightest">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/this%E6%8C%87%E9%92%88/"><span class="tag">this指针</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%9B%BE%E7%89%87%E5%BA%93/"><span class="tag">图片库</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%9B%BE%E7%89%87%E5%BA%93%E6%94%B9%E8%BF%9B/"><span class="tag">图片库改进</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%9C%A8HTML%E4%B8%AD%E4%BD%BF%E7%94%A8JavaScript/"><span class="tag">在HTML中使用JavaScript</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/"><span class="tag">快捷键</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%88%E7%8E%87/"><span class="tag">效率</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"><span class="tag">最佳实践</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%9F%A5%E8%AF%86%E7%82%B9/"><span class="tag">知识点</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%AB%AF%E5%8F%A3/"><span class="tag">端口</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%98%B2%E7%81%AB%E5%A2%99/"><span class="tag">防火墙</span><span class="tag is-grey-lightest">1</span></a></div></div></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">订阅更新</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button is-primary" type="submit" value="订阅"></div></div></form></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="Matrix" height="28"></a><p class="size-small"><span>&copy; 2020 CCYYZZNN</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">共<span id="busuanzi_value_site_uv">0</span>个访客</span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            site: {
                url: 'http://timemachine.top',
                external_link: {"enable":true,"exclude":[]}
            },
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>