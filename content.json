{"pages":[{"title":"tags","text":"","link":"/tags/index.html"},{"title":"categories","text":"","link":"/categories/index.html"}],"posts":[{"title":"CentOS 防火墙 启动&#x2F;停止&#x2F;重启&#x2F;永久开启端口","text":"# &gt;&gt;&gt; 开启端口 firewall-cmd --zone=public --add-port=8000/tcp --permanent # 命令含义： --zone #作用域 --add-port=80/tcp #添加端口，格式为：端口/通讯协议 --permanent #永久生效，没有此参数重启后失效 # &gt;&gt;&gt; 重启防火墙 firewall-cmd --reload ##重启防火墙 firewall-cmd --state ##查看防火墙状态，是否是running firewall-cmd --reload ##重新载入配置，比如添加规则之后，需要执行此命令 firewall-cmd --get-zones ##列出支持的zone firewall-cmd --get-services ##列出支持的服务，在列表中的服务是放行的 firewall-cmd --query-service ftp ##查看ftp服务是否支持，返回yes或者no firewall-cmd --add-service=ftp ##临时开放ftp服务 firewall-cmd --add-service=ftp --permanent ##永久开放ftp服务 firewall-cmd --remove-service=ftp --permanent ##永久移除ftp服务 firewall-cmd --add-port=80/tcp --permanent ##永久添加80端口 iptables -L -n ##查看规则，这个命令是和iptables的相同的 man firewall-cmd ##查看帮助 # &gt;&gt;&gt; CentOS 7.0默认使用的是firewall作为防火墙，使用iptables必须重新设置一下 # 1、直接关闭防火墙 systemctl stop firewalld.service #停止firewall systemctl disable firewalld.service #禁止firewall开机启动 # 2、设置 iptables service yum -y install iptables-services # 如果要修改防火墙配置，如增加防火墙端口3306 vi /etc/sysconfig/iptables # 增加规则 -A INPUT -m state --state NEW -m tcp -p tcp --dport 3306 -j ACCEPT # 保存退出后 systemctl restart iptables.service #重启防火墙使配置生效 systemctl enable iptables.service #设置防火墙开机启动 # 最后重启系统使设置生效即可。","link":"/passages/CentOS-%E9%98%B2%E7%81%AB%E5%A2%99-%E5%90%AF%E5%8A%A8-%E5%81%9C%E6%AD%A2-%E9%87%8D%E5%90%AF-%E6%B0%B8%E4%B9%85%E5%BC%80%E5%90%AF%E7%AB%AF%E5%8F%A3/"},{"title":"JS获取子节点、父节点和兄弟节点的若干种方式","text":"原文链接：https://blog.csdn.net/laok_/article/details/75760572 一、js获取子节点的方式1.通过获取dom方式直接获取子节点其中test的父标签id的值，div为标签的名字。getElementsByTagName是一个方法。返回的是一个数组。在访问的时候要按数组的形式访问。 var a = document.getElementById(&quot;test&quot;).getElementsByTagName(&quot;div&quot;); 2.通过childNodes获取子节点使用childNodes获取子节点的时候，childNodes返回的是子节点的集合，是一个数组的格式。他会把换行和空格也当成是节点信息。 var b =document.getElementById(&quot;test&quot;).childNodes; //为了不显示不必须的换行的空格，我们如果要使用childNodes就必须进行必要的过滤。通过正则表达式式取掉不必要的信息。 //去掉换行的空格 for(var i=0; i&lt;b.length;i++){ if(b[i].nodeName == &quot;#text&quot; &amp;&amp; !/\\s/.test(b.nodeValue)){ document.getElementById(&quot;test&quot;).removeChild(b[i]); } } //打印测试 for(var i=0;i&lt;b.length;i++){ console.log(i+&quot;---------&quot;) console.log(b[i]); } //补充 document.getElementById(&quot;test&quot;).childElementCount; 可以直接获取长度 同length 3.通过children来获取子节点var getFirstChild = document.getElementById(&quot;test&quot;).children[0];","link":"/passages/JS%E8%8E%B7%E5%8F%96%E5%AD%90%E8%8A%82%E7%82%B9%E3%80%81%E7%88%B6%E8%8A%82%E7%82%B9%E5%92%8C%E5%85%84%E5%BC%9F%E8%8A%82%E7%82%B9%E7%9A%84%E8%8B%A5%E5%B9%B2%E7%A7%8D%E6%96%B9%E5%BC%8F/"},{"title":"JavaScript-语法","text":"第二章：JavaScript语法变量赋值： var age,mood; // console.log(age,mood) 已定义的变量输出为undefined console.log(a) // 未定义的直接抛出错误 Uncaught ReferenceError: a is not defined 数据类型： JavaScript为弱语言类型 // var age = ‘thirty’ ; age = 33; 不会报错 字符串(String) 转义字符 “ \\ ” 示例： var mood = ‘don\\‘t ask’ ; var height =”about 5 ‘10\\“tall” ; 数值(Number) 整数 负数 浮点数(floating-point number) 布尔值(boolean) true false 数组(Array) 下标index+值value 的组合 index开始于0 length 数组长度 传统下标赋值（值可以有 任意基础类型） 二维数组嵌套 class[0][0] 第一班第一位 var people = []; people['name'] = 'john'; people['year'] = 1940; 这样的数组叫做关联数组。由于可以使用字符串来代替数字值,因而代码更具有可读性。但是,这种用法并不是一个好习惯,不推荐大家使用。本质上,在创建关联数组时,你创建的是Aray对象的属性。在 JavaScript中,所有的变量实际上都是某种类型的对象。比如,一个布尔值就是一个 Boolean类型的对象,一个数组就是一个Aray类型的对象。在上面这个例子中,你实际上是给 lennon数组添加了name、year和 living三个属性。理想情况下,你不应该修改Aray对象的属性,而应该使用通用的对象( object)。 对象 创建对象使用0bject关键字 var lennon ={ name: John”, year: 1940, living: false } // 创建对象 操作（operation） 算数操作符 加减乘除 + - * / 自增 自减 ++ -- +连接字符串 += -= *= /= // var a = a + 1 ; a+=1 ; 可进行字符串拼接 强制转换为字符串 var year = 2018; var message = &quot;this year&quot; + year; console.log(message) // 条件语句 if 条件语句 基本语法： if(条件语句){ //条件为真 往下执行 //执行语句 } if(1&gt;2) alert('false') //可写成一行 比较操作符 大于 小于 大于等于 小于等于 相等 全等 不等于 不全等（&gt; &lt; &gt;= &lt;= == === != !==） 逻辑操作符 或于切（|| 或、&amp;&amp; 且） 或 || 一个条件为真 就是真 且 两个条件为真 就是真 一个假就是假 循环语句 while循环 while(条件){ //只要条件为true就执行 //执行语句 } example ： var a = 1 ; while(a&lt;11){ a++; } do while 循环 do{ //语句 }while(条件) //先执行一次 //条件为真 继续运行 条件为假 退出 for 循环 for(var i = 1; i&lt;9 ; i++){ //statement } 函数 如果需要多次使用同一段代码,可以把它们封装成一个函数。函数( function)就是一组允许在你的代码里随时调用的语句。事实上,每个函数实际上是一个短小的脚本。 function(arguments){ //参数 形参 //执行语句 return '' //函数可以返回任意数据类型 包括函数 } 变量作用域 全局变量 局部变量 判断全局还是局部变量需要用var来判断，当函数内部有var的时候，是局部变量，当函数里没有var的时候是全局变量 function get(num){ total = num * num; return total; } var total = 33; var new = get(12); console.log(total) //144 //调用过程中，total市全局变量，并不是局部变量，当函数调用修改的时候total的值也发生了变化 //调整 function get(num){ var total = num * num; return total; } //此时total是get函数的局部变量 对象 对象( object)是一种非常重要的数据类型,但此前我们还没有认真对待它。对象是自包含的数据集合,包含在对象里的数据可以通过两种形式访间—属性( property.)和方法( method): 属性是隶属于某个特定对象的变量;方法是只有某个特定对象才能调用的函数 属性 property 共同调用方法 “.” 隶属于对象的变量 方法 method 隶属于对象的方法 可执行函数 实例对象（instance） function Person(){ this.age = '11' } //实例对象 操作符 new 通过实例化对象 把构造函数的属性和方法挂载到实例对象上 var chenyu = new Person(); console.log(chenyu.age) * 内建对象 * 数组对象Array * 数学对象Math * 日期对象Date * 宿主对象 &gt; 由浏览器提供的预定义对象被成为宿主对象 * document对象 * window对象","link":"/passages/JavaScrip-%E8%AF%AD%E6%B3%95/"},{"title":"JavaScript-DOM","text":"第三章 DOM document 文档 object 对象 model 模型 统称为文档对象模型 节点（node） 元素节点（element node） // div ul li a 文本节点 （text node） // 标签内容 属性节点（attribute）//标签的属性值 href CSS id class 获取元素 getElementById //通过id取得 document对象特有的函数 getElementsByTagName //通过表签名取得 获取到的是一个数组，可遍历，可使用Array对象中的默认属性 //获取全部标签 通配符* document.getElementsByTagName(&quot;*&quot;) //返回所有文档节点obj //获取指定标签内所有的标签 var shop = document.getElementById(&quot;shop&quot;); var allItems = shop.getElementsByTagName(&quot;*&quot;); getElementsByClassName //通过class属性获得 HTML5新增 document.getElementsByClassName(&quot;classname&quot;) //返回是数组 类似于tagname document.getElementsByClassName(&quot;classname1 classname2&quot;) //获取多个classname的标签 //获取指定id下所有特定class标签 var id = document.getElementById(&quot;id&quot;); var innerClass = id.getElementsByClassName(&quot;classname&quot;); //适应老浏览器做法 function getElementsByClassName(node,classname){ if(node.getElementsByClassName){ return node.getElementsByClassName(classname); }else{ var results = []; var allNode = document.getElementsByTagName('*'); for(var i in allNode){ if(allNode[i].className.indexOf(classname) != -1){ results[i] = allNode[i]; } } return results; } } //替换为 var id = document.getElementById(&quot;id&quot;); var innerClass = getElementsByClassName(id，&quot;classname&quot;); 获取和设置属性 获取元素以后，我们可以获取和设置这些元素的属性 获取属性值 obj.getAttribute(属性名) //不能通过document对象调用，只能通过元素节点调用 //获取所有p标签的title属性 var paras = document.getElementsByTagName('p'); var result = []; for(var i in paras){ result[i] = paras[i].getAttribute('title'); } 设置属性值 obj.setAttribute(“属性名”，”属性值”) var para = document.getElementById(&quot;par&quot;); para.setAttribute(&quot;title&quot;,&quot;我是标题&quot;) 这里有一个非常值得关注的细节:通过 setAttribute对文档做出修改后,在通过浏览器的view source(查看源代码)选项去查看文档的源代码时看到的仍将是改变前的属性值,也就是说,setAttribute做出的修改不会反映在文档本身的源代码里。这种“表里不一”的现象源自DOM的工作模式:先加载文档的静态内容,再动态刷新,动态刷新不影响文档的静态内容。这正是DOM的真正威力:对页面内容进行刷新却不需要在浏览器里刷新页面。","link":"/passages/JavaScript-DOM/"},{"title":"JavaScript 函数","text":"函数概念 函数是一块 JavaScript代码,被定义一次,但可执行和调用多次。JS中的函数也是对象,所以JS函数可以像其它对象那样操作和传递，所以我们也常叫JS中的函数为函数对象。 函数创建方法 函数声明 function func(){ //do something } 函数表达式 var func = function(){} //传入匿名函数 使用构造函数 var func = new Function('参数1','参数2','函数内部块'); //等价于 var func = Function() ; 不同创建方法，会有不同差别 //函数声明与函数表达式进行对比 var result = add(1,2) ; console.log(result) //输出3 function add(a,b){ return a+b } //等价于 function add(a,b){ return a+b } var result = add(1,2) ; console.log(result) //输出3 使用函数声明，可以进行函数提升，执行上下文之前，函数声明会提升到前面，可以直接进行调用 var result = add(1,2) console.log(result) //报错,Uncaught TypeError: add is not a function var add = function(a,b){ return a+b } //等价于 var add; //此时add刚刚被定义，值为undefined var result = add(1,2); console.log(result) add = function(a,b){ return a+b } 使用函数表达式创建函数，仅仅会把当前的变量进行提升，并不能对内部的匿名函数进行提升。 var result = add(1,2) console.log(result) //报错,Uncaught TypeError: add is not a function var add = new Function('a','b','return a+b'); //示例 var globalTime = 3; (function(){ var time = 2; var getTime = Function('return time') //undefined，无法访问到函数内部变量，却可以访问到全局变量（globalTime） }) 使用函数构造器构造函数时，函数也不会进行提升，不能访问到函数内部变量，可以访问全局变量。 函数属性与argumentsfunction foo(x,y,z){ arguments.length //实际传入两个形参 那么长度就是2 arguments[0] //返回1 arguments[0]=10 x //打印为10 （严格模式下赋值会失败） arguments[2] = 20 z //打印为20 arguments.callee === foo //arguments下的callee属性指向函数本身（严格模式下不能使用） } foo(1,2) foo.length // 函数的形参3个，所以长度为3 foo.name //名称foo 闭包在函数作用域外，仍然能通过一种形式访问到函数内部的局部变量。 function caller(){ var abc = 111; return abc } caller() ; // 111 此时只有调用函数的时候才能获取到abc的值 function caller(){ var abc = 111; return function(){ return abc; } } var func = caller(); func(); //可以获取到内部变量abc 闭包可以进行封装，灵活方便。但是容易造成空间浪费，内存泄漏，性能消耗等问题。 作用域 全局变量 var i = 0; function func(){ console.log(i) } func(); // 0 for(var j = 1 ; j&lt;6;j++){ } console.log(j) // 1 局部变量 function foo(){ var i = 0; } console.log(i) //undefined //特殊例子 function foo1(){ var i = 0 ; var foo2 = new Function('console.log(i)'); foo2() } foo1() ; // undefined eval() 内部声明的变量 利用函数作用域封装(function(){ })() //or !function(){ }() //变成函数表达式","link":"/passages/JavaScript-%E5%87%BD%E6%95%B0/"},{"title":"JavaScript 动态创建标记","text":"传统创建标记方法 document.write方法 innerHTML属性 DOM方法 createElement 方法 创建元素节点方法：document.createElement(nodeName) //创建一个p元素 var para = document.createElement('p'); //此时p元素是文档碎片(document fragment)游离在文档之外 appendChild方法 添加到某元素的节点树 parent.appendChild(child) //创建一个p元素 var para = document.createElement('p'); var testdiv = document.getELementById(&quot;testdiv&quot;); //添加p元素到testdiv,成为testdiv的一个子元素节点 testdiv.appendChild(para); createTextNode方法 创建一个文本节点 document.createTextNode(“txt”) //创建一个文本节点 var text = document.createTextNode(&quot;hello world&quot;); //创建一个p元素 var para = document.createElement('p'); //添加文本节点到元素节点 para.appendChild(text); Example：创建复杂的示例 //创建 &lt;p&gt; this is &lt;em&gt;my&lt;/em&gt; content. &lt;/p&gt; var para = document.createElement(&quot;p&quot;); var txt1 = document.createTextNode(&quot;this is&quot;); para.appendChild(txt1) var em = document.createElement('em'); var txt2 = document.createTextNode('my'); em.appendChild(txt2) var txt3 = document.createTextNode('content.'); para.appendChild(em) para.appendChild(txt3) 获取body元素 //方法1 document.getElementsByTagName('body')[0] //方法2 document.body 在已有元素前插入一个新元素 insertBefore()方法 新元素newElement，目标元素targetElement，父元素parentElement（目标元素的父元素） parenetElement.insertBefore(newElement,targetElement) ==targetElement.parentNode.indsertBefore(newElement,targetElement) //在父元素内在目标元素前插入 // &lt;div id='demoParent'&gt; &lt;span id='demoChild'&gt; &lt;/span&gt; &lt;/div&gt; var obj = document.createElement('p'); var demoChild = document.getELmentById(&quot;demoChild&quot;); var demoParent = document.getELementById(&quot;demoParent&quot;); demoParent.insertBefore(obj,demoChild) == demoChild.parentNode.insertBefore(obj,demoChild) 在现有的元素后插入一个新元素（DOM未提供） 自制函数insertBefore() function insertBefore(new,target){ var parent = target.parentNode; if(parent.lastChild == target){ parent.appendChild(new) }else{ //目标元素的下一个兄弟元素 target.nextSibling parent.appendChild(new,target.nextSibling); } } *Ajax异步加载页面内容，无需刷新页面 XMLHttpRequest 对象Ajax技术的核心就是XMLHttpRequest对象。这个对象充当着浏览器中的脚本(客户端)与服务器之间的中间人的角色。以往的请求都由浏览器发出,而 JavaScript通过这个对象可以自己发送请求,同时也自己处理响应。","link":"/passages/JavaScript-%E5%8A%A8%E6%80%81%E5%88%9B%E5%BB%BA%E6%A0%87%E8%AE%B0/"},{"title":"JavaScript-图片库","text":"第四章：JavaScript 图片交互&lt;ul&gt; &lt;li&gt;&lt;a href=&quot;images/3840x2160-3122452-creative-wallpapers.jpg&quot; onclick=&quot;showpic(this);return false;&quot;&gt;1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;images/3840x2160-3374593-free-dusk-wallpapers.jpg&quot; onclick=&quot;showpic(this);return false;&quot;&gt;2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;images/3840x2160-3957507-photos-wallpapers.jpg&quot;&gt;3&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;images/3840x2160-4279191-stunning-retina-wallpapers.jpg&quot;&gt;4&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; //占位符 &lt;img src=&quot;images/3840x2160-3122452-creative-wallpapers.jpg&quot; alt=&quot;&quot; id=&quot;placeholder&quot;&gt; function showpic(whichpic){ var imgPlaceholder = document.getElementById(&quot;placeholder&quot;); var nodeSource = whichpic.href; imgPlaceholder.src = nodeSource; } //控制图片href childNodes 属性 //获取一个元素的所有子元素 由 childnodes属性返回的数组包含所有类型的节点,而不仅仅是元素节点。事实上,文档里几乎每一样东西都是一个节点,甚至连空格和换行符都会被解释为节点,而它们也全都包含在childNodes属性所返回的数组当中。 var body_ele = document.getElementsByTagName('body')[0]; var body_all_child = body_ele.childNodes; //获取全部body 下面的子元素 //text元素、ul、img、script等 nodeType属性 //获取元素 节点的属性 body_ele.nodeType; //返回值1:元素节点，2:属性节点，3:文本节点 nodeValue 属性 //获取节点的值 var para = document.getElementById(&quot;paragraph&quot;); console.log(para.nodeValue) //返回值为null //para元素本身的nodeValue属性是空值 //para元素包含很多子元素 console.log(para.childNodes[0].nodeValue) //childNodes 获取当前元素的所有元素信息，第一个是元素的文本信息节点，第二个是元素下挂载的其他元素 firstChild和lastChild 属性 node.firstChild = node.childNodes[0]; node.lastChild = node.childNodes[node.childNodes.length-1]","link":"/passages/JavaScript-%E5%9B%BE%E7%89%87%E5%BA%93/"},{"title":"JavaScript this","text":"this指向在浏览器环境中，当前的全局this为window对象 this.document === document //true this === window 一般函数的this，指向的是当前全局对象 在浏览器环境中，指向为window对象 function fn(){ return this } fn() === window //true 在nodejs环境中，指向为global对象 在严格模式中，指向为undefined function fn2(){ 'use strict'; return this; } fn2() === undefined 作为对象方法的函数this var o = { props :37 f:function(){ return this.props //此时this指向函数字面量o } } var o = { props : 37 } function fn(){ return this.props; //此时的this指向全局的window对象 } //将函数作为对象的方法，可以获取到该对象 o.f = fn; console.log(o.f()); //37 对象原型链上的this //this指向实例对象 var o = { f:function(){ return this.a + this.b } } var obj = Object.create(o); obj.a = 2; obj.b = 1; obj.f(); // 3 get/set方法上的this function modulus(){ return Math.sqrt(this.re * this.re + this.rm * this.rm) } var o = { re : 2, rm : 2, get phase(){ return Math.atan2(this.rm,this.re) } } Object.defineProperty(o,'modulus',{ get: modulus, enumerable:true, configurable:true }) console.log(o.phase,o.modulus) //都可以取到值 构造函数上的this function Person(){ this.age = '24' } var person1 = new Person(); //此时this指向到构造函数的prototype 此时Person.prototype.age person1.age // 24 此时this指向到实例对象的私有原型 __proto__ 可以直接拿到 //如果函数有return 返回值，切返回值为一个对象并包含该属性，则返回该属性 function Person(){ this.age = '24' return {age:'25'} } var person2 = new Person(); person2.age = 25 call/apply方法与this function add(c,d){ return this.a + this.b + c + d } var o = { a:1, b:2 } add.call(o,3,4) //此时函数上下文this为o, 返回1+2+3+4 add.apply(o,[3,4]) //返回1+2+3+4 function bar(){ console.log(Object.prototype.toString.call(this)) } bar.call(7) // [object number] bind方法与this //bind 绑定 当前的this function person(){ return this.a; } var g = person.bind({a:&quot;test&quot;}) g() // test 通过bind绑定当前的this为一个对象 var o = { a:36, f:peroson, g:g } o.f() // 36 o.g() // test 仍然按照绑定的来走 call / apply 注意事项function show(x,y){ console.log(x,y,this) } show.call(100,1,2) // 1,2,100 show.apply(100,[3,4]) //3,4,100 show.call(null) //undefined undefined window 此时this为全局变量window show.call(undefined) //undefined undefined window 此时this也指向全局变量window //严格模式下 function show(x,y){ 'use strict' console.log(x,y,this) } show.call(null) //undefined undefined null. undefined同理 bind方法注意事项this.x = 20; var module = { x:30, getX:function(){ return this.x } } var getX = module.getX; getX() //20 赋值到变量的时候 此时this指向到全局window对象 var boundGetX = getX.bind(module) boundGetX() // 30 绑定到module this指向module bind与currying//固定某些值，然后个性化改变某几个值 function show(a,b,c){ return a + b + c } var show1 = show.bind(null,2) show1(1,2) // 2 + 1 + 2 固定a，bc个性化设置 var show2 = show1.bind(null,3) show2(5) // 2+3+5 固定ab, c个性化设置 //举例 function getConfig(color,size,otheroptions){ console.log(color,size,otheroptions) } var defineConfig = getConfig(null,'#ffffff','1024*768') //固定两个参数 defineConfig('show') // '#ffffff','1024*768',show defineConfig('hide') //'#ffffff','1024*768',hide bind与newfunction foo(){ this.b = 100 return this.a } var foo1 = foo.bind({a:20}) foo1() //20 new foo() // {b:100} 整个函数作为返回值返回，作为构造函数扔掉返回值，bind作用会被忽略","link":"/passages/JavaScript-this/"},{"title":"JavaScript 图片库改进","text":"平隐退化 在没有javascript支持的情况下，是否网页会出现错误？ JavaScript和HTML分离 剥离页面元素与用户的逻辑操作，提供页面挂钩 Fn-prepareGallery 现在,需要编写一个简短的函数把有关操作关联到onc1ick事件上我将其命名为 prepareGallery。 下面是我想让这个函数完成的工作。口检查当前浏览器是否理解 getElementsBy TagName囗检査当前浏览器是否理解 getelementById。口检查当前网页是否存在一个d为 imagegal lery的元素。口遍历 imagegallery元素中的所有链接。口设置 onclick事件,让它在有关链接被点击时完成以下操作: ■把这个链接作为参数传递给 showPic函数; ■取消链接被点击时的默认行为,不让浏览器打开这个链接 function preparGallery(){ //检查是否支持get if(!document.getElementsByTagName || !document.getElementById){ return false } var imgGallery = document.getELementById(&quot;gallery&quot;); if(!imgGallery){ console.log('浏览器不支持获取id，请启用JavaScript') return false }else{ var aContent = imgGallery.getElementsByTagName('a'); for(var i in aContent){ if(aContent[i].href){ this.click = function(e){ e.preventDefault(); showPic(this) return false } } } } } //启用事件 window.onload = function(){ //fn1 //fn2 ... //fn[n] } //快速添加页面onload事件 function addEventAfterOnload(func){ var wonload = window.onload if(typeof window.onload != 'function'){ window.onload = func; }else{ window.onload = function(){ wonload(); func(); } } } addEventAfterOnload(func1) 三目运算符var result = condition ? result1 : result2 ; //结果为true返回result1 TIPS element.nodeName 返回值为大写字母","link":"/passages/JavaScript-%E5%9B%BE%E7%89%87%E5%BA%93%E6%94%B9%E8%BF%9B/"},{"title":"JavaScript 数组","text":"创建数组 数组是特殊的Object，包含很多方法，创建数组的方法有很多： //数组的创建 var arr = new Array(100) //创建一个长度为100的数组,所有的值都为undefined var arr1 = new Array('1','2',true) //创建一个包含数值和固定下标的字符串 var arr2 = [] //快捷创建一个数组 数组的方法 获取所有的数组方法: Array.prototype 所有在原型链上的方法 john 方法 将数组转换为字符串 var arr = [1,2,3] arr.join('/') //输出&quot;1/2/3“ var arr1 = [1,2,3,undefined]; arr.join('') //输出&quot;123&quot;忽略 undefined //利用join创建一个重复输出的函数 function repeatString(str,n){ return new Array(n+1).join(str) //创建一个n长度的数组，然后join连接符得以重复 } reverse方法 将数组顺序颠倒 var arr = [1,2,3] arr.reverse() //输出[3,2,1] 会修改原数组 sort方法 将数组排序 var arr = [15,22,17,58] arr.sort(); // 15,17,22,58 var arr1 = [13,24,3,58] arr1.sort(); // 13,24,3,58 并没有按照实际的数字大小进行排序，因为sort方法先将其转换为字符串然后进行排序，解决方法： var arr1 = [13,24,3,58]; arr1.sort(function(a,b){return a-b }) //根据大小排列 var items = [ { name: 'Edward', value: 21 }, { name: 'Sharpe', value: 37 }, { name: 'And', value: 45 }, { name: 'The', value: -12 }, { name: 'Magnetic' }, { name: 'Zeros', value: 37 } ]; // 根据值的大小排列 items.sort(function (a, b) { return (a.value - b.value) }); concat方法 连接返回一个数组 var arr = [1,2,3] arr.concat(1) // [1,2,3,1] arr.concat([10,11],12) // [1,2,3,10,11,12]拉平数组一次 arr.concat([10,11,[12,13]]) // [1,2,3,10,11,[12,13]] 只能拉平数组一次不能多次拉平 slice方法 返回部分数组 var arr = [1,2,3,4,5] arr.slice(1,3) //返回[2,3] 不包含结束的那个字符 arr.slice(1) //[2,3,4,5] arr.slice(1,-1) //[2,3,4] 从索引位置到最后一个的索引 不包含最后一个字符 arr.slice(-4,-3) // [2] splice方法 数组精简、指定位置增加 var arr = [1,2,3,4,5] arr.splice(1,1) arr //[1,3,4,5] 从第二个字符开始删除一个 arr.splice(2,2) arr //[1,2,5] 从第三个字符上开始删除两个 arr.splice(1,1,'a','b') arr //[1,'a','b',3,4,5] //从第二个索引删除一个，然后插入后续的值 ES5 方法：forEach方法，遍历数组 并不会修改当前数组 var arr = [1,2,3,4,5] arr.forEach(function(x,index,a){ //三个参数：x数组的值，index数组的索引，a数组本体 console.log(x+'|'+index+'|'+ (a === arr) ) }) ES5方法：map方法，遍历并返回一个数组 var arr = [1,2,3,4,5] var arr1 = arr.map(function(x){ return x * 2 }) arr1 //[2,4,6,8,10] var kvArray = [{key: 1, value: 10}, {key: 2, value: 20}, {key: 3, value: 30}]; var newKeyValueArray = kvArray.map(function(obj){ var sObj = {}; sObj[obj.key] = obj.value return sObj }) newKeyValueArray //[{1:10},{2:20},{3:30}] ES5方法：filter方法，接受一个callback，返回一个过滤的数组 var arr = [1,2,3,4,5]; arr.filter(function(x,index){ //接受两个参数x为值，index为索引 return index % 3 === 0 || index &gt; 1 }) // [4] ES5方法：every方法，对数组进行判断，全部符合返回一个boolean数值 ES5方法：some方法，对数组进行判断，符合一个则返回boolean数值 //every方法 var arr = [1,2,3,4,5]; arr.every(function(x){ return x &lt; 10 }) //true 因为全部小于10 arr.every(function(x){ return x &gt; 6 }) //false 因为没有大于6的 //some方法 arr.some(function(x){ return x === 3 }) //true 因为数组里面存在3 arr.some(function(x){ return x &lt;2 }) //true 因为1小于2 ES5方法：reduce方法，对数组相邻的值进行操作 //reduce var arr = [1,2,3,4,5] arr.reduce(function(x,y){ //此时x、y为1、2 第一个参数为索引1的值，第二个参数为索引2的值 return x+y },1) //此时1先作为x，与数组内数字相加，然后从左到右进行累加 reduceRight //顺序改变从右往左 ES5方法：indexOf / lastIndexOf方法，查找数组是否存在该值，如果存在返回当前索引位置，如果没有则返回-1 var arr = [1,2,3,2,1] arr.indexOf(1) //返回索引为0 arr.indexOf(1,2) //从第三个位置开始查找，返回索引为4 arr.indexOf(1,-2) //从倒数第二的位置（2）开始查找，返回索引为4 arr.lastIndexOf(3,-4) //从右往左找，从倒数第四个开始（2），返回索引为2 判断是否为数组 Array.isArray(obj) obj instanceof Array; //是否是数组实例 ({}).toString.apply([]) === “[object Array]” //true 调用对象的toString方法 [].constructor === Array //true 利用构造函数判断","link":"/passages/JavaScript-%E6%95%B0%E7%BB%84/"},{"title":"JavaScript-最佳实践","text":"JavaScript相对独立 与HIML语言相比, JavaScript语言的生存环境的要求要苛刻得多。如果 JavaScript代码不符合语法规定, JavaScript解释器(对Web应用而言就是浏览器)将拒绝执行它们并报错;而浏览器在遇到不符合语法规定的HTML代码时,则会千方百计地将其呈现出来。尽管如此,在如今的Web上还是充斥着质量低劣的 JavaScript代码 JavaScript伪协议 “javascript:” 这个伪协议可以让我们通过一个链接来调用JavaScript函数 &lt;a href=&quot;javascript:popUp()&quot;&gt;示例&lt;/a&gt; 内嵌的事件处理函数&lt;a href=&quot;#&quot; onclick=&quot;popup()&quot;&gt; &lt;/a&gt; 分离JavaScript&lt;a href='#' class=&quot;popup&quot;&gt; &lt;/a&gt; //包装在函数里 利用window.onload 加载页面全部的节点 window.onload = choose(); function choose(){ var popup_class = document.getELementsByClassName('popup'); for(var i in popup_class){ if(popup_class[i].className = 'popup'){ this.click = function(){ //statement } } } } 性能考虑 尽量少访问DOM 尽量减少标记 对获取来的DOM进行存储，防止二次获取 合理放置脚本，脚本合并，减少http请求 压缩脚本，双版本，原版，.min.js版本","link":"/passages/JavaScript-%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"},{"title":"MacOS 常用快捷键","text":"快捷键是提高效率的捷径不管使用哪一个 App 或者操作系统，掌握快捷键永远提高效率最简单的方法。就像它的名字”shortcuts”一样，它的设计就是为了让你节省时间的捷径。 macOS 系统自带许多有用的快捷键，有全局的也有各个 App 自己的。Mac App 的特色是 Menubar 上的菜单如果是重要操作一般都会带有匹配的快捷键，而且实现起来非常简单。所以 macOS 生态里的快捷键非常统一。用户只需要学习一套快捷键操作，就可以复制到其他 App 里面。 大部分使用 macOS 的读者朋友应该都习惯了相当一部的快捷键，但可能还有些有用的快捷键没有用到。我在写作此文的时候也发现有些快捷键之前都不知道，整理的过程也是我学习的过程。 本文整理 macOS 几个大类的快捷键，希望能对读者朋友们有所帮助。更多主流 App 快捷键大家随时可以通过 Google 关键字: App Name + Shortcuts 或者是 App Name + Cheatsheat 来找到。 一、系统全局类系统自带的快捷键有一部分可以从 System Preferences -&gt; Keyboard -&gt; Shortcuts 里面找到 这里我们介绍几个比较常用到的全局快捷键: Key Action cmd + tab 在已经打开的 App 之间进行切换，按住 shift 可以反向选择 ctrl + left/right 左右切换 Workspace ctrl + up 显示 Mission Control ctrl + down 显示当前 App 所有 Windows option + cmd + l 在 Finder 打开 Downloads 目录 option + cmd + d 显示/隐藏 Dock option + cmd + esc 打开 Force Quit App 列表 shift + option + cmd + esc 直接 Force Quit 当前 App 二、窗口类 Key Action cmd + ` 在当前 App 的多个窗口直接切换 cmd + m 最小化当前窗口 cmd + h 隐藏当前 App cmd + opt + h 隐藏除了当前 App 以外的所有窗口 cmd + ctrl + f 进入/退出最大化 cmd + w 关掉当前窗口或者当前 Tab cmd + opt + w 关掉当前 App 的所有窗口 三、文本编辑操作对于开发者或者文字工作者，每天都在敲键盘打开，能够不用鼠标就完成选择文本、替换文本之类的操作是最好的。以下是文本编辑常用的快捷键: Key Action ctrl + a 跳到当前行的最前面 ctrl + e 跳到当前行的最后面 cmd + left/right 跳转到当前行的开头/结尾 cmd + up/down 跳转到当前文档的最顶部或最底部 cmd + del 删掉当前光标到行首之间的所有文本 shift + up/down/left/right 按住 shift 和上下左右可以选中文本 鼠标点击某处，再按住 shift 点击另外一处 可以直接选中两次点击之间的所有文本 alt + left/right 向左/右跳一个单词 双击鼠标 选中最靠近的一个单词 三击鼠标 选中当前行 文本选择小技巧 当我们按下 shift 之后我们就可以通过上下左右方向键来选择文本。这时候按住 cmd + 方向键的效果就带上了选择效果。比如 cmd + left 本来是跳转到光标所在行的最前面，加上了 shift 就自带了选中效果。 所以如果你想选择当前光标所在的位置到文本最底部，按住 shift + cmd + down 就可以了，非常方便。 这里的文本编辑快捷键是针对通用的文本编辑器而言的，喜欢 Vim/Emacs 的朋友也可以安装对应的插件，实现更加高效的操作。 比如在 Vim 里面，跳转到文档最顶部只需键入 gg 即可。选中当前光标到最顶部则只需 vgg，理论上是要更加省时间的做法。只是学习曲线要高得多，如非码农，一般也用不上。 ##四、截图类操作 Key Action shift + cmd + 3 截当前全屏并存文件到桌面 ctrl + shift + cmd + 3 截当前全屏并保存到剪贴板 shift + cmd + 4 按下后拖拽鼠标选择截图区域，或者按下 space 直接截取当前窗口并保存到文件 ctrl + shift + cmd + 4 按下后拖拽鼠标选择截图区域，或者按下 space 直接截取当前窗口并保存到剪贴板 五、大多数 App 标准快捷键 Key Action cmd + , 打开当前 App 的 Preferences 窗口 cmd + w 关闭当前窗口 cmd + 1/2/3 选中当前第 n 个窗口 ctrl + tab 切换到下一个窗口 shift + ctrl + tab 切换到上一个窗口 cmd + l 在 Safari/Chrome 中直接选中地址栏 cmd + r 在 Safari/Chrome 中刷新当前页 cmd + f 大部分支持搜索的 App 的搜索快捷键 cmd + opt + f VSCode/Sublime 之类的 App 可以支持完整 Workspace 搜索 cmd + t 大部分多 Tab 应用支持以此创建新 Tab cmd + shift + [ 大部分多 Tab 应用支持以此往左切换 tab cmd + shift + [ 大部分多 Tab 应用支持以此往右切换 tab cmd + shift + n 在 Finder 中创建新文件夹 Apple 官方有一份非常详尽的快捷键列表，有兴趣的朋友可以到这里查看: Mac keyboard shortcuts – Apple Support","link":"/passages/MacOS-%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/"},{"title":"JavaScript 重要知识点","text":"重点 //赋值 var i = (1,2,3) // i = 3 逗号计算，返回最右 var obj = {x:1,x:2} // obj.x -&gt; 2 ,可以重复命名但返回最后一个 //try catch finally try{ console.error('error1') }catch(err){ console.log(err) } finally{ console.log('finally') } //顺序 抛出错误-&gt; 捕捉错误error1 -&gt;finally try{ try{ console.error(&quot;error2&quot;) }catch(err){ console.log(err) }finally{ console.log('finally2') } } catch(err){ console.log(&quot;outer&quot;,err) }finally{ console.log('finally3') } //顺序 抛出错误error2 -&gt; 捕捉错误error2 -&gt; finally2 -&gt; outer（接收不到err 已经在上个catch捕捉） -&gt; finally3 //删除对象 var person = {age:23,name:&quot;perter&quot;} delete person.age // true delete person['name'] //true person.age // undefined delete person.age //true ！依然返回true但是并不执行 var descriptor = Object.getOwnPropertyDescriptor(Object,'prototype'); descriptor // 获取当前对象的描述属性 -&gt; 读写、配置、枚举 //var 、 function 定义的属性不能被删除 var age = 23 delete age //false function test(){} delete test //false (function test(){ var local = 1; return delete local //false }) (function(){ function test(){} return delete test //false }) //隐式变量定义 oh = 1 delete oh //true //隐式创建类似于在window对象上添加属性 window.oh //1 delete oh == delete window.oh eval('var i = 1'); delete i //true //属性检测 var cat = new Object(); cat.legs = 4; cat.name ='kitty' 'legs' in cat // true 'name' in cat //true 'toString' in cat // in 往上找，一直找到Object.prototype -&gt; null cat.hasOwnProperty('legs') //true cat.hasOwnProperty('toString') //false 因为只是继承原型链上的方法，并不是其对象内部的方法 //用当前存在的对象创建新变量 var existObj = {x:1,y:2,z:3} var newObj = Object.create(existObj); newObj.x //1 如果仅仅想枚举当前对象上的属性 var key for(key in newObj){ if(newObj.hasOwnProperty(key)){ console.log(key) //屏蔽继承原型链上的属性，仅枚举当前对象上的属性。 } } //可/不可枚举 var cat = new Object(); Object.defineProperty(cat,'legs',{enumerable:false,value:4}); cat.x = 1;cat.y=2;cat.z=3; var key; for(key in cat){ console.log(key) //x,y,z 不包含legs 因为legs不能被枚举 } Object.defineProperty(cat,'legs',{enumerable:true}) for(var key in cat){ console.log(key) //legs x , y ,z 可以进行枚举 } //get/set方法 var man = { name:'chenyu', get age(){ return new Date().getFullYear() - 1995 }, set age(val){ console.log(&quot;can't set age&quot; + val) } } GET/SET 与原型链 obj.z //向上查找原型链上的z，在构造函数foo上寻找到z obj.z = 10 //原型链上有get/set方法，赋值时会调用，并不在对象内部创建属性，所以该赋值操作不能被执行，因为无法操作原型链上的方法。 //如何在实例对象上定义z属性？ Object.defineProperty(obj,'z',{value:1,configurable:true}) obj.z //返回1 在实例对象中查找到z为1 delete obj.z ; obj.z //10 创建对象o 定义o的属性x 为1，默认定义为不可写, 创建实例对象 var obj = Object.create(o) 继承o的原型链 实例对象上还是无法修改x 对象，因为x在原型链上为不可写状态 在当前实例对象上再次定义x，并且writable为true，当前obj.x 可都可写 Object.keys(obj) //获取obj的所有键 返回为数组 Object.values(obj) //获取obj的所有数值 返回为数组 //定义多个属性 var o = {} var obj = Object.create(o) Object.defineProperties(obj,{ name:{value:'chen',enmuerable:true}, age:{value:24,enmuerable:true}, salary:{value:7000,enmuerable:true,writable:true}, luck:{ get:function(){ return Math.random() &gt; 0.5 ? &quot;good&quot; : &quot;bad&quot; } }, promote:{ set:function(level){ this.salary *= 1 + level * 0.1 } } }) obj.salary // 7000 obj.promote = 1 obj.salary // 7700 //对象是否可扩展 Object.isExtensible(obj) //判断obj是否是可扩展属性 Object.preventExtensions(obj) //让obj变得不可扩展 Object.seal(obj) //让obj属性变得不可扩展 并且configurable为false Object.isSealed(obj) //判断obj是否密封 Object.freeze(obj) //冻结obj 不可扩展 configurable和writable为false Object.isFrozen(obj) //判断是否被冻结 以上不能改变原型链中的属性 //序列化 JSON.stringify(obj) //转换为字符串 JSON.parse(obj) // 将字符串转换为JavaScript对象 注意以下几点会异常序列化 val: undefined //当值为undefined的时候，不进行序列化转换 a: NaN //值为NaN的时候，直接转换为null //自定义o序列化的过程 var obj = { o:{ o1 : 1, o2 : 2, toJSON:function(){ //toJSON函数名称固定，当序列化的时候执行这个函数，返回一个值 return this.o1 + this.o2 } } } JSON.stringify(obj.o) // o:3 //对象的toString方法 对象的toString方法可以自己定义返回的字符串 当与字符串拼接时，自动转换为字符串类型 当做运算的时，转换为数字。","link":"/passages/JavaScript-%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"title":"MacOS 常用破解软件","text":"列表更新事件：2019-08-20 软件来源：https://yun.naodai.org/Software/ https://xclient.info/ http://www.macbed.com/ 1、PDF Expert轻松在MAC上完成PDF编辑、阅读、批注、编辑文本、添加照片、填写表单、签署合同、合并PDF文档以及加密保护，只需轻轻点击几下即可，前所未有的体验。 版本号：2.4.23 链接：立即下载 2、CleanMyMac XMac OS X 系统下知名清理软件 CleanMyMac，这种垃圾清理类的软件似乎始终无法上架 Mac App Store，CleanMyMac 3 的宣传力度似乎并不如CleanMyMac 2，想当年 CleanMyMac 2 在MacPaw 网站上得倒计时挂了很久。这次，CleanMyMac 3 作为在 OS X Yosemite 系统下的软件，视觉风格上自然要满足扁平化和简约的设计路线。当然，版本号大升级，也需要拿出一点诚意，增加一些新功能。CleanMyMac 3 优化了清理体验，将复杂的操作和内容隐藏的更好，实际的操作流畅性更好一些。 版本号：4.4.6 链接：立即下载 3、Adobe Zii Adobe系列软件激活工具步骤： 1、下载creative cloud 安装正版Adobe软件 2、退出所有Adobe系列软件 3、运行Zii，点击patch，即可激活 版本号：4.4.2 链接：网盘地址","link":"/passages/MacOS-%E5%B8%B8%E7%94%A8%E7%A0%B4%E8%A7%A3%E8%BD%AF%E4%BB%B6/"},{"title":"【JS高级程序设计】第六章 面向对象的程序设计","text":"面向对象（Object-Oriented，OO）的语言有一个标志，那就是它们都有类的概念，而通过类可 以创建任意多个具有相同属性和方法的对象。前面提到过，ECMAScript 中没有类的概念，因 此它的对象也与基于类的语言中的对象有所不同。 6.1 理解对象简单创建一个对象 var person = new Object() person.name = 'chenyu' person.age = 25 person.sayName = function(){ return this.name } 使用字面量创建对象 var person = { name: &quot;chenyu&quot;, age:25, sayName:function(){ return this.name } } 6.1.1 属性类型ECMAScript 中有两种属性：数据属性和访问器属性。 数据属性 [[Configurable]]：表示能否通过 delete 删除属性从而重新定义属性，能否修改属性的特 性，或者能否把属性修改为访问器属性。像前面例子中那样直接在对象上定义的属性，它们的 这个特性默认值为 true。 [[Enumerable]]：表示能否通过 for-in 循环返回属性。像前面例子中那样直接在对象上定 义的属性，它们的这个特性默认值为 true。 [[Writable]]：表示能否修改属性的值。像前面例子中那样直接在对象上定义的属性，它们的 这个特性默认值为 true。 [[Value]]：包含这个属性的数据值。读取属性值的时候，从这个位置读；写入属性值的时候， 把新值保存在这个位置。这个特性的默认值为 undefined。 对于像前面例子中那样直接在对象上定义的属性，它们的[[Configurable]]、[[Enumerable]] 和[[Writable]]特性都被设置为 true，而[[Value]]特性被设置为指定的值。 要修改属性默认的特性，必须使用 ECMAScript 5 的 Object.defineProperty()方法。这个方法 接收三个参数：属性所在的对象、属性的名字和一个描述符对象。其中，描述符（descriptor）对象的属 性必须是：configurable、enumerable、writable 和 value。设置其中的一或多个值，可以修改 对应的特性值。 var person = {} Object.defineProperty('person','name',{ value:&quot;chenyu&quot;, writable:false }) person.name // chenyu person.name = 'test' person.name // chenyu 类似的规则也适用于不可配置的属性。 var person = {} Object.defineProperty('person','name',{ value:&quot;chenyu&quot;, configurable:false }) person.name // chenyu person.name = 'test' delete person.name //false person.name // chenyu 一旦把属性定义为不可配置的， 就不能再把它变回可配置了。 此时，再调用 Object.defineProperty()方法修改除 writable 之外 的特性，都会导致错误 在调用 Object.defineProperty() 方法时， 如果不指定， configurable 、 enumerable 和 writable 特性的默认值都是 false。多数情况下，可能都没有必要利用 Object.defineProperty() 方法提供的这些高级功能。不过，理解这些概念对理解 JavaScript 对象却非常有用。 访问器属性 访问器属性不包含数据值；它们包含一对儿 getter 和 setter 函数（不过，这两个函数都不是必需的）。 在读取访问器属性时，会调用 getter 函数，这个函数负责返回有效的值；在写入访问器属性时，会调用 setter 函数并传入新值，这个函数负责决定如何处理数据。访问器属性有如下 4 个特性。 [[Configurable]]：表示能否通过 delete 删除属性从而重新定义属性，能否修改属性的特 性， 或者能否把属性修改为数据属性。 对于直接在对象上定义的属性， 这个特性的默认值为 true。 [[Enumerable]]：表示能否通过 for-in 循环返回属性。对于直接在对象上定义的属性，这 个特性的默认值为 true。 [[Get]]：在读取属性时调用的函数。默认值为 undefined。 [[Set]]：在写入属性时调用的函数。默认值为 undefined。 var book = { _year: 2004, edition: 1 }; Object.defineProperty(book,'year',{ get:function(){ return this._year }, set:function(newValue){ if(newValue &gt; this._year){ this._year = newValue this.edition += newValue - 2004 } } }) 以上代码创建了一个 book 对象，并给它定义两个默认的属性：_year 和 edition。_year 前面 的下划线是一种常用的记号，用于表示只能通过对象方法访问的属性。而访问器属性 year 则包含一个 getter 函数和一个 setter 函数。getter 函数返回_year 的值，setter 函数通过计算来确定正确的版本。因此， 把 year 属性修改为 2005 会导致_year 变成 2005，而 edition 变为 2。这是使用访问器属性的常见方 式，即设置一个属性的值会导致其他属性发生变化。 不一定非要同时指定 getter 和 setter。只指定 getter 意味着属性是不能写，尝试写入属性会被忽略。 在严格模式下，尝试写入只指定了 getter 函数的属性会抛出错误。类似地，只指定 setter 函数的属性也 不能读，否则在非严格模式下会返回 undefined，而在严格模式下会抛出错误。 支持 ECMAScript 5 的这个方法的浏览器有 IE9+（IE8 只是部分实现）、Firefox 4+、Safari 5+、Opera 12+ 和 Chrome 。 在 这 个 方 法 之 前 ， 要 创 建 访 问 器 属 性 ， 一 般 都 使 用 两 个 非 标 准 的 方 法 ： __defineGetter__()和__defineSetter__()。这两个方法最初是由 Firefox 引入的，后来 Safari 3、 Chrome 1 和 Opera 9.5 也给出了相同的实现。 6.1.2 定义多个属性由于为对象定义多个属性的可能性很大， ECMAScript 5 又定义了一个 Object.defineProperties()方法。利用这个方法可以通过描述符一次定义多个属性。这个方法接收两个对象参数：第一 个对象是要添加和修改其属性的对象，第二个对象的属性与第一个对象中要添加或修改的属性一一对 应。 var person = {} Object.defineProperties(person,{ _year:{ value:2004 }, edition:{ value:1 }, name:{ value:'chenyu', configurable:false }, year:{ get:function(){ return this._year }, set:function(newValue){ if(newValue &gt; 2004){ this._year = newValue, this.edition += newValue - 2004 } } } }) 6.1.3 读取属性的特性使用 ECMAScript 5 的 Object.getOwnPropertyDescriptor()方法，可以取得给定属性的描述符。这个方法接收两个参数：属性所在的对象和要读取其描述符的属性名称。返回值是一个对象，如果 是访问器属性，这个对象的属性有 configurable、enumerable、get 和 set；如果是数据属性，这 个对象的属性有 configurable、enumerable、writable 和 value var person = {} Object.defineProperties(person,{ _year:{ value:2004 }, edition:{ value:1 }, name:{ value:'chenyu', configurable:false }, year:{ get:function(){ return this._year }, set:function(newValue){ if(newValue &gt; 2004){ this._year = newValue, this.edition += newValue - 2004 } } } }) var properties = Object.getOwnPropertyDescriptor(book,'name') // {value: &quot;chenyu&quot;, writable: false, enumerable: false, configurable: false} Object.getOwnPropertyDescriptor(person,'year') //{enumerable: false, configurable: false, get: ƒ, set: ƒ} 6.2 创建对象虽然 Object 构造函数或对象字面量都可以用来创建单个对象，但这些方式有个明显的缺点：使用同 一个接口创建很多对象，会产生大量的重复代码。为解决这个问题，人们开始使用工厂模式的一种变体。 6.2.1 工厂模式（用于创建出相似的对象）工厂模式是软件工程领域一种广为人知的设计模式，这种模式抽象了创建具体对象的过程，考虑到在 ECMAScript 中无法创建类，开发人员 就发明了一种函数，用函数来封装以特定接口创建对象的细节。 function createPerson(name,age,job){ var o = new Object() o.name = name o.age = age o.job = job o.sayName = function(){ alert(this.name) } return o } var tom = createPerson('tom',20,'The engineer') var jerry = createPerson('jerry',20,'mouse') 函数 createPerson()能够根据接受的参数来构建一个包含所有必要信息的 Person 对象。可以无 数次地调用这个函数，而每次它都会返回一个包含三个属性一个方法的对象。工厂模式虽然解决了创建 多个相似对象的问题，但却没有解决对象识别的问题（即怎样知道一个对象的类型）。随着 JavaScript 的发展，又一个新模式出现了。 6.2.2 构造函数模式（区别对象的类型）上述代码可以改写成： function Person(name,age,job){ this.name = name this.age = age this.job = job this.sayName = function(){ alert(this.name) } } var tom = new Person('tom',20,'The engineer') var jerry = new Person('jerry',20,'mouse') 创建了两个实例对象Tom、Jerry，他们都有一个构造函数属性指向构造函数 tom.constructor == Person jerry.constructor == Person 在这个例子中，Person()函数取代了 createPerson()函数。我们注意到，Person()中的代码 除了与 createPerson()中相同的部分外，还存在以下不同之处： 没有显式地创建对象； 直接将属性和方法赋给了 this 对象； 没有 return 语句 此外，还应该注意到函数名 Person 使用的是大写字母 P。按照惯例，构造函数始终都应该以一个 大写字母开头，而非构造函数则应该以一个小写字母开头。这个做法借鉴自其他 OO 语言，主要是为了 区别于 ECMAScript 中的其他函数；因为构造函数本身也是函数，只不过可以用来创建对象而已。 要创建 Person 的新实例，必须使用 new 操作符。以这种方式调用构造函数实际上会经历以下 4 个步骤： 创建一个新对象； 将函数的作用域赋值给新对象，当前的this会指向新对象 执行构造函数中的代码（为这个新对象添加属性）； 返回新对象 对象的 constructor 属性最初是用来标识对象类型的。但是，提到检测对象类型，还是 instanceof 操作符要更可靠一些。我们在这个例子中创建的所有对象既是 Object 的实例，同时也是 Person 的实例，这一点通过 instanceof 操作符可以得到验证。 tom instanceof Object // true tom instanceof Person // true jerry instanceof Object // true jerry instanceof Person // true 创建自定义的构造函数意味着将来可以将它的实例标识为一种特定的类型；而这正是构造函数模式 胜过工厂模式的地方。在这个例子中，person1 和 person2 之所以同时是 Object 的实例，是因为所 有对象均继承自 Object。 将构造函数当作函数 构造函数与其他函数的唯一区别，就在于调用它们的方式不同。不过，构造函数毕竟也是函数，不 存在定义构造函数的特殊语法。任何函数，只要通过 new 操作符来调用，那它就可以作为构造函数；而 任何函数，如果不通过 new 操作符来调用，那它跟普通函数也不会有什么两样。例如，前面例子中定义 的 Person()函数可以通过下列任何一种方式来调用。 // 当作构造函数使用 var person = new Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;); person.sayName(); //&quot;Nicholas&quot; //当作普通函数使用 Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;); window.name // Nicholas //在另一个对象的作用域中调用 var o = new Object Person.call(o,&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;) o.name // Nicholas 这个例子中的前两行代码展示了构造函数的典型用法，即使用 new 操作符来创建一个新对象。接下 来的两行代码展示了不使用 new 操作符调用 Person()会出现什么结果：属性和方法都被添加给 window 对象了。有读者可能还记得，当在全局作用域中调用一个函数时，this 对象总是指向 Global 对象（在 浏览器中就是 window 对象）。因此，在调用完函数之后，可以通过 window 对象来调用 sayName()方 法，并且还返回了”Greg”。最后，也可以使用 call()（或者 apply()）在某个特殊对象的作用域中 调用 Person()函数。这里是在对象 o 的作用域中调用的，因此调用后 o 就拥有了所有属性和 sayName() 方法。 构造函数的问题 构造函数模式虽然好用，但也并非没有缺点。使用构造函数的主要问题，就是每个方法都要在每个 实例上重新创建一遍。在前面的例子中，person1 和 person2 都有一个名为 sayName()的方法，但那 两个方法不是同一个 Function 的实例。不要忘了——ECMAScript 中的函数是对象，因此每定义一个 函数，也就是实例化了一个对象。从逻辑角度讲，此时的构造函数也可以这样定义。 function Person(name, age, job){ this.name = name; this.age = age; this.job = job; this.sayName = new Function(&quot;alert(this.name)&quot;); // 与声明函数在逻辑上是等价的 } 从这个角度上来看构造函数，更容易明白每个 Person 实例都包含一个不同的 Function 实例（以 显示 name 属性）的本质。说明白些，以这种方式创建函数，会导致不同的作用域链和标识符解析，但 创建 Function 新实例的机制仍然是相同的。 tom.sayName == jerry.sayName // false function Person(name, age, job){ this.name = name; this.age = age; this.job = job; this.sayName = sayName; } function sayName(){ alert(this.name) } var person1 = new Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;); var person2 = new Person(&quot;Greg&quot;, 27, &quot;Doctor&quot;); person1.sayName == person2.sayName // true 在这个例子中，我们把 sayName()函数的定义转移到了构造函数外部。而在构造函数内部，我们 将 sayName 属性设置成等于全局的 sayName 函数。这样一来，由于 sayName 包含的是一个指向函数 的指针，因此 person1 和 person2 对象就共享了在全局作用域中定义的同一个 sayName()函数。这 样做确实解决了两个函数做同一件事的问题，可是新问题又来了：在全局作用域中定义的函数实际上只 能被某个对象调用，这让全局作用域有点名不副实。而更让人无法接受的是：如果对象需要定义很多方 法，那么就要定义很多个全局函数，于是我们这个自定义的引用类型就丝毫没有封装性可言了。好在， 这些问题可以通过使用原型模式来解决。 6.2.3 原型模式我们创建的每个函数都有一个 prototype（原型）属性，这个属性是一个指针，指向一个对象， 而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。如果按照字面意思来理解，那 么 prototype 就是通过调用构造函数而创建的那个对象实例的原型对象。使用原型对象的好处是可以 让所有对象实例共享它所包含的属性和方法。换句话说，不必在构造函数中定义对象实例的信息，而是 可以将这些信息直接添加到原型对象中，如下面的例子所示。 function Person(){ } Person.prototype.name = &quot;Nicholas&quot;; Person.prototype.age = 29; Person.prototype.job = &quot;Software Engineer&quot;; Person.prototype.sayName = function(){ alert(this.name); }; var person1 = new Person(); person1.sayName(); //&quot;Nicholas&quot; var person2 = new Person(); person2.sayName(); //&quot;Nicholas&quot; alert(person1.sayName == person2.sayName);//true 在此，我们将 sayName()方法和所有属性直接添加到了 Person 的 prototype 属性中，构造函数 变成了空函数。即使如此，也仍然可以通过调用构造函数来创建新对象，而且新对象还会具有相同的属 性和方法。但与构造函数模式不同的是，新对象的这些属性和方法是由所有实例共享的。换句话说， person1 和 person2 访问的都是同一组属性和同一个 sayName()函数。要理解原型模式的工作原理， 必须先理解 ECMAScript 中原型对象的性质。 理解原型对象 无论什么时候，只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个 prototype 属性，这个属性指向函数的原型对象。在默认情况下，所有原型对象都会自动获得一个 constructor （构造函数）属性，这个属性包含一个指向 prototype 属性所在函数的指针。就拿前面的例子来说， Person.prototype. constructor 指向 Person。而通过这个构造函数，我们还可继续为原型对象 添加其他属性和方法。 创建了自定义的构造函数之后，其原型对象默认只会取得 constructor 属性；至于其他方法，则 都是从 Object 继承而来的。当调用构造函数创建一个新实例后，该实例的内部将包含一个指针（内部 属性），指向构造函数的原型对象。ECMA-262 第 5 版中管这个指针叫[[Prototype]]。虽然在脚本中 没有标准的方式访问 [[Prototype]] ， 但 Firefox、Safari 和 Chrome 在每个对象上都支持一个属性 proto；而在其他实现中，这个属性对脚本则是完全不可见的。不过，要明确的真正重要的一点就 是，这个连接存在于实例与构造函数的原型对象之间，而不是存在于实例与构造函数之间。 虽然在所有实现中都无法访问到[[Prototype]]，但可以通过 isPrototypeOf()方法来确定对象之 间是否存在这种关系。 从本质上讲， 如果 [[Prototype]] 指向调用 isPrototypeOf() 方法的对象 （Person.prototype），那么这个方法就返回 true Person.prototype.isProtytypeOf(person1) //true Person.prototype.isPrototypeOf(person2) // true ECMAScript 5 增加了一个新方法，叫 Object.getPrototypeOf()，在所有支持的实现中，这个 方法返回[[Prototype]]的值。例如： Object.getPrototypeOf(person1) == Person.prototype //true Object.getPrototypeOf(person1).name //Nicholas 使用 Object.getPrototypeOf() 可以方便地取得一个对象的原型，而这在利用原型实现继承（本章稍后会讨论）的情况下是非常重要的。 ​ 每当代码读取某个对象的某个属性时，都会执行一次搜索，目标是具有给定名字的属性。搜索首先 从对象实例本身开始。如果在实例中找到了具有给定名字的属性，则返回该属性的值；如果没有找到， 则继续搜索指针指向的原型对象，在原型对象中查找具有给定名字的属性。如果在原型对象中找到了这 个属性，则返回该属性的值。也就是说，在我们调用 person1.sayName()的时候，会先后执行两次搜 索。首先，解析器会问：“实例 person1 有 sayName 属性吗？”答：“没有。”然后，它继续搜索，再 问：“person1 的原型有 sayName 属性吗？”答：“有。”于是，它就读取那个保存在原型对象中的函 数。当我们调用 person2.sayName()时，将会重现相同的搜索过程，得到相同的结果。而这正是多个 对象实例共享原型所保存的属性和方法的基本原理。 前面提到过，原型最初只包含 constructor 属性，而该属性也是共享的，因此 可以通过对象实例访问。 如果在实例对象中定义的属性名与原型对象中的属性名冲突，则会屏蔽原型对象中的属性值 function Person(){} Person.prototype,name = 'Nicholas' Person.prototype.age = 20 Person.prototype.sayName = function(){ return this.name } var person1 = new Person() var person2 = new Person() person1.name // 'Nicholas' person1.name = 'chenyu' person1.name // chenyu person2.name // 'Nicholas' 在这个例子中，person1 的 name 被一个新值给屏蔽了。但无论访问 person1.name 还是访问 person2.name 都能够正常地返回值，即分别是”Greg”（来自对象实例）和”Nicholas”（来自原型）。 当在 alert()中访问 person1.name 时，需要读取它的值，因此就会在这个实例上搜索一个名为 name 的属性。这个属性确实存在，于是就返回它的值而不必再搜索原型了。当以同样的方式访问 person2. name 时，并没有在实例上发现该属性，因此就会继续搜索原型，结果在那里找到了 name 属性。 当为对象实例添加一个属性时，这个属性就会屏蔽原型对象中保存的同名属性；换句话说，添加这 个属性只会阻止我们访问原型中的那个属性，但不会修改那个属性。即使将这个属性设置为 null，也 只会在实例中设置这个属性，而不会恢复其指向原型的连接。不过，使用 delete 操作符则可以完全删 除实例属性，从而让我们能够重新访问原型中的属性， delete person1.name person1.name // &quot;Nicholas&quot; 使用 hasOwnProperty()方法可以检测一个属性是存在于实例中，还是存在于原型中。这个方法（不 要忘了它是从 Object 继承来的）只在给定属性存在于对象实例中时，才会返回 true。 原型与in操作符 当in单独使用时，in 操作符会在通 过对象能够访问给定属性时返回 true，无论该属性存在于实例中还是原型中。 function Person(){} Person.prototype,name = 'Nicholas' Person.prototype.age = 20 Person.prototype.sayName = function(){ return this.name } var person1 = new Person() var person2 = new Person() 'name' in person1 // true person1.name = 'test' 'name' in person1 // true 在以上代码执行的整个过程中，name 属性要么是直接在对象上访问到的，要么是通过原型访问到 的。因此，调用”name” in person1 始终都返回 true，无论该属性存在于实例中还是存在于原型中。 同时使用 hasOwnProperty()方法和 in 操作符，就可以确定该属性到底是存在于对象中，还是存在于 原型中 function hasOwnPrototype(obj,name){ return ! obj.hasOwnProperty(name) &amp;&amp; (name in obj) } 由于 in 操作符只要通过对象能够访问到属性就返回 true，hasOwnProperty()只在属性存在于 实例中时才返回 true，因此只要 in 操作符返回 true 而 hasOwnProperty()返回 false，就可以确 定属性是原型中的属性。下面来看一看上面定义的函数 hasPrototypeProperty()的用法。 在使用 for-in 循环时，当实例对象中的属性设置描述符enumerable为false时，无法进行枚举。 要取得对象上所有可枚举的实例属性，可以使用 ECMAScript 5 的 Object.keys()方法。这个方法 接收一个对象作为参数，返回一个包含所有可枚举属性的字符串数组。 function Person(){} Person.prototype,name = 'Nicholas' Person.prototype.age = 20 Person.prototype.sayName = function(){ return this.name } Object.keys(Person.prototype) // name ,age ,sayName var p1 = new Person() p1.name = 'rob' p1.age = 21 var p1Keys = Object.keys(p1) p1Keys // name , age 这里，变量 keys 中将保存一个数组，数组中是字符串”name”、”age”、”job”和”sayName”。这 个顺序也是它们在 for-in 循环中出现的顺序。如果是通过 Person 的实例调用，则 Object.keys() 返回的数组只包含”name”和”age”这两个实例属性。 如果你想要得到所有实例属性，无论它是否可枚举，都可以使用 Object.getOwnPropertyNames()方法。 var keys = Object.getOwnPropertyNames(Person.prototype) keys // constructor , name , age , sayName 注意结果中包含了不可枚举的 constructor 属性。Object.keys()和 Object.getOwnPropertyNames()方法都可以用来替代 for-in 循环。 更简单的原型语法 前面例子中每添加一个属性和方法就要敲一遍 Person.prototype。为减少 不必要的输入，也为了从视觉上更好地封装原型的功能，更常见的做法是用一个包含所有属性和方法的 对象字面量来重写整个原型对象 function Person(){} Person.prototype = { name : 'chenyu', age:25, sayName:function(){ return this.name } } 在上面的代码中，我们将 Person.prototype 设置为等于一个以对象字面量形式创建的新对象。 最终结果相同，但有一个例外：constructor 属性不再指向 Person 了。前面曾经介绍过，每创建一 个函数，就会同时创建它的 prototype 对象，这个对象也会自动获得 constructor 属性。而我们在 这里使用的语法，本质上完全重写了默认的 prototype 对象，因此 constructor 属性也就变成了新 对象的 constructor 属性（指向 Object 构造函数），不再指向 Person 函数。此时，尽管 instanceof 操作符还能返回正确的结果，但通过 constructor 已经无法确定对象的类型了 var friend = new Person() friend instanceof Person // true friend.constructor == Person // false friend.constructor == Object // true 创建覆盖的原型对象时，添加构造函数属性指针 Person.prototype = { constructor: Person, name: 'chenyu', age:21, sayName:function(){ return this.name } } 字面量创建的constructor属性是可以被枚举的，可以使用Object.defineProperty()进行描述符修改 Person.prototype = { name: 'chenyu', age:21, sayName:function(){ return this.name } } Obejct.defineProperty(Person.prototype,'constructor',{ enumerable:false, value:Person }) 原型的动态性 由于在原型中查找值的过程是一次搜索，因此我们对原型对象所做的任何修改都能够立即从实例上反映出来——即使是先创建了实例后修改原型也照样如此。 var friend = new Person() Person.prototype.sayHi = function(){ alert('hi') } friend.sayHi() // hi 以上代码先创建了 Person 的一个实例，并将其保存在 person 中。然后，下一条语句在 Person. prototype 中添加了一个方法 sayHi()。即使 person 实例是在添加新方法之前创建的，但它仍然可 以访问这个新方法。其原因可以归结为实例与原型之间的松散连接关系。当我们调用 person.sayHi() 时，首先会在实例中搜索名为 sayHi 的属性，在没找到的情况下，会继续搜索原型。因为实例与原型 之间的连接只不过是一个指针，而非一个副本，因此就可以在原型中找到新的 sayHi 属性并返回保存 在那里的函数。 尽管可以随时为原型添加属性和方法，并且修改能够立即在所有对象实例中反映出来，但如果是重 写整个原型对象，那么情况就不一样了。我们知道，调用构造函数时会为实例添加一个指向最初原型的 [[Prototype]]指针，而把原型修改为另外一个对象就等于切断了构造函数与最初原型之间的联系。 请记住：实例中的指针仅指向原型，而不指向构造函数。看下面的例子。 var friend = new Person() Person.prototype = { sayHi : function(){ alert('hi') } } friend.sayHi() // error 原生对象的原型 原型模式的重要性不仅体现在创建自定义类型方面，就连所有原生的引用类型，都是采用这种模式 创建的。所有原生引用类型（Object、Array、String，等等）都在其构造函数的原型上定义了方法。 例如， 在 Array.prototype 中可以找到 sort() 方法， 而在 String.prototype 中可以找到 substring()方法 通过原生对象的原型，不仅可以取得所有默认方法的引用，而且也可以定义新方法。可以像修改自 定义对象的原型一样修改原生对象的原型， 因此可以随时添加方法。 下面的代码就给基本包装类型 String 添加了一个名为 startsWith()的方法。 String.prototype.startsWith = function (text) { return this.indexOf(text) == 0; }; var msg = &quot;Hello world!&quot;; alert(msg.startsWith(&quot;Hello&quot;)); 这里新定义的 startsWith()方法会在传入的文本位于一个字符串开始时返回 true。既然方法被 添加给了 String.prototype，那么当前环境中的所有字符串就都可以调用它。由于 msg 是字符串， 而且后台会调用 String 基本包装函数创建这个字符串，因此通过 msg 就可以调用 startsWith()方法。 原型对象的问题 原型模式也不是没有缺点。首先，它省略了为构造函数传递初始化参数这一环节，结果所有实例在 默认情况下都将取得相同的属性值。虽然这会在某种程度上带来一些不方便，但还不是原型的最大问题。 原型模式的最大问题是由其共享的本性所导致的。 原型中所有属性是被很多实例共享的，这种共享对于函数非常合适。对于那些包含基本值的属性倒 也说得过去，毕竟（如前面的例子所示），通过在实例上添加一个同名属性，可以隐藏原型中的对应属 性。然而，对于包含引用类型值的属性来说，问题就比较突出了。 function Person(){} Person.prototype = { name:'chenyu', age:25, friends:['1','2'] } var person1 = new Person() var person2 = new Person() person1.friends.push('3') // [1,2,3] person2.friends // [1,2,3] 随着改变 person1.friends == person2.friends // 指向同一个引用类型 在此，Person.prototype 对象有一个名为 friends 的属性，该属性包含一个字符串数组。然后， 创建了 Person 的两个实例。接着，修改了 person1.friends 引用的数组，向数组中添加了一个字符 串。由于 friends 数组存在于 Person.prototype 而非 person1 中，所以刚刚提到的修改也会通过 person2.friends（与 person1.friends 指向同一个数组）反映出来。假如我们的初衷就是像这样 在所有实例中共享一个数组，那么对这个结果我没有话可说。可是，实例一般都是要有属于自己的全部 属性的。而这个问题正是我们很少看到有人单独使用原型模式的原因所在。 6.2.4 组合使用构造函数模式和原型模式创建自定义类型的最常见方式，就是组合使用构造函数模式与原型模式。构造函数模式用于定义实 例属性，而原型模式用于定义方法和共享的属性。结果，每个实例都会有自己的一份实例属性的副本， 但同时又共享着对方法的引用，最大限度地节省了内存。另外，这种混成模式还支持向构造函数传递参 数；可谓是集两种模式之长。 function Person(name,age){ this.name = name this.age = age this.friends = [1,2,3] } Person.prototype = { constructor : Person, sayName:function(){ return this.name } } var person1 = new Person('tom',23) var person2 = new Person('jerry', 22) person1.friends.push(4) // [1,2,3,4] person2.friends // [1,2,3] person1.friends == person2.friends // false person1.sayName == person2.sayName // true 在这个例子中，实例属性都是在构造函数中定义的，而由所有实例共享的属性 constructor 和方 法 sayName()则是在原型中定义的。而修改了 person1.friends（向其中添加一个新字符串），并不 会影响到 person2.friends，因为它们分别引用了不同的数组。 这种构造函数与原型混成的模式，是目前在 ECMAScript 中使用最广泛、认同度最高的一种创建自定义类型的方法。可以说，这是用来定义引用类型的一种默认模式。 动态原型模式有其他 OO 语言经验的开发人员在看到独立的构造函数和原型时，很可能会感到非常困惑。动态原 型模式正是致力于解决这个问题的一个方案，它把所有信息都封装在了构造函数中，而通过在构造函数 中初始化原型（仅在必要的情况下），又保持了同时使用构造函数和原型的优点。换句话说，可以通过 检查某个应该存在的方法是否有效，来决定是否需要初始化原型。 function Person(name,age){ this.name= name this.age = age if(typeof person.prototype.sayName != 'function'){ Person.prototype.sayName = function(){ return this.name } } } var friend = new Person('tom',28) friend.sayName() // tom 这里只在 sayName()方法不存在的情况下，才会将它添加到原 型中。这段代码只会在初次调用构造函数时才会执行。此后，原型已经完成初始化，不需要再做什么修 改了。不过要记住，这里对原型所做的修改，能够立即在所有实例中得到反映。因此，这种方法确实可 以说非常完美。其中，if 语句检查的可以是初始化之后应该存在的任何属性或方法——不必用一大堆 if 语句检查每个属性和每个方法；只要检查其中一个即可。对于采用这种模式创建的对象，还可以使 用 instanceof 操作符确定它的类型。 6.2.6 寄生构造函数模式在前述的几种模式都不适用的情况下，可以使用寄生（parasitic）构造函数模式。这种模式 的基本思想是创建一个函数，该函数的作用仅仅是封装创建对象的代码，然后再返回新创建的对象；但 从表面上看，这个函数又很像是典型的构造函数。 function Person(name, age, job){ var o = new Object(); o.name = name; o.age = age; o.job = job; o.sayName = function(){ alert(this.name); }; return o; } var friend = new Person('tom',29,'The engineer') friend,sayName() //tom 在这个例子中，Person 函数创建了一个新对象，并以相应的属性和方法初始化该对象，然后又返 回了这个对象。除了使用 new 操作符并把使用的包装函数叫做构造函数之外，这个模式跟工厂模式其实 是一模一样的。构造函数在不返回值的情况下，默认会返回新对象实例。而通过在构造函数的末尾添加一个 return 语句，可以重写调用构造函数时返回的值。 关于寄生构造函数模式，有一点需要说明：首先，返回的对象与构造函数或者与构造函数的原型属 性之间没有关系；也就是说，构造函数返回的对象与在构造函数外部创建的对象没有什么不同。为此， 不能依赖 instanceof 操作符来确定对象类型。由于存在上述问题，我们建议在可以使用其他模式的情 况下，不要使用这种模式。 6.2.7 稳妥构造函数模式function Person(name,age){ var o = new Object() o.sayName(){ return name } return o } 仅仅能通过sayName获取name属性，其他方法无法获得。构造函数中，不使用this，不使用原型。 6.3 继承6.3.1 原型链ECMAScript 中描述了原型链的概念，并将原型链作为实现继承的主要方法。其基本思想是利用原 型让一个引用类型继承另一个引用类型的属性和方法。简单回顾一下构造函数、原型和实例的关系：每 个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型 对象的内部指针。那么，假如我们让原型对象等于另一个类型的实例，结果会怎么样呢？显然，此时的 原型对象将包含一个指向另一个原型的指针，相应地，另一个原型中也包含着一个指向另一个构造函数 的指针。假如另一个原型又是另一个类型的实例，那么上述关系依然成立，如此层层递进，就构成了实 例与原型的链条。这就是所谓原型链的基本概念。 实现原型链有一种基本模式，其代码大致如下。 function superType(){ this.property = true } superType.prototype.superCall = function(){ return this.property } function subType(){ this.subproperty = false } subType.prototype = new superType() subType.prototype.getSubValue = function(){ return this.subproperty } var instance = new SubType() instance.superCall() // true 以上代码定义了两个类型：SuperType 和 SubType。每个类型分别有一个属性和一个方法。它们 的主要区别是 SubType 继承了 SuperType，而继承是通过创建 SuperType 的实例，并将该实例赋给 SubType.prototype 实现的。实现的本质是重写原型对象，代之以一个新类型的实例。换句话说，原 来存在于 SuperType 的实例中的所有属性和方法，现在也存在于 SubType.prototype 中了。在确立了 继承关系之后，我们给 SubType.prototype 添加了一个方法，这样就在继承了 SuperType 的属性和方 法的基础上又添加了一个新方法。 既然 SubType.prototype 现在是 SuperType的实例，那么 property 当然就位于该实例中了。此外，要注意 instance.constructor 现在指向的 是 SuperType，这是因为原来 SubType.prototype 中的 constructor 被重写了的缘故 。 通过实现原型链，本质上扩展了本章前面介绍的原型搜索机制。读者大概还记得，当以读取模式访 问一个实例属性时，首先会在实例中搜索该属性。如果没有找到该属性，则会继续搜索实例的原型。在 通过原型链实现继承的情况下， 搜索过程就得以沿着原型链继续向上。 就拿上面的例子来说， 调用 instance.getSuperValue()会经历三个搜索步骤：1）搜索实例；2）搜索 SubType.prototype； 3）搜索 SuperType.prototype，最后一步才会找到该方法。在找不到属性或方法的情况下，搜索过 程总是要一环一环地前行到原型链末端才会停下来。 别忘记默认的原型 事实上，前面例子中展示的原型链还少一环。我们知道，所有引用类型默认都继承了 Object，而 这个继承也是通过原型链实现的。大家要记住，所有函数的默认原型都是 Object 的实例，因此默认原 型都会包含一个内部指针，指向 Object.prototype。这也正是所有自定义类型都会继承 toString()、 valueOf()等默认方法的根本原因。所以，我们说上面例子展示的原型链中还应该包括另外一个继承层 次。 一句话，SubType 继承了 SuperType，而 SuperType 继承了 Object。当调用 instance.toString() 时，实际上调用的是保存在 Object.prototype 中的那个方法。 确定原型和实例的关系 可以通过两种方式来确定原型和实例之间的关系。第一种方式是使用 instanceof 操作符，只要用 这个操作符来测试实例与原型链中出现过的构造函数，结果就会返回 true。以下几行代码就说明了这 一点。 可以通过两种方式来确定原型和实例之间的关系。第一种方式是使用 instanceof 操作符，只要用 这个操作符来测试实例与原型链中出现过的构造函数，结果就会返回 true。以下几行代码就说明了这 一点。 alert(instance instanceof Object); //全部是true alert(instance instanceof SuperType); alert(instance instanceof SubType); 由于原型链的关系，我们可以说 instance 是 Object、SuperType 或 SubType 中任何一个类型 的实例。因此，测试这三个构造函数的结果都返回了 true。 第二种方式是使用 isPrototypeOf()方法。同样，只要是原型链中出现过的原型，都可以说是该 原型链所派生的实例的原型，因此 isPrototypeOf()方法也会返回 true Object.prototype.isPrototypeOf(instance) SuperType.prototype.isPrototypeOf(instance) SubType.prototype.isPrototypeOf(instance) 谨慎的定义方法 子类型有时候需要重写超类型中的某个方法，或者需要添加超类型中不存在的某个方法。但不管怎 样，给原型添加方法的代码一定要放在替换原型的语句之后。 function SuperType(){ this.property = true } SuperType.prototype.getSuperValue = function(){ return this.property } function SubType(){ this.subProperty = false } SubType.prototype = new SuperType() SubType.prototype.getSuperValue = function(){ return false } var instance = new SubType() instance.getSuperValue // false 在以上代码中，加粗的部分是两个方法的定义。第一个方法 getSubValue()被添加到了 SubType 中。第二个方法 getSuperValue()是原型链中已经存在的一个方法，但重写这个方法将会屏蔽原来的 那个方法。换句话说，当通过 SubType 的实例调用 getSuperValue()时，调用的就是这个重新定义 的方法；但通过 SuperType 的实例调用 getSuperValue()时，还会继续调用原来的那个方法。这里 要格外注意的是，必须在用 SuperType 的实例替换原型之后，再定义这两个方法。 还有一点需要提醒，即在通过原型链实现继承时，不能使用对象字面量创建原型方法。因为这 样做就会重写原型链 function SuperType(){ this.property = true } SuperType.prototype.getSuperValue = function(){ return this.property } function SubType(){ this.subProperty = false } SubType.prototype = new SuperType() SubType.prototype = { getSubValue : function (){ return this.subproperty; }, } //使用字面量会重写原型 并无法访问超类型的属性和方法 以上代码展示了刚刚把 SuperType 的实例赋值给原型，紧接着又将原型替换成一个对象字面量而 导致的问题。由于现在的原型包含的是一个 Object 的实例，而非 SuperType 的实例，因此我们设想 中的原型链已经被切断——SubType 和 SuperType 之间已经没有关系了。 原型链的问题 原型链虽然很强大，可以用它来实现继承，但它也存在一些问题。其中，最主要的问题来自包含引 用类型值的原型。想必大家还记得，我们前面介绍过包含引用类型值的原型属性会被所有实例共享；而 这也正是为什么要在构造函数中，而不是在原型对象中定义属性的原因。在通过原型来实现继承时，原 型实际上会变成另一个类型的实例。于是，原先的实例属性也就顺理成章地变成了现在的原型属性了 （如果构造函数中存在引用类型，则生成的实例共享当前引用类型） 6.3.2 借用构造函数在解决原型中包含引用类型值所带来问题的过程中， 开发人员开始使用一种叫做借用构造函数 （constructor stealing）的技术（有时候也叫做伪造对象或经典继承）。这种技术的基本思想相当简单，即 在子类型构造函数的内部调用超类型构造函数。别忘了，函数只不过是在特定环境中执行代码的对象， 因此通过使用 apply()和 call()方法也可以在（将来）新创建的对象上执行构造函数 function SuperType(){ this.colors = ['red','blue','orange'] } function SubType(){ superType.call(this) } var instance1 = new SubType() var instance2 = new SubType() instance1.push('green') // ['red','blue','orange','green'] instance2 // ['red','blue','orange'] 传递参数 相对于原型链而言，借用构造函数有一个很大的优势，即可以在子类型构造函数中向超类型构造函 数传递参数。 function SuperType(name){ this.name = name; } function SubType(){ //继承了 SuperType，同时还传递了参数 SuperType.call(this, &quot;Nicholas&quot;); //实例属性 this.age = 29; } var instance = new SubType(); alert(instance.name); //&quot;Nicholas&quot;; alert(instance.age); //29 以上代码中的 SuperType 只接受一个参数 name，该参数会直接赋给一个属性。在 SubType 构造 函数内部调用 SuperType 构造函数时，实际上是为 SubType 的实例设置了 name 属性。为了确保 SuperType 构造函数不会重写子类型的属性，可以在调用超类型构造函数后，再添加应该在子类型中 定义的属性。 借用构造函数的问题 如果仅仅是借用构造函数，那么也将无法避免构造函数模式存在的问题——方法都在构造函数中定 义，因此函数复用就无从谈起了。而且，在超类型的原型中定义的方法，对子类型而言也是不可见的，结 果所有类型都只能使用构造函数模式。考虑到这些问题，借用构造函数的技术也是很少单独使用的。 6.3.3 组合继承组合继承 = 原型链继承（原型的属性和方法继承-实例之前的共享）+ 构造函数继承（实例对象的属性和方法继承） function SuperType(name){this.name = name;this.colors=['red','blue']} SuperType.prototype.sayName = function(){ return this.name } function SubType(name,age){ SuperType.call(this,name) this.age = age } SubType.prototype = new SuperType() SubType.prototype.constructor = SubType var instance1 = new SubType('instance1',28) var instance2 = new SubType('instance2',26) instance1.colors.push('green') // ['red','blue','green'] instance2.colors // ['red','blue'] 在这个例子中，SuperType 构造函数定义了两个属性：name 和 colors。SuperType 的原型定义 了一个方法 sayName()。SubType 构造函数在调用 SuperType 构造函数时传入了 name 参数，紧接着 又定义了它自己的属性 age。然后，将 SuperType 的实例赋值给 SubType 的原型，然后又在该新原型 上定义了方法 sayAge()。这样一来，就可以让两个不同的 SubType 实例既分别拥有自己属性——包 括 colors 属性，又可以使用相同的方法了。 组合继承避免了原型链和借用构造函数的缺陷，融合了它们的优点，成为 JavaScript 中最常用的继 承模式。而且，instanceof 和 isPrototypeOf()也能够用于识别基于组合继承创建的对象。 6.3.4 原型式继承道格拉斯·克罗克福德在 2006 年写了一篇文章，题为 Prototypal Inheritance in JavaScript （JavaScript 中的原型式继承）。在这篇文章中，他介绍了一种实现继承的方法，这种方法并没有使用严格意义上的 构造函数。他的想法是借助原型可以基于已有的对象创建新对象，同时还不必因此创建自定义类型。为 了达到这个目的，他给出了如下函数。 function object(o){ function F(){} F.prototype = o; return new F(); } 在 object()函数内部，先创建了一个临时性的构造函数，然后将传入的对象作为这个构造函数的 原型，最后返回了这个临时类型的一个新实例。从本质上讲，object()对传入其中的对象执行了一次浅复制。 克罗克福德主张的这种原型式继承，要求你必须有一个对象可以作为另一个对象的基础。如果有这么 一个对象的话，可以把它传递给 object()函数，然后再根据具体需求对得到的对象加以修改即可。在这 个例子中，可以作为另一个对象基础的是 person 对象，于是我们把它传入到 object()函数中，然后该 函数就会返回一个新对象。这个新对象将 person 作为原型，所以它的原型中就包含一个基本类型值属性 和一个引用类型值属性。这意味着 person.friends 不仅属于 person 所有，而且也会被 anotherPerson 以及 yetAnotherPerson 共享。实际上，这就相当于又创建了 person 对象的两个副本。 ECMAScript 5 通过新增 Object.create()方法规范化了原型式继承。这个方法接收两个参数：一 个用作新对象原型的对象和（可选的）一个为新对象定义额外属性的对象。在传入一个参数的情况下， Object.create()与 object()方法的行为相同。 Object.create()方法的第二个参数与 Object.defineProperties()方法的第二个参数格式相 同：每个属性都是通过自己的描述符定义的。以这种方式指定的任何属性都会覆盖原型对象上的同名属性。 支持 Object.create()方法的浏览器有 IE9+、Firefox 4+、Safari 5+、Opera 12+和 Chrome。 在没有必要兴师动众地创建构造函数，而只想让一个对象与另一个对象保持类似的情况下，原型式 继承是完全可以胜任的。不过别忘了，包含引用类型值的属性始终都会共享相应的值，就像使用原型模 式一样。 6.3.5 寄生式继承寄生式（parasitic）继承是与原型式继承紧密相关的一种思路，并且同样也是由克罗克福德推而广 之的。寄生式继承的思路与寄生构造函数和工厂模式类似，即创建一个仅用于封装继承过程的函数，该 函数在内部以某种方式来增强对象，最后再像真地是它做了所有工作一样返回对象。 6.3.6 寄生组合式继承前面说过，组合继承是 JavaScript 最常用的继承模式；不过，它也有自己的不足。组合继承最大的 问题就是无论什么情况下，都会调用两次超类型构造函数：一次是在创建子类型原型的时候，另一次是 在子类型构造函数内部。没错，子类型最终会包含超类型对象的全部实例属性，但我们不得不在调用子 类型构造函数时重写这些属性。 function SuperType(name){this.name = name} SuperType.prototype.sayName = function(){ return this.name } function SubType(name,age){ SuperType.call(this,name) // 第二次调用SuperType构造函数 this.age = age } SubType.prototype = new SuperType() //第一次调用SuperType构造函数 SubType.prototype.constructor = SubType 在第一次调用 SuperType 构造函数时， SubType.prototype 会得到两个属性：name 和 colors；它们都是 SuperType 的实例属性，只不过 现在位于 SubType 的原型中。当调用 SubType 构造函数时，又会调用一次 SuperType 构造函数，这 一次又在新对象上创建了实例属性 name 和 colors。于是，这两个属性就屏蔽了原型中的两个同名属 性。 有两组 name 和 colors 属性：一组在实例上，一组在 SubType 原型中。这就是调 用两次 SuperType 构造函数的结果。好在我们已经找到了解决这个问题方法——寄生组合式继承。 所谓寄生组合式继承，即通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。其背 后的基本思路是：不必为了指定子类型的原型而调用超类型的构造函数，我们所需要的无非就是超类型 原型的一个副本而已。本质上，就是使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型 的原型。 function inheritance(subType,superType){ subType.prototype = Object.create(superType.prototype) subType.prototype.constructor = subType } 通过给子类型的原型复制超类型原型的副本，避免调用超类型的构造函数，防止复制构造函数中用于创建实例的属性。直接从超类型的原型链上生成副本，避免与子类型生成的实例属性冲突。 这个例子的高效率体现在它只调用了一次 SuperType 构造函数，并且因此避免了在 SubType. prototype 上面创建不必要的、多余的属性。与此同时，原型链还能保持不变；因此，还能够正常使用 instanceof 和 isPrototypeOf()。开发人员普遍认为寄生组合式继承是引用类型最理想的继承范式。 总结ECMAScript 支持面向对象（OO）编程，但不使用类或者接口。对象可以在代码执行过程中创建和 增强，因此具有动态性而非严格定义的实体。在没有类的情况下，可以采用下列模式创建对象。  工厂模式，使用简单的函数创建对象，为对象添加属性和方法，然后返回对象。这个模式后来 被构造函数模式所取代。  构造函数模式，可以创建自定义引用类型，可以像创建内置对象实例一样使用 new 操作符。不 过，构造函数模式也有缺点，即它的每个成员都无法得到复用，包括函数。由于函数可以不局 限于任何对象（即与对象具有松散耦合的特点），因此没有理由不在多个对象间共享函数。  原型模式，使用构造函数的 prototype 属性来指定那些应该共享的属性和方法。组合使用构造 函数模式和原型模式时，使用构造函数定义实例属性，而使用原型定义共享的属性和方法。 JavaScript 主要通过原型链实现继承。原型链的构建是通过将一个类型的实例赋值给另一个构造函 数的原型实现的。这样，子类型就能够访问超类型的所有属性和方法，这一点与基于类的继承很相似。 原型链的问题是对象实例共享所有继承的属性和方法，因此不适宜单独使用。解决这个问题的技术是借 用构造函数，即在子类型构造函数的内部调用超类型构造函数。这样就可以做到每个实例都具有自己的 属性，同时还能保证只使用构造函数模式来定义类型。使用最多的继承模式是组合继承，这种模式使用 原型链继承共享的属性和方法，而通过借用构造函数继承实例属性。 此外，还存在下列可供选择的继承模式。  原型式继承，可以在不必预先定义构造函数的情况下实现继承，其本质是执行对给定对象的浅 复制。而复制得到的副本还可以得到进一步改造。  寄生式继承，与原型式继承非常相似，也是基于某个对象或某些信息创建一个对象，然后增强 对象，最后返回对象。为了解决组合继承模式由于多次调用超类型构造函数而导致的低效率问 题，可以将这个模式与组合继承一起使用。  寄生组合式继承，集寄生式继承和组合继承的优点与一身，是实现基于类型继承的最有效方式。","link":"/passages/%E3%80%90JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%91%E7%AC%AC%E5%85%AD%E7%AB%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"},{"title":"【JS高级程序设计】 第二章 使用JavaScript","text":"2.1 “script”元素向 HTML 页面中插入 JavaScript 的主要方法，就是使用&lt;/script&gt;元素。这个元素由 Netscape 创造 并在 Netscape Navigator 2 中首先实现。后来，这个元素被加入到正式的 HTML 规范中。HTML 4.01 为 &lt;/script&gt;定义了下列 6 个属性： async : 可选。表示应该立即下载脚本，但不应妨碍页面中的其他操作，比如下载其他资源或等待加载其他脚本。只对外部脚本文件有效。 charset：可选。表示通过 src 属性指定的代码的字符集。由于大多数浏览器会忽略它的值， 因此这个属性很少有人用。 defer：可选。表示脚本可以延迟到文档完全被解析和显示之后再执行。只对外部脚本文件有效。IE7 及更早版本对嵌入脚本也支持这个属性。 language：已废弃。原来用于表示编写代码使用的脚本语言（如 JavaScript、JavaScript1.2 或 VBScript）。大多数浏览器会忽略这个属性，因此也没有必要再用了。 src：可选。表示包含要执行代码的外部文件。 type：可选。可以看成是 language 的替代属性；表示编写代码使用的脚本语言的内容类型（也称为 MIME 类型）。虽然 text/javascript 和 text/ecmascript 都已经不被推荐使用，但人 们一直以来使用的都还是 text/javascript。实际上，服务器在传送 JavaScript 文件时使用的 MIME 类型通常是 application/x–javascript，但在 type 中设置这个值却可能导致脚本被 忽略。另外，在非IE浏览器中还可以使用以下值：application/javascript 和 application/ecmascript 。 考虑到约定俗成和最大限度的浏览器兼容性， 目前 type 属性的值依旧还是 text/javascript。不过，这个属性并不是必需的，如果没有指定这个属性，则其默认值仍为 text/javascript。 ##2.1.3 异步脚本 HTML5为script元素定义了async属性。同样与 defer 类似，async 只适用于外部脚本文件，并告诉浏览器立即下载文件。但与 defer 不同的是，标记为 async 的脚本并不保证按照指定它们的先后顺序执行。 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Example HTML Page&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; async src=&quot;example1.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; async src=&quot;example2.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 这里放内容 --&gt; &lt;/body&gt; &lt;/html&gt; 第二个脚本可能会在第一个脚本之前执行，因此，需要确认两者没有相互的依赖关系。 指定 async 属性的目的是不让页面等待两个脚本下载和执行，从而异步加载页面其他内容。 为此，建议异步脚本不要在加载期间修改 DOM。 异步脚本一定会在页面的 load 事件前执行，但可能会在 DOMContentLoaded 事件触发之前或之 后执行。支持异步脚本的浏览器有 Firefox 3.6、Safari 5 和 Chrome。 2.2嵌入代码与维护性在 HTML 中嵌入 JavaScript 代码虽然没有问题，但一般认为最好的做法还是尽可能使用外部文件来 包含 JavaScript 代码。不过，并不存在必须使用外部文件的硬性规定，但支持使用外部文件的人多会强 调如下优点。 可维护性：遍及不同 HTML 页面的 JavaScript 会造成维护问题。但把所有 JavaScript 文件都放在 一个文件夹中，维护起来就轻松多了。而且开发人员因此也能够在不触及 HTML 标记的情况下， 集中精力编辑 JavaScript 代码。 可缓存：浏览器能够根据具体的设置缓存链接的所有外部 JavaScript 文件。也就是说，如果有两个 页面都使用同一个文件，那么这个文件只需下载一次。因此，最终结果就是能够加快页面加载的 速度。 适应未来：通过外部文件来包含 JavaScript 无须使用前面提到 XHTML 或注释 hack。HTML 和 XHTML 包含外部文件的语法是相同的。 #2.4&lt;\\noscript&gt;元素 noscript里面内容显示的前提条件： 浏览器不支持脚本 支持脚本但是禁用 //html页面 &lt;noscript&gt; &lt;p&gt;本页面需要浏览器支持（启用）JavaScript。 &lt;/noscript&gt; 2.5小结把 JavaScript 插入到 HTML 页面中要使用&lt;/script&gt;元素。使用这个元素可以把 JavaScript 嵌入到 HTML 页面中，让脚本与标记混合在一起；也可以包含外部的 JavaScript 文件。而我们需要注意的地方有： 在包含外部 JavaScript 文件时，必须将 src 属性设置为指向相应文件的 URL。而这个文件既可 以是与包含它的页面位于同一个服务器上的文件，也可以是其他任何域中的文件。 所有&lt;/script&gt;元素都会按照它们在页面中出现的先后顺序依次被解析。 在不使用 defer 和 async 属性的情况下， 只有在解析完前面 &lt;/script&gt; 元素中的代码之后， 才会开始解析后面 &lt;/script&gt;元素中的代码。 由于浏览器会先解析完不使用 defer 属性的&lt;/script&gt;元素中的代码，然后再解析后面的内容， 所以一般应该把&lt;/script&gt;元素放在页面最后，即主要内容后面，&lt;/body&gt;标签前面。 使用 defer 属性可以让脚本在文档完全呈现之后再执行。延迟脚本总是按照指定它们的顺序执行。 使用 async 属性可以表示当前脚本不必等待其他脚本，也不必阻塞文档呈现。不能保证异步脚本按照它们在页面中出现的顺序执行。 另外，使用&lt;\\noscript&gt;元素可以指定在不支持脚本的浏览器中显示的替代内容。但在启用了脚本的情况下，浏览器不会显示&lt;\\noscript&gt;元素中的任何内容。","link":"/passages/%E3%80%90JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%91%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%9C%A8HTML%E4%B8%AD%E4%BD%BF%E7%94%A8JavaScript/"},{"title":"【JS高级程序设计】第五章 引用类型","text":"引用类型的值（对象）是引用类型的一个实例。在 ECMAScript 中，引用类型是一种数据结构， 用于将数据和功能组织在一起。它也常被称为类，但这种称呼并不妥当。尽管 ECMAScript 从技术上讲是一门面向对象的语言，但它不具备传统的面向对象语言所支持的类和接口等基本结构。引 用类型有时候也被称为对象定义，因为它们描述的是一类对象所具有的属性和方法。 如前所述，对象是某个特定引用类型的实例。新对象是使用 new 操作符后跟一个构造函数来创建的。 构造函数本身就是一个函数，只不过该函数是出于创建新对象的目的而定义的。 var person = new Object(); 5.1 Object 类型 到目前为止， 我们看到的大多数引用类型值都是 Object 类型的实例；而且， Object 也是 ECMAScript 中使用最多的一个类型。虽然 Object 的实例不具备多少功能，但对于在应用程序中存储 和传输数据而言，它们确实是非常理想的选择。 创建 Object 实例的方式有两种。第一种是使用 new 操作符后跟 Object 构造函数 var person = new Object() person.name = 'tom' person.age = 18 另一种方式是使用对象字面量表示法。对象字面量是对象定义的一种简写形式，目的在于简化创建 包含大量属性的对象的过程。下面这个例子就使用了对象字面量语法定义了与前面那个例子中相同的 person 对象： var person = { name : 'tom', age : 18 } 在使用对象字面量语法时，属性名也可以使用字符串 var person = { &quot;name&quot; : 'tom', &quot;age&quot; : 18, 5 : true } 一般来说，访问对象属性时使用的都是点表示法，这也是很多面向对象语言中通用的语法。不过， 在 JavaScript 也可以使用方括号表示法来访问对象的属性。在使用方括号语法时，应该将要访问的属性 以字符串的形式放在方括号中 如果属性名中包含会导致语法错误的字符，或者属性名使用的是关键字或保留字，也可以使用方括 号表示法。 person[&quot;first name&quot;] = &quot;Nicholas&quot;; 5.2 Array类型除了 Object 之外，Array 类型恐怕是 ECMAScript 中最常用的类型了。而且，ECMAScript 中 的数组与其他多数语言中的数组有着相当大的区别。虽然 ECMAScript 数组与其他语言中的数组都是 数据的有序列表，但与其他语言不同的是，ECMAScript 数组的每一项可以保存任何类型的数据。 也 就是说，可以用数组的第一个位置来保存字符串，用第二位置来保存数值，用第三个位置来保存对象， 以此类推，而且，ECMAScript 数组的大小是可以动态调整的，即可以随着数据的添加自动增长以容 纳新增数据 创建数组的方法1: var arr = new Array() 如果预先知道数组要保存的项目数量，也可以给构造函数传递该数量，而该数量会自动变成 length 属性的值。 var arr = new Array(20)// 创建了一个长度为20的数组 也可以向 Array 构造函数传递数组中应该包含的项。以下代码创建了一个包含 3 个字符串值的数组 var colors = new Array(&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;) 当然，给构造函数传递一个值也可以创建数组。但这时候问题就复杂一点了，因为如果传递的是数 值，则会按照该数值创建包含给定项数的数组；而如果传递的是其他类型的参数，则会创建包含那个值 的只有一项的数组。 var arr = new Array(3) //创建一个3个长度的数组 var arr = new Array('sa') //创建为长度为1的sa 另外，在使用 Array 构造函数时也可以省略 new 操作符 5.2.1 检测数组 instanceof 操作符的问题在于，它假定只有一个全局执行环境。如果网页中包含多个框架，那实 际上就存在两个以上不同的全局执行环境，从而存在两个以上不同版本的 Array 构造函数。如果你从 一个框架向另一个框架传入一个数组，那么传入的数组与在第二个框架中原生创建的数组分别具有各自 不同的构造函数。 为了解决这个问题，ECMAScript 5 新增了 Array.isArray()方法。这个方法的目的是最终确定某 个值到底是不是数组，而不管它是在哪个全局执行环境中创建的。 Array.isArray([]) //true 5.2.2 转换方法如前所述，所有对象都具有 toLocaleString()、toString()和 valueOf()方法。其中，调用 数组的 toString()方法会返回由数组中每个值的字符串形式拼接而成的一个以逗号分隔的字符串。而 调用 valueOf()返回的还是数组。实际上，为了创建这个字符串会调用数组每一项的 toString()方 法。 var colors = ['red','blue','green'] alert(colors.toString()) // red,blue,green alert(colors.valueOf()) // red,blue,green alert(colors) // red,blue,green 在这里，我们首先显式地调用了 toString()方法，以便返回数组的字符串表示，每个值的字符串 表示拼接成了一个字符串，中间以逗号分隔。接着调用 valueOf()方法，而最后一行代码直接将数组 传递给了 alert()。由于 alert()要接收字符串参数，所以它会在后台调用 toString()方法，由此 会得到与直接调用 toString()方法相同的结果。 另外，toLocaleString()方法经常也会返回与 toString()和 valueOf()方法相同的值，但也 不总是如此。当调用数组的 toLocaleString()方法时，它也会创建一个数组值的以逗号分隔的字符 串。而与前两个方法唯一的不同之处在于，这一次为了取得每一项的值，调用的是每一项的 toLocaleString()方法，而不是 toString()方法。 var val = { toString : function () { return '1' }, toLocalString : function () { return '-1' } } var val1 = { toString : function () { return '2' }, toLocalString : function () { return '-2' } } var content = [val,val1] content.toString() // 1 ,2 content.toLocalString() // -1 ,-2 调用每项的toLocalString content // 1 ,2 默认调用toString 方法 数组继承的 toLocaleString()、toString()和 valueOf()方法，在默认情况下都会以逗号分隔的字 符串的形式返回数组项。而如果使用 join()方法，则可以使用不同的分隔符来构建这个字符串。join()方 法只接收一个参数，即用作分隔符的字符串，然后返回包含所有数组项的字符串。 var colors = ['red','blue','green'] colors.join(&quot; | &quot;) // red | blue | green 如果数组中的某一项的值是 null 或者 undefined ， 那么该值在 join() 、 toLocaleString()、toString()和 valueOf()方法返回的结果中以空字符串表示。 5.2.3 栈方法ECMAScript 数组也提供了一种让数组的行为类似于其他数据结构的方法。具体说来，数组可以表 现得就像栈一样，后者是一种可以限制插入和删除项的数据结构。栈是一种 LIFO（Last-In-First-Out， 后进先出）的数据结构，也就是最新添加的项最早被移除。而栈中项的插入（叫做推入）和移除（叫做 弹出），只发生在一个位置——栈的顶部。ECMAScript 为数组专门提供了 push()和 pop()方法，以便 实现类似栈的行为。 push()方法可以接收任意数量的参数，把它们逐个添加到数组末尾，并返回修改后数组的长度。而 pop()方法则从数组末尾移除最后一项，减少数组的 length 值，然后返回移除的项。 var colors = new Array(); var count = colors.push(&quot;red&quot;, &quot;green&quot;); alert(count ) //2 count = colors.push(&quot;black&quot;); alert(count) //3 var item = colors.pop(); //取得最后一项 alert(item) //black alert(color.length) //2 5.2.4 队列方法由于 push()是向数组末端添加项的方法， 因此要模拟队列只需一个从数组前端取得项的方法。实现这一操作的数组方法就是 shift()，它能够移 除数组中的第一个项并返回该项，同时将数组长度减 1。结合使用 shift()和 push()方法，可以像使 用队列一样使用数组。 var color = new Array() var count = color.push('red','green') alert(count) // 2 var item = color.shift() alert(item) // red color.length //1 ECMAScript 还为数组提供了一个 unshift()方法。顾名思义，unshift()与 shift()的用途相反： 它能在数组前端添加任意个项并返回新数组的长度。因此，同时使用 unshift()和 pop()方法，可以 从相反的方向来模拟队列，即在数组的前端添加项，从数组末端移除项 5.2.5 重新排序方法 reverse() sort() reverse 反转数组 var number = [1,2,3,4,5] number.reverse() number // [5,4,3,2,1] sort方法 在默认情况下，sort()方法按升序排列数组项——即最小的值位于最前面，最大的值排在最后面。 为了实现排序，sort()方法会调用每个数组项的 toString()转型方法，然后比较得到的字符串，以 确定如何排序。即使数组中的每一项都是数值，sort()方法比较的也是字符串 var values = [0, 1, 5, 10, 15]; values.sort(); alert(values) // //0,1,10,15,5 比较函数接收两个参数，如果第一个参数应该位于第二个之前则返回一个负数，如果两个参数相等 则返回 0，如果第一个参数应该位于第二个之后则返回一个正数。 function compare(val1,val2){ if(val1 &lt; val2){ return -1 }else if(val1 &gt; val2){ return 1 }else{ return 0 } } 对于数值类型或者其 valueOf()方法会返回数值类型的对象类型，可以使用一个更简单的比较函 数。这个函数只要用第二个值减第一个值即可。 function compare(value1, value2){ return value2 - value1; } 由于比较函数通过返回一个小于零、等于零或大于零的值来影响排序结果，因此减法操作就可以适 当地处理所有这些情况。 5.2.6 操作方法ECMAScript 为操作已经包含在数组中的项提供了很多方法。其中，concat()方法可以基于当前数 组中的所有项创建一个新数组。具体来说，这个方法会先创建当前数组一个副本，然后将接收到的参数 添加到这个副本的末尾，最后返回新构建的数组。在没有给 concat()方法传递参数的情况下，它只是 复制当前数组并返回副本。如果传递给 concat()方法的是一或多个数组，则该方法会将这些数组中的 每一项都添加到结果数组中。如果传递的值不是数组，这些值就会被简单地添加到结果数组的末尾。 var colors = ['red' , 'green' ,'blue'] var colors2 = colors.concat('1',['2','3']) colors // ['red' , 'green' ,'blue'] colors2 // ['red' , 'green' ,'blue' , '1','2','3'] 下一个方法是 slice()，它能够基于当前数组中的一或多个项创建一个新数组。slice()方法可以 接受一或两个参数，即要返回项的起始和结束位置。在只有一个参数的情况下，slice()方法返回从该 参数指定位置开始到当前数组末尾的所有项。如果有两个参数，该方法返回起始和结束位置之间的项—但不包括结束位置的项。注意，slice()方法不会影响原始数组。 var colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;yellow&quot;, &quot;purple&quot;]; var colors2 = colors.slice(1); var colors3 = colors.slice(1,4); alert(colors2) // green到purple alert(colors3) // green 到yellow 下面我们来介绍 splice()方法，这个方法恐怕要算是最强大的数组方法了，它有很多种用法。 splice()的主要用途是向数组的中部插入项，但使用这种方法的方式则有如下 3 种。 删除：可以删除任意数量的项，只需指定 2 个参数：要删除的第一项的位置和要删除的项数。 例如，splice(0,2)会删除数组中的前两项。 插入：可以向指定位置插入任意数量的项，只需提供 3 个参数：起始位置、0（要删除的项数） 和要插入的项。 如果要插入多个项， 可以再传入第四、第五， 以至任意多个项。 例如， splice(2,0,”red”,”green”)会从当前数组的位置 2 开始插入字符串”red”和”green”。 替换：可以向指定位置插入任意数量的项，且同时删除任意数量的项，只需指定 3 个参数：起 始位置、要删除的项数和要插入的任意数量的项。插入的项数不必与删除的项数相等。例如， splice (2,1,”red”,”green”)会删除当前数组位置 2 的项，然后再从位置 2 开始插入字符串 “red”和”green”。 splice()方法始终都会返回一个数组，该数组中包含从原始数组中删除的项（如果没有删除任何 项，则返回一个空数组）。 5.2.7 位置方法ECMAScript 5 为数组实例添加了两个位置方法：indexOf()和 lastIndexOf()。这两个方法都接收 两个参数：要查找的项和（可选的）表示查找起点位置的索引。其中，indexOf()方法从数组的开头（位 置 0）开始向后查找，lastIndexOf()方法则从数组的末尾开始向前查找。 这两个方法都返回要查找的项在数组中的位置，或者在没找到的情况下返回1。在比较第一个参数 与数组中的每一项时，会使用全等操作符；也就是说，要求查找的项必须严格相等（就像使用===一样）。 5.2.8 迭代方法ECMAScript 5 为数组定义了 5 个迭代方法。每个方法都接收两个参数：要在每一项上运行的函数和（可选的）运行该函数的作用域对象——影响 this 的值。传入这些方法中的函数会接收三个参数：数 组项的值、该项在数组中的位置和数组对象本身。根据使用的方法不同，这个函数执行后的返回值可能 会也可能不会影响方法的返回值。 every() 用于查询数组中的项是否满足某个条件，如果全部为true则返回true，否则返回false some() 用于查询数组中的项是否满足某个条件，如果一个为true则返回true var numbers = [1,2,3,4,5,4,3,2,1]; var everyResult = numbers.every(function(item, index, array){ return (item &gt; 2); }); // false 因为有小于2的值 var someResult = numbers.some(function(item,index,array){ return (item &gt; 2) })//true 因为有大于2的值 filter()函数，它利用指定的函数确定是否在返回的数组中包含某一项。返回过滤的数组（过滤器） var numbers = [1,2,3,4,5,4,3,2,1]; var filterResult = numbers.filter(function(item,index,array){ return item &gt; 2 }) filterResult // [3,4,5,4,3] map()也返回一个数组，而这个数组的每一项都是在原始数组中的对应项上运行传入函数的结果。(遍历并返回数组) var numbers = [1,2,3,4,5,4,3,2,1]; var mapResult = numbers.map(function(item,index,array){ return item * 2 }) mapResult // [2,3,6,8,10,8,6,4,2] forEach()，它只是对数组中的每一项运行传入的函数。 //简单复制数组 var numbers = [1,2,3,4,5,4,3,2,1] var newGroup = [] numbers.forEach(function(item,index,array){ newGroup.push(item) }) newGroup //[1,2,3,4,5,4,3,2,1] 5.2.9 归并方法ECMAScript 5 还新增了两个归并数组的方法：reduce()和 reduceRight()。这两个方法都会迭 代数组的所有项，然后构建一个最终返回的值。其中，reduce()方法从数组的第一项开始，逐个遍历 到最后。而 reduceRight()则从数组的最后一项开始，向前遍历到第一项。 reduce()和 reduceRight()的函数接收 4 个参数：前一个值、当前值、项的索引和数组对象。 这 个函数返回的任何值都会作为第一个参数自动传给下一项。第一次迭代发生在数组的第二项上，因此第 一个参数是数组的第一项，第二个参数就是数组的第二项。 var numbers = [1,2,3,4,5] var sum = numbers.reduce(function(pre,cur,index,array){ return pre + cur }) sum //15 第一次执行回调函数，prev 是 1，cur 是 2。第二次，prev 是 3（1 加 2 的结果），cur 是 3（数组 的第三项）。这个过程会持续到把数组中的每一项都访问一遍，最后返回结果。 reduceRight()的作用类似，只不过方向相反而已。 var values = [1,2,3,4,5]; var sum = values.reduceRight(function(prev, cur, index, array){ return prev + cur; }); alert(sum); //15 5.3 Date类型ECMAScript 中的 Date 类型是在早期 Java 中的 java.util.Date 类基础上构建的。为此，Date 类型使用自 UTC（Coordinated Universal Time，国际协调时间）1970 年 1 月 1 日午夜（零时）开始经过 的毫秒数来保存日期。 在使用这种数据存储格式的条件下，Date 类型保存的日期能够精确到 1970 年 1 月 1 日之前或之后的 285 616 年。 创建日期对象 var time = new Date() 在调用 Date 构造函数而不传递参数的情况下，新创建的对象自动获得当前日期和时间。如果想根 据特定的日期和时间创建日期对象，必须传入表示该日期的毫秒数（即从 UTC 时间 1970 年 1 月 1 日午 夜起至该日期止经过的毫秒数）。为了简化这一计算过程，ECMAScript 提供了两个方法：Date.parse() 和 Date.UTC()。 Date.parse() 接受一个日期字符串，反馈一个相应日期的毫秒数 var ms = Date.parse('1993-09-28') var birthDay = new Date(ms) birthDay //Tue Sep 28 1993 08:00:00 GMT+0800 (中国标准时间) //与下面类似 var birthDay = new Date('1993-09-28') ECMA-262 没有定义 Date.parse()应该支持哪种日期格式，因此这个方法的行为因实现 而异，而且通常是因地区而异。 Date.UTC()方法同样也返回表示日期的毫秒数，但它与 Date.parse()在构建值时使用不同的信息。 Date.UTC()的参数分别是年份、基于 0 的月份（一月是 0，二月是 1，以此类推）、月 （1 到 31）、小时数（0 到 23）、分钟、秒以及毫秒数。 在这些参数中，只有前两个参数（年和月）是必 需的。如果没有提供月中的天数，则假设天数为 1；如果省略其他参数，则统统假设为 0。 // GMT 时间 2000 年 1 月 1 日午夜零时 var y2k = new Date(Date.UTC(2000, 0)); //类似于 var y2k = new Date(2000, 0); // GMT 时间 2005 年 5 月 5 日下午 5:55:55 var allFives = new Date(Date.UTC(2005, 4, 5, 17, 55, 55)); //类似于 var allFives = new Date(2005, 4, 5, 17, 55, 55); ECMAScript 5 添加了 Data.now()方法，返回表示调用这个方法时的日期和时间的毫秒数。这个方 法简化了使用 Data 对象分析代码的工作。 var start = Date.now() dosomething() var stop = Date.now() //可以用以下替换 var start = +new Date() //+号替换成字符串 调用new Date().valueOf() dosomething() var stop = +new Date() 5.3.2 📅日期格式化 toDateString()——以特定于实现的格式显示星期几、月、日和年； toTimeString()——以特定于实现的格式显示时、分、秒和时区； toLocaleDateString()——以特定于地区的格式显示星期几、月、日和年； toLocaleTimeString()——以特定于实现的格式显示时、分、秒； toUTCString()——以特定于实现的格式完整的 UTC 日期。 ECMAScript 推荐现在编写的代码一律使用 toUTCString()方法。 5.4 RegExp 类型ECMAScript 通过 RegExp 类型来支持正则表达式。使用下面类似 Perl 的语法，就可以创建一个正 则表达式。 var expression = / pattern / flags ; 其中的模式（pattern）部分可以是任何简单或复杂的正则表达式，可以包含字符类、限定符、分组、 向前查找以及反向引用。每个正则表达式都可带有一或多个标志（flags），用以标明正则表达式的行为。 正则表达式的匹配模式支持下列 3 个标志。 g：表示全局（global）模式，即模式将被应用于所有字符串，而非在发现第一个匹配项时立即 停止； i：表示不区分大小写（case-insensitive）模式，即在确定匹配项时忽略模式与字符串的大小写； m：表示多行（multiline）模式，即在到达一行文本末尾时还会继续查找下一行中是否存在与模 式匹配的项。 一个正则表达式就是一个模式与上述 3 个标志的组合体。不同组合产生不同结果。 /* * 匹配字符串中所有&quot;at&quot;的实例 */ var pattern1 = /at/g; /* * 匹配第一个&quot;bat&quot;或&quot;cat&quot;，不区分大小写 */ var pattern2 = /[bc]at/i; /* * 匹配所有以&quot;at&quot;结尾的 3 个字符的组合，不区分大小写 */ var pattern3 = /.at/gi; 前面举的这些例子都是以字面量形式来定义的正则表达式。另一种创建正则表达式的方式是使用 RegExp 构造函数，它接收两个参数：一个是要匹配的字符串模式，另一个是可选的标志字符串。可以 使用字面量定义的任何表达式，都可以使用构造函数来定义， /* * 匹配第一个&quot;bat&quot;或&quot;cat&quot;，不区分大小写 */ var pattern1 = /[bc]at/i; //使用构造函数创建正则表达式 var pattern1 = new RegExp(&quot;[bc]at&quot;,&quot;i&quot;) 5.4.1 RegExp实例属性RegExp 的每个实例都具有下列属性，通过这些属性可以取得有关模式的各种信息 global：布尔值，表示是否设置了 g 标志 ignoreCase：布尔值，表示是否设置了 i 标志。 lastIndex：整数，表示开始搜索下一个匹配项的字符位置，从 0 算起。 multiline：布尔值，表示是否设置了 m 标志 source：正则表达式的字符串表示，按照字面量形式而非传入构造函数中的字符串模式返回。 5.5 Function 类型说起来 ECMAScript 中什么最有意思，我想那莫过于函数了——而有意思的根源，则在于函数实际 上是对象。每个函数都是 Function 类型的实例，而且都与其他引用类型一样具有属性和方法。由于函 数是对象，因此函数名实际上也是一个指向函数对象的指针，不会与某个函数绑定。函数通常是使用函 数声明语法定义的 函数的三种创建方式： //函数声明 function sum(num1,num2){ return num1 + num2 } //函数表达式 var sum = function(num1,num2){ return num1 + num2 } //Function 构造函数生成 var sum = new Function('num1','num2','return num1 + num2') function sum(num1, num2){ return num1 + num2; } alert(sum(10,10));//20 var anotherSum = sum; alert(anotherSum(10,10)); //20 sum = null; alert(anotherSum(10,10)); //20 以上代码首先定义了一个名为 sum()的函数，用于求两个值的和。然后，又声明了变量 anotherSum， 并将其设置为与 sum 相等（将 sum 的值赋给 anotherSum）。注意，使用不带圆括号的函数名是访问函 数指针，而非调用函数。此时，anotherSum 和 sum 就都指向了同一个函数，因此 anotherSum()也 可以被调用并返回结果。即使将 sum 设置为 null，让它与函数“断绝关系”，但仍然可以正常调用 anotherSum()。 5.5.1 没有重载（深入理解）将函数名想象为指针，也有助于理解为什么 ECMAScript 中没有函数重载的概念。（重复声明的函数会被覆盖） function addSomeNum(num){ return num + 100 } function addSomeNum(num){ return num + 200 } addSomeNum(100) //300 函数被覆盖。函数表达式也是如此。 5.5.2 函数声明与函数表达式本节到目前为止，我们一直没有对函数声明和函数表达式加以区别。而实际上，解析器在向执行环 境中加载数据时，对函数声明和函数表达式并非一视同仁。解析器会率先读取函数声明，并使其在执行 任何代码之前可用（可以访问）；至于函数表达式，则必须等到解析器执行到它所在的代码行，才会真 正被解释执行。 alert(sum(10,10)); function sum(num1, num2){ return num1 + num2; } 上述代码可以运行。因为在代码开始执行之前，解析器就已经通过一个名为函数声明提升 （function declaration hoisting）的过程，读取并将函数声明添加到执行环境中。对代码求值时，JavaScript 引擎在第一遍会声明函数并将它们放到源代码树的顶部。所以，即使声明函数的代码在调用它的代码后 面，JavaScript 引擎也能把函数声明提升到顶部。 如果改变为函数表达式则会出现错误 alert(sum(10,10)) var sum = function(num1,num2){ return num1 + num2 } 原因在于函数位于一个初始化语句中，而不是一个函数声 明。换句话说，在执行到函数所在的语句之前，变量 sum 中不会保存有对函数的引用；而且，由于第一 行代码就会导致“unexpected identifier”（意外标识符）错误，实际上也不会执行到下一行。 5.5.3 作为值的函数因为 ECMAScript 中的函数名本身就是变量，所以函数也可以作为值来使用。也就是说，不仅可以 像传递参数一样把一个函数传递给另一个函数，而且可以将一个函数作为另一个函数的结果返回。 function execFunction(fn,params){ return fn(params) } function addSomeNum(num){ return num + 10 } execFunction(addSomeNum,10) //20 当然，可以从一个函数中返回另一个函数，而且这也是极为有用的一种技术。例如，假设有一个 对象数组，我们想要根据某个对象属性对数组进行排序。而传递给数组 sort()方法的比较函数要接收 两个参数，即要比较的值。可是，我们需要一种方式来指明按照哪个属性来排序。要解决这个问题， 可以定义一个函数，它接收一个属性名，然后根据这个属性名来创建一个比较函数，下面就是这个函 数的定义。 function compare(objectName){ return function(obj1,obj2){ var val1 = obj1[objectName] var val2 = obj2[objectName] if(val1 &gt; val2){ return -1 }else if(val1 &lt; val2){ return 1 }else{ return 0 } } } //实例 var data = [{name: &quot;Zachary&quot;, age: 28}, {name: &quot;Nicholas&quot;, age: 29}]; data.sort(compare(&quot;name&quot;)); alert(data[0].name); //Nicholas data.sort(compare(&quot;age&quot;)); alert(data[0].name); //Zachary 5.5.4 函数内部属性在函数内部，有两个特殊的对象：arguments 和 this。其中，arguments 在第 3 章曾经介绍过， 它是一个类数组对象，包含着传入函数中的所有参数。虽然 arguments 的主要用途是保存函数参数， 但这个对象还有一个名叫 callee 的属性，该属性是一个指针，指向拥有这个 arguments 对象的函数。 function factorial(num){ if (num &lt;=1) { return 1; } else { return num * factorial(num-1) } } 定义阶乘函数一般都要用到递归算法；如上面的代码所示，在函数有名字，而且名字以后也不会变 的情况下，这样定义没有问题。但问题是这个函数的执行与函数名 factorial 紧紧耦合在了一起。为 了消除这种紧密耦合的现象，可以像下面这样使用 arguments.callee。 function factorial(num){ if (num &lt;=1) { return 1; } else { return num * arguments.callee(num-1) } } 在这个重写后的 factorial()函数的函数体内，没有再引用函数名 factorial。这样，无论引用 函数时使用的是什么名字，都可以保证正常完成递归调用。 var trueFactorial = factorial; factorial = function(){ return 0; }; alert(trueFactorial(5)); //120 alert(factorial(5));//0 函数内部的另一个特殊对象是 this，其行为与 Java 和 C#中的 this 大致类似。换句话说，this 引用的是函数据以执行的环境对象——或者也可以说是 this 值（当在网页的全局作用域中调用函数时， this 对象引用的就是 window）。 window.color = 'red' var o = { color : &quot;blue&quot; } function sayColor(){ return this.color } sayColor() // red o.sayColor = sayColor o.sayColor() // blue 上面这个函数 sayColor()是在全局作用域中定义的，它引用了 this 对象。由于在调用函数之前， this 的值并不确定，因此 this 可能会在代码执行过程中引用不同的对象。当在全局作用域中调用 sayColor() 时， this 引用的是全局对象 window ；换句话说， 对 this.color 求值会转换成对 window.color 求值，于是结果就返回了”red”。而当把这个函数赋给对象 o 并调用 o.sayColor() 时，this 引用的是对象 o，因此对 this.color 求值会转换成对 o.color 求值，结果就返回了”blue”。 caller属性。这个属性保存着当前函数的引用对象（是谁来调用这个函数） function myFunc(){ if(arguments.callee.caller == 'null'){ console.log(&quot;调用我的人是全局环境&quot;) }else{ console.log(&quot;调用我的人是&quot; + arguments.callee.caller) } } myFunc() // 调用我的人是全局环境 function test(){ return myFunc() } test() // 调用我的人是test 打印test函数 5.5.5 函数属性和方法ECMAScript 中的函数是对象，因此函数也有属性和方法。每个函数都包含两个 属性：length 和 prototype。其中，length 属性表示函数希望接收的命名参数的个数 function sayName(name){ alert(name); } function sum(num1, num2){ return num1 + num2; } function sayHi(){ alert(&quot;hi&quot;); } alert(sayName.length); //1 alert(sum.length); //2 alert(sayHi.length); //0 在 ECMAScript 核心所定义的全部属性中， 最耐人寻味的就要数 prototype 属性了。 对于 ECMAScript 中的引用类型而言，prototype 是保存它们所有实例方法的真正所在。换句话说，诸如 toString()和 valueOf()等方法实际上都保存在 prototype 名下，只不过是通过各自对象的实例访 问罢了。在创建自定义引用类型以及实现继承时，prototype 属性的作用是极为重要的（第 6 章将详 细介绍）。在 ECMAScript 5 中，prototype 属性是不可枚举的，因此使用 for-in 无法发现。 每个函数都包含两个非继承而来的方法：apply()和 call()。这两个方法的用途都是在特定的作 用域中调用函数，实际上等于设置函数体内 this 对象的值。首先，apply()方法接收两个参数：一个 是在其中运行函数的作用域，另一个是参数数组。其中，第二个参数可以是 Array 的实例，也可以是 arguments 对象。 function sum(num1,num2){ return num1 + num2 } function sumCall(num1,num2){ return sum.call(this,[num1,num2]) } function sumCall2(num1,num2){ return sum.call(this,arguments) } sumCall(10,10) //20 sumCall2(10,10) //20 call()方法与 apply()方法的作用相同，它们的区别仅在于接收参数的方式不同。对于 call() 方法而言，第一个参数是 this 值没有变化，变化的是其余参数都直接传递给函数。换句话说，在使用 call()方法时，传递给函数的参数必须逐个列举出来 事实上，传递参数并非 apply()和 call()真正的用武之地；它们真正强大的地方是能够扩充函数 赖以运行的作用域。 window.color = 'red' var o = { color: 'blue' } function sayColor(){ return this.color } sayColor() // red sayColor.call(window) //red sayColor.call(o) //blue 而 sayColor.call(this)和 sayColor.call(window)，则是两 种显式地在全局作用域中调用函数的方式，结果当然都会显示”red”。但是，当运行 sayColor.call(o) 时，函数的执行环境就不一样了，因为此时函数体内的 this 对象指向了 o，于是结果显示的是”blue”。 使用 call()（或 apply()）来扩充作用域的最大好处，就是对象不需要与方法有任何耦合关系。 在前面例子的第一个版本中，我们是先将 sayColor()函数放到了对象 o 中，然后再通过 o 来调用它的； 而在这里重写的例子中，就不需要先前那个多余的步骤了。 //bind window.color = 'red' var o = { color: 'blue' } function sayColor(){ return this.color } var objectBind = sayColor.bind(o) objectBind() // blue 5.6 基本包装类型为了便于操作基本类型值， ECMAScript 还提供了 3 个特殊的引用类型：Boolean、Number 和 String。这些类型与本章介绍的其他引用类型相似，但同时也具有与各自的基本类型相应的特殊行为。 实际上，每当读取一个基本类型值的时候，后台就会创建一个对应的基本包装类型的对象，从而让我们 能够调用一些方法来操作这些数据。 var s1 = &quot;some text&quot;; var s2 = s1.substring(2); 这个例子中的变量 s1 包含一个字符串， 字符串当然是基本类型值。 而下一行调用了 s1 的 substring()方法，并将返回的结果保存在了 s2 中。我们知道，基本类型值不是对象，因而从逻辑上 讲它们不应该有方法（尽管如我们所愿，它们确实有方法）。其实，为了让我们实现这种直观的操作， 后台已经自动完成了一系列的处理。当第二行代码访问 s1 时，访问过程处于一种读取模式，也就是要 从内存中读取这个字符串的值。而在读取模式中访问字符串时，后台都会自动完成下列处理。 创建 String 类型的一个实例； 在实例上调用指定的方法； 销毁这个实例。 引用类型与基本包装类型的主要区别就是对象的生存期。使用 new 操作符创建的引用类型的实例， 在执行流离开当前作用域之前都一直保存在内存中。而自动创建的基本包装类型的对象，则只存在于一 行代码的执行瞬间，然后立即被销毁。这意味着我们不能在运行时为基本类型值添加属性和方法。 5.6.1 Boolean类型Boolean 类型是与布尔值对应的引用类型。要创建 Boolean 对象，可以像下面这样调用 Boolean 构造函数并传入 true 或 false 值。 var booleanObject = new Boolean(true); Boolean 类型的实例重写了 valueOf()方法，返回基本类型值 true 或 false；重写了 toString() 方法，返回字符串”true”和”false”。可是，Boolean 对象在 ECMAScript 中的用处不大，因为它经 常会造成人们的误解。其中最常见的问题就是在布尔表达式中使用 Boolean 对象 var falseObj = new Boolean(false) var result = falseObj &amp;&amp; true result // true 此时falseObj没有进行求值 仅仅是把falseObj当成一个 obj对象 var falseValue = false; result = falseValue &amp;&amp; true; alert(result); //false 基本类型与引用类型的布尔值还有两个区别。首先，typeof 操作符对基本类型返回”boolean”， 而对引用类型返回”object”。其次，由于 Boolean 对象是 Boolean 类型的实例，所以使用 instanceof 操作符测试 Boolean 对象会返回 true，而测试基本类型的布尔值则返回 false。 5.6.2 Number类型Number 是与数字值对应的引用类型。要创建 Number 对象，可以在调用 Number 构造函数时向其 中传递相应的数值。 var num = new Number(10) 与 Boolean 类型一样，Number 类型也重写了 valueOf()、toLocaleString()和 toString() 方法。重写后的 valueOf()方法返回对象表示的基本类型的数值，另外两个方法则返回字符串形式的数值。我们在第 3 章还介绍过，可以为 toString()方法传递一个表示基数的参数，告诉它返回几进制 数值的字符串形式，如下面的例子所示。 var num = 10 alert(num.toString()); // 10 alert(num.toString(2)); // 1010 alert(num.toString(8)); //12 alert(num.toString(10)); //10 alert(num.toString(16)); //a 除了继承的方法之外，Number 类型还提供了一些用于将数值格式化为字符串的方法。 其中，toFixed()方法会按照指定的小数位返回数值的字符串表示 var num = new Number(10) num.toFixed(2) // 10.00 var a = 10.005 a.toFixed(2) // 10.01 5.6.3 String 类型String 类型是字符串的对象包装类型，可以像下面这样使用 String 构造函数来创建。 var str = new String('hello world') String 对象的方法也可以在所有基本的字符串值中访问到。其中，继承的 valueOf()、toLocaleString()和 toString()方法，都返回对象所表示的基本字符串值。 String 类型的每个实例都有一个 length 属性，表示字符串中包含多个字符。 var str = 'hello world' str.length // 11 String 类型提供了很多方法，用于辅助完成对 ECMAScript 中字符串的解析和操作。 字符方法 两个用于访问字符串中特定字符的方法是：charAt()和 charCodeAt()。这两个方法都接收一个 参数，即基于 0 的字符位置。其中，charAt()方法以单字符字符串的形式返回给定位置的那个字符 （ECMAScript 中没有字符类型）。 var str = 'hello world' str.charAt(1) // e str.charCodeAt(1) // 101 输出的是&quot;101&quot;，也就是小写字母&quot;e&quot;的字符编码 ECMAScript 5 还定义了另一个访问个别字符的方法。在支持此方法的浏览器中，可以使用方括号加数 字索引来访问字符串中的特定字符 var str = 'hello world' str[1] // e 字符串操作方法 concat() 拼接字符串,返回一个新字符串 var str = 'hello ' var result = str.concat('world') result // hello world str // hello concat()方法可以接受任意多个参数，也就是说可以通过它 拼接任意多个字符串。 var str = 'hello ' var result = str.concat('world','~') result // hello world~ ECMAScript 还提供了三个基于子字符串创建新字符串的方法：slice()、substr()和 substring()。 这三个方法都会返回被操作字符串的一个子字符串，而且也都接受一或两个参数。 var str = 'hello world' str.slice(3) // lo world str.substr(3) // lo world str.substring(3)// lo world str.slice(3,7) // lo w str.substr(3,7) //lo worl str.substring(3,7) //lo w 在传递给这些方法的参数是负值的情况下，它们的行为就不尽相同了。其中，slice()方法会将传 入的负值与字符串的长度相加，substr()方法将负的第一个参数加上字符串的长度，而将负的第二个 参数转换为 0。最后，substring()方法会把所有负值参数都转换为 0。 字符串位置方法 有两个可以从字符串中查找子字符串的方法：indexOf()和 lastIndexOf()。这两个方法都是从 一个字符串中搜索给定的子字符串，然后返子字符串的位置（如果没有找到该子字符串，则返回-1）。 这两个方法的区别在于：indexOf()方法从字符串的开头向后搜索子字符串，而 lastIndexOf()方法 是从字符串的末尾向前搜索子字符串。 var stringValue = &quot;hello world&quot;; alert(stringValue.indexOf(&quot;o&quot;)); //4 alert(stringValue.lastIndexOf(&quot;o&quot;)); // 7 这两个方法都可以接收可选的第二个参数， 表示从字符串中的哪个位置开始搜索。 换句话说， indexOf()会从该参数指定的位置向后搜索，忽略该位置之前的所有字符；而 lastIndexOf()则会从 指定的位置向前搜索，忽略该位置之后的所有字符。 var stringValue = &quot;hello world&quot;; alert(stringValue.indexOf(&quot;o&quot;, 6)); //7 alert(stringValue.lastIndexOf(&quot;o&quot;, 6)); //4 trim()方法 ECMAScript 5 为所有字符串定义了 trim()方法。这个方法会创建一个字符串的副本，删除前置及 后缀的所有空格，然后返回结果。 var str = ' hello world ' var newStr = str.trim() newStr // hello wold 去除了两端空格 str // hello world 原字符串 字符串大小写转换方法 toLowerCase() 全部转换为小写 toUpperCase() 全部转换为大写 返回一个新的字符串 var str = 'hello world' var newStr = str.toUpperCase() //HELLO WORLD 字符串的模式匹配方法 String 类型定义了几个用于在字符串中匹配模式的方法。第一个方法就是 match()，在字符串上 调用这个方法，本质上与调用 RegExp 的exec()方法相同。match()方法只接受一个参数，要么是一 个正则表达式，要么是一个 RegExp 对象。 var text = &quot;cat, bat, sat, fat&quot;; var pattern = /.at/; var matches = text.match(pattern); alert(matches.index); // 0 alert(matches[0]); //cat alert(pattern.lastIndex); //0 另一个用于查找模式的方法是 search()。这个方法的唯一参数与 match()方法的参数相同：由字 符串或 RegExp 对象指定的一个正则表达式。search()方法返回字符串中第一个匹配项的索引；如果没 有找到匹配项，则返回-1。而且，search()方法始终是从字符串开头向后查找模式。 var text = &quot;cat, bat, sat, fat&quot;; var pos = text.search(/at/) pos // 1 这个例子中的 search()方法返回 1，即”at”在字符串中第一次出现的位置。 为了简化替换子字符串的操作，ECMAScript 提供了 replace()方法。这个方法接受两个参数：第 一个参数可以是一个 RegExp 对象或者一个字符串（这个字符串不会被转换成正则表达式），第二个参 数可以是一个字符串或者一个函数。如果第一个参数是字符串，那么只会替换第一个子字符串。要想替 换所有子字符串，唯一的办法就是提供一个正则表达式，而且要指定全局（g）标志 var text = &quot;cat, bat, sat, fat&quot;; text.replace(/at/g,'on') text // con,bon,son,fon 最后一个与模式匹配有关的方法是 split()，这个方法可以基于指定的分隔符将一个字符串分割成 多个子字符串，并将结果放在一个数组中。分隔符可以是字符串，也可以是一个 RegExp 对象（这个方 法不会将字符串看成正则表达式）。split()方法可以接受可选的第二个参数，用于指定数组的大小， 以便确保返回的数组不会超过既定大小。 var colorText = &quot;red,blue,green,yellow&quot;; var colors1 = colorText.split(&quot;,&quot;); //[&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;yellow&quot;] var colors2 = colorText.split(&quot;,&quot;, 2); //[&quot;red&quot;, &quot;blue&quot;] localeCompare()方法 fromCharCode()方法 有需要再看 5.7 单体内置对象单体内置对象：Global 和 Math。 5.7.1 Global对象Global（全局）对象可以说是 ECMAScript 中最特别的一个对象了，因为不管你从什么角度上看， 这个对象都是不存在的。ECMAScript 中的 Global 对象在某种意义上是作为一个终极的“兜底儿对象” 来定义的。换句话说，不属于任何其他对象的属性和方法，最终都是它的属性和方法。事实上，没有全 局变量或全局函数；所有在全局作用域中定义的属性和函数，都是 Global 对象的属性。本书前面介绍 过的那些函数，诸如 isNaN()、isFinite()、parseInt()以及 parseFloat()，实际上全都是 Global 对象的方法。除此之外，Global 对象还包含其他一些方法。 URI 编码方法 Global 对象的 encodeURI() 和 encodeURIComponent() 方法可以对 URI（Uniform Resource Identifiers，通用资源标识符）进行编码，以便发送给浏览器。有效的 URI 中不能包含某些字符，例如 空格。而这两个 URI 编码方法就可以对 URI 进行编码，它们用特殊的 UTF-8 编码替换所有无效的字符， 从而让浏览器能够接受和理解。 其中，encodeURI()主要用于整个 URI（例如，http://www.wrox.com/illegal value.htm），而 encodeURIComponent()主要用于对 URI 中的某一段（例如前面 URI 中的 illegal value.htm）进行编码。 它们的主要区别在于，encodeURI()不会对本身属于 URI 的特殊字符进行编码，例如冒号、正斜杠、 问号和井字号；而 encodeURIComponent()则会对它发现的任何非标准字符进行编码。 var uri = &quot;http://www.wrox.com/illegal value.htm#start&quot;; alert(encodeURI(uri)); //&quot;http://www.wrox.com/illegal%20value.htm#start&quot; alert(encodeURIComponent(uri)); // //&quot;http%3A%2F%2Fwww.wrox.com%2Fillegal%20value.htm%23start&quot; 使用 encodeURI() 编码后的结果是除了空格之外的其他字符都原封不动， 只有空格被替换成了 %20。而 encodeURIComponent()方法则会使用对应的编码替换所有非字母数字字符。这也正是可以 对整个 URI 使用 encodeURI()，而只能对附加在现有 URI 后面的字符串使用 encodeURIComponent() 的原因所在。 与 encodeURI() 和 encodeURIComponent() 方法对应的两个方法分别是 decodeURI() 和 decodeURIComponent()。其中，decodeURI()只能对使用 encodeURI()替换的字符进行解码。例如， 它可将%20 替换成一个空格，但不会对%23 作任何处理，因为%23 表示井字号（#），而井字号不是使用 encodeURI()替换的。同样地，decodeURIComponent()能够解码使用 encodeURIComponent()编码的所有字符，即它可以解码任何特殊字符的编码。 eval()方法 现在，我们介绍最后一个——大概也是整个 ECMAScript 语言中最强大的一个方法：eval()。eval() 方法就像是一个完整的 ECMAScript 解析器，它只接受一个参数，即要执行的 ECMAScript（或 JavaScript） 字符串。 eval('alert('hi')')等同于alert('hi') 当解析器发现代码中调用 eval()方法时，它会将传入的参数当作实际的 ECMAScript 语句来解析， 然后把执行结果插入到原位置。通过 eval()执行的代码被认为是包含该次调用的执行环境的一部分， 因此被执行的代码具有与该执行环境相同的作用域链。这意味着通过 eval()执行的代码可以引用在包 含环境中定义的变量 var msg = &quot;hello world&quot;; eval('alert(msg)') //hello world 可见，变量 msg 是在 eval()调用的环境之外定义的，但其中调用的 alert()仍然能够显示”hello world”。这是因为上面第二行代码最终被替换成了一行真正的代码。同样地，我们也可以在 eval() 调用中定义一个函数，然后再在该调用的外部代码中引用这个函数： eval(&quot;function sayHi() { alert('hi'); }&quot;); sayHi(); 在 eval()中创建的任何变量或函数都不会被提升，因为在解析代码的时候，它们被包含在一个字 符串中；它们只在 eval()执行的时候创建。 Global 对象的属性 Global 对象还包含一些属性， 其中一部分属性已经在本书前面介绍过了。 例如， 特殊的值 undefined、NaN 以及 Infinity 都是 Global 对象的属性。此外，所有原生引用类型的构造函数，像 Object 和 Function，也都是 Global 对象的属性。下表列出了 Global 对象的所有属性。 window 对象 ECMAScript 虽然没有指出如何直接访问 Global 对象，但 Web 浏览器都是将这个全局对象作为 window 对象的一部分加以实现的。因此，在全局作用域中声明的所有变量和函数，就都成为了 window 对象的属性。 取得全局对象的方法 var global = function(){ return this }() 5.7.2 Math对象ECMAScript 还为保存数学公式和信息提供了一个公共位置，即 Math 对象。与我们在 JavaScript 直 接编写的计算功能相比，Math 对象提供的计算功能执行起来要快得多。Math 对象中还提供了辅助完成 这些计算的属性和方法。 Math 对象的属性 Math.E 自然对数的底数 min()和max()方法 Math 对象还包含许多方法，用于辅助完成简单和复杂的数学计算。 var max = Math.max(3, 54, 32, 16); //54 var min = Math.min(3, 54, 32, 16); //3 要找到数组中的最大或最小值，可以像下面这样使用 apply()方法。 var values = [1, 2, 3, 4, 5, 6, 7, 8]; var max = Math.max.apply(Math,values) //这个技巧的关键是把 Math 对象作为 apply()的第一个参数，从而正确地设置 this 值。然后，可 以将任何数组作为第二个参数。 舍入方法 Math.ceil() 执行向上舍入，即它总是将数值向上舍入为最接近的整数； Math.floor()执行向下舍入，即它总是将数值向下舍入为最接近的整数； Math.round() 执行标准舍入，即它总是将数值四舍五 上学到的舍入规则）。 random()方法 Math.random()方法返回大于等于 0 小于 1 的一个随机数。对于某些站点来说，这个方法非常实用， 12 因为可以利用它来随机显示一些名人名言和新闻事件。套用下面的公式，就可以利用 Math.random() 从某个整数范围内随机选择一个值。 值 = Math.floor(Math.random() * 可能值的总数 + 第一个可能的值)","link":"/passages/%E3%80%90JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%91%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/"},{"title":"【JS高级程序设计】第三章 基本概念","text":"3.1语法 区分大小写 不能使用关键字/保留字 统一的命名规则 第一个字符必须是一个字母、下划线（_）或一个美元符号（$）； 其他字符可以是字母、下划线、美元符号或数字。 标识符中的字母也可以包含扩展的 ASCII 或 Unicode 字母字符（如 À 和 Æ），但我们不推荐这样做。 ECMAScript 标识符采用驼峰大小写格式： firstSecond myCar doSomethingImportant 虽然没有谁强制要求必须采用这种格式，但为了与 ECMAScript 内置的函数和对象命名格式保持一 致，可以将其当作一种最佳实践。 注释：单行/多行注释 // or /* */ ECMAScript5 提出严格模式：’use strict’ , 也可在函数内部执行 语句：推荐语句用分号结束 变量： //创建局部变量 function test(){ var msg = '1' } alert(msg) //抛出错误 //创建全局变量 function test(){ msg = '1' } alert(msg) // 1 3.4数据类型 5种简单类型：Undefined、Null、Number、String、Boolean 一种复杂类型：Object 3.4.1 typeof操作符typeof负责检测数据类型，以下为数据检测返回值： “undefined” // 如果这个值未定义 “object” //如果这个值为对象或者Null “number” //如果这个值为数值 “string” //如果这个值为字符串 “boolean” //如果这个值为true/false “function” // 如果这个值为函数 typeof(msg) 注意， typeof 是一个操作符而不是函数，因此例子中的圆括号尽管可以使用，但不是必需的 3.4.2 Undefined类型 undefined 只有一个值就是undefined，在var进行声明未进行赋值的情况下，返回undefined。 var msg ; // 等价与var msg = undefined alert( msg === undefined) //true alert(age) //产生错误 用typeof检测数据类型时，已定义和未定义的都返回undefined var msg; console.log(msg) //undefined console.log(age) //undefined 3.4.3 Null类型 Null 类型是第二个只有一个值的数据类型，这个特殊的值是 null。从逻辑角度来看，null 值表 示一个空对象指针，而这也正是使用 typeof 操作符检测 null 值时会返回”object”的原因 Null类型只有一个值就是null，null对象表示一个空对象指针，在定义一个位置obj的时候就可以使用null进行预定义 var person = null; console.log(typeof person ) //object 通常用来定义一个空对象 实际上，undefined 值是派生自 null 值的，因此 ECMA-262 规定对它们的相等性测试要返回 true： null == undefined //实际上进行了转换 Boolean(null) == Boolean(undefined) //true null常用在初始化一个对象 只要意在保存对象的变量还没有真正保存对象，就应该明确地让该变量保存 null 值。这样做不仅可以 体现 null 作为空对象指针的惯例，而且也有助于进一步区分 null 和 undefined。 3.4.4 Boolean类型值：true / false 区分大小写 所有类型都有一个boolean 的值，转换方式： var msg = 'hello world' var msgBoolean = Boolean(msg) 所有值转换列表： 数据类型 转换为true的值 数量 Boolean true 5 String 任何非空字符串 “” /空字符串 Number 任何非零数字值（包括无穷大） 0和NaN Object 任何对象 null Undefined n/a（not applicable 的缩写“不适用”） undefined 3.4.5 Number类型 浮点数值 由于保存浮点数值需要的内存空间是保存整数值的两倍，因此 ECMAScript 会不失时机地将浮点数值 转换为整数值。显然，如果小数点后面没有跟任何数字，那么这个数值就可以作为整数值来保存。同样 地，如果浮点数值本身表示的就是一个整数（如 1.0），那么该值也会被转换为整数，如下面的例子所示： var floatNum1 = 1.; var floatNum2 = 10.0; // 小数点后面没有数字——解析为 1 // 整数——解析为 10 //指数幂计数法： var count = 3.159e4 //31590 //在默认情况下，ECMASctipt 会将那些小数点后面带有 6个 零以上的浮点数值转换为以 e 表示法表示的数值（例如，0.0000003 会被转换成 3e7）。 console.log(0.1+0.2) //结果为 0.30000000000000004 //永远不要做浮点数相加判断 数值范围 ECMAScript 能够表示的最小数值保 存在 Number.MIN_VALUE 中——在大多数浏览器中，这个值是 5e-324；能够表示的最大数值保存在 Number.MAX_VALUE 中——在大多数浏览器中，这个值是 1.7976931348623157e+308。如果某次计算的 结果得到了一个超出 JavaScript 数值范围的值，那么这个数值将被自动转换成特殊的 Infinity 值。具 体来说，如果这个数值是负数，则会被转换成-Infinity（负无穷），如果这个数值是正数，则会被转 换成 Infinity（正无穷）, 。要想确定一个数值是不是有穷的（换句话说，是不是位于最 小和最大的数值之间），可以使用 isFinite()函数。这个函数在参数位于最小与最大数值之间时会返 回 true，如下面的例子所示： var result = Number.MAX_VALUE + Number.MAX_VALUE; alert(isFinite(result)); //超出范围false NaN 任何涉及NaN的操作都会返回NaN，NaN与自己不相等 检测一个值是否为NaN的函数： isNaN(); 任何涉及 NaN 的操作（例如 NaN/10）都会返回 NaN， 0 / 0 // NaN 8 / 0 //Infinity //使用isNaN()检测是否不是数值 console.log(isNaN(true)) // boolean true自动转换为1,是数字返回false alert(isNaN(NaN));//true alert(isNaN(10));//false（10 是一个数值） alert(isNaN(&quot;10&quot;));//false（可以被转换成数值 10） alert(isNaN(&quot;blue&quot;));//true（不能转换成数值） 数值转换 Number()函数 可转换所有类型 如果是boolean true -&gt;1 / false -&gt;0 数字，简单传入传出 null -&gt; 0 undefined -&gt; NaN（不是数字） 如果字符串中只包含数字（包括前面带正号或负号的情况），则将其转换为十进制数值，即”1” 会变成 1，”123”会变成 123，而”011”会变成 11（注意：前导的零被忽略了） 如果字符串中包含有效的浮点格式，如”1.1”，则将其转换为对应的浮点数值（同样，也会忽 略前导零）； 如果字符串中包含有效的十六进制格式， 例如 “0xf” ， 则将其转换为相同大小的十进制整 数值； 如果字符串是空的（不包含任何字符），则将其转换为 0； 如果字符串中包含除上述格式之外的字符，则将其转换为 NaN。 如果是对象，则调用对象的 valueOf()方法，然后依照前面的规则转换返回的值。如果转换 的结果是 NaN，则调用对象的 toString()方法，然后再次依照前面的规则转换返回的字符 串值。 //示例 Number('hello world') // NaN Number(null) // 0 Number(&quot;011&quot;) // 11 Number(true) // 1 Number(undefined) //NaN parseInt() 函数 由于 Number()函数在转换字符串时比较复杂而且不够合理，因此在处理整数的时候更常用的是 parseInt()函数。parseInt()函数在转换字符串时，更多的是看其是否符合数值模式。 parseInt()会替换掉空格，会忽略前导的0，如果字符串开头为字符则返回NaN。 parseInt(&quot;&quot;) //空字符串返回NaN parseInt(&quot;123abc&quot;) //123 parseInt(&quot;abc123&quot;) //NaN parseInt(‘’,进制) 接收一个进制，按照进制进行转换 parseFloat()函数 只解析10进制的数字，忽略前导的0 3.4.6 String类型 字符串字面量 反斜杠表示转义字符 \\n 换行 \\t 制表 \\b 空格 \\r 回车 \\f 进纸 \\\\ 斜杠 \\' 转义' \\&quot; 转义&quot; \\xnn 以十六进制代码nn表示的一个字符（其中n为0～F）。例如，\\x41表示&quot;A&quot; \\unnnn 以十六进制代码nnnn表示的一个Unicode字符（其中n为0～F）。例如，\\u03a3表示希腊字符Σ 字符串的特点 ECMAScript 中的字符串是不可变的，也就是说，字符串一旦创建，它们的值就不能改变。要改变 某个变量保存的字符串，首先要销毁原来的字符串，然后再用另一个包含新值的字符串填充该变量， 例如： var lang = &quot;Java&quot;; lang = lang + &quot;Script&quot;; 转换字符串 toString()方法，可以接收一个参数─进制 var age = 13; var ageAsString = age.toString(8); // 以8进制处理返回&quot;15&quot; 数值、布尔值、对象和字符串值（没错，每个字符串也都有一个 toString()方法，该方法返回字 符串的一个副本）都有 toString()方法。但 null 和 undefined 值没有这个方法。 String() 方法 如果值有 toString()方法，则调用该方法（没有参数）并返回相应的结果； 如果值是 null，则返回”null”； 如果值是 undefined，则返回”undefined”。 var value1 = 10; var value2 = true; var value3 = null; var value4 ; String(value1) // &quot;10&quot; String(value2) // &quot;true&quot; String(value3) // &quot;null&quot; String(value4) // &quot;undefined&quot; 要把某个值转换为字符串，可以使用加号操作符把它与一个字符 串（””）加在一起。 3.4.7 Object类型ECMAScript 中的对象其实就是一组数据和功能的集合。对象可以通过执行 new 操作符后跟要创建 的对象类型的名称来创建。而创建 Object 类型的实例并为其添加属性和（或）方法，就可以创建自定 义对象， var obj = new Object(); Object 的每个实例都具有下列属性和方法。 constructor：保存着用于创建当前对象的函数。对于前面的例子而言，构造函数（constructor） 就是 Object()。 hasOwnProperty(propertyName)：用于检查给定的属性在当前对象实例中（而不是在实例 的原型中）是否存在。其中，作为参数的属性名（propertyName）必须以字符串形式指定（例 如：o.hasOwnProperty(“name”)）。 isPrototypeOf(object)：用于检查传入的对象是否是传入对象的原型。 propertyIsEnumerable(propertyName)：用于检查给定的属性是否能够使用 for-in 语句来枚举。与 hasOwnProperty()方法一样，作为参数的属性名必须以字符串形式指定。 toLocaleString()：返回对象的字符串表示，该字符串与执行环境的地区对应。 toString()：返回对象的字符串表示。 valueOf() ：返回对象的字符串、数值或布尔值表示。 通常与 toString() 方法的返回值相同。 3.5 操作符ECMA-262 描述了一组用于操作数据值的操作符，包括算术操作符（如加号和减号）、位操作符、 关系操作符和相等操作符。ECMAScript 操作符的与众不同之处在于，它们能够适用于很多值，例如字 符串、数字值、布尔值，甚至对象。不过，在应用于对象时，相应的操作符通常都会调用对象的 valueOf() 和（或）toString()方法，以便取得可以操作的值。 3.5.1 一元操作符只能操作一个值的操作符叫做一元操作符。一元操作符是 ECMAScript 中最简单的操作符。 前置递增和递减操作 ++ / – ++ age ; -- age; //执行前置递增和递减操作时，变量的值都是在语句被求值以前改变的。（在计算机科学领域，这种 情况通常被称作副效应。） var age = 29 ; var anotherAge = --age + 2; //输出 age 28 anotherAge 30 //由于前置递增和递减操作与执行语句的优先级相等，因此整个语句会从左至右被求值 var num1 = 2;var num2 = 20; var num3 = –num1 + num2; //21var num4 = num1 + num2; //21 &gt; 加号/减号在前，先计算值，然后再计算表达式，值先增加/减少 &gt; &gt; 加号/减号在后，先计算表达式，然后再计算值，值后增加/减少 * 后置递增和递减操作 ```js var num1 = 2 var num2 = 20 var total = num1 ++ +num2 // 22 num1 //3 var total = num1 -- +num2 // 23 num1 //2 在应用于不同的值时，递增和递减操作符遵循下列规则: 在应用于一个包含有效数字字符的字符串时，先将其转换为数字值，再执行加减 1 的操作。字 符串变量变成数值变量。 在应用于一个不包含有效数字字符的字符串时，将变量的值设置为 NaN 字符串变量变成数值变量。 在应用于布尔值 false 时，先将其转换为 0 再执行加减 1 的操作。布尔值变量变成数值变量。 在应用于布尔值 true 时，先将其转换为 1 再执行加减 1 的操作。布尔值变量变成数值变量。 在应用于浮点数值时，执行加减 1 的操作。 在应用于对象时，先调用对象的 valueOf()方法以取得一个可供操作的 值。然后对该值应用前述规则。如果结果是 NaN，则在调用 toString()方法后再应用前述规 则。对象变量变成数值变量。 市例: var a = &quot;1&quot; a ++ // 1 a //2 typeof a // number var b = &quot;str&quot; b ++ // NaN b //NaN typeof b //number var c = false c++ // 0 c // 1 typeof c // number var d = true d++ // 1 d // 2 typeof d //number var e = 1.1 e ++ // 1.1 e // 2.1 typeof e // number var o = { valueOf : function(){ return 1 } } o ++ // 1 o // 2 typeof o // number 3.5.2 位操作符对于有符号的整数，32 位中的前 31 位用于表示整数的值。第 32 位用于表示数值的符号：0 表示正 数，1 表示负数。这个表示符号的位叫做符号位，符号位的值决定了其他位数值的格式。其中，正数以 纯二进制格式存储，31 位中的每一位都表示 2 的幂。第一位（叫做位 0）表示 2 0 ，第二位表示 2 1 ，以此 类 推 。 没 有 用 到 的 位 以 0 填 充 ， 即 忽 略 不 计 。 例 如 ， 数 值 18 的 二 进 制 表 示 是 00000000000000000000000000010010，或者更简洁的 10010。这是 5 个有效位，这 5 位本身就决定了实 际的值 var num = -18 num.toString(2) // &quot;-10010&quot; 按位非（NOT） 按位非操作符由一个波浪线（~）表示， 执行按位非的结果就是返回数值的反码 看不下去了，用到再补内容吧 3.5.3布尔操作符布尔操作符一共有 3 个：非（NOT）、与（AND）和或（OR） 逻辑非 逻辑非操作符由一个叹号（！）表示，可以应用于 ECMAScript 中的任何值。无论这个值是什么数据 类型，这个操作符都会返回一个布尔值。逻辑非操作符首先会将它的操作数转换为一个布尔值，然后再 对其求反。也就是说，逻辑非操作符遵循下列规则： 如果操作数是一个对象，返回 false；!{}//false 如果操作数是一个空字符串，返回 true；!&quot;&quot;//true 如果操作数是一个非空字符串，返回 false； !&quot;1&quot;//false 如果操作数是数值 0，返回 true；!0 //true 如果操作数是任意非 0 数值（包括 Infinity），返回 false；!2 //false !infinity //false 如果操作数是 null，返回 true； !null //true 如果操作数是 NaN，返回 true； !NaN //true 如果操作数是 undefined，返回 true。!undefined //true 双 !! 实际作用与 Boolean() 函数相当 逻辑与（短路操作符） 逻辑与操作符由两个和号（&amp;&amp;）表示，有两个操作数 var result = true &amp;&amp; false; 如果第一个操作数是对象，则返回第二个操作数 如果第二个操作数是对象， 则只有在第一个操作数的求值结果为 true 的情况下才会返回该 对象 如果两个操作数都是对象，则返回第二个操作数； 如果有一个操作数是 null，则返回 null； 如果有一个操作数是 NaN，则返回 NaN； 如果有一个操作数是 undefined，则返回 undefined。 逻辑与操作属于短路操作，即如果第一个操作数能够决定结果，那么就不会再对第二个操作数求值。 对于逻辑与操作而言，如果第一个操作数是 false，则无论第二个操作数是什么值，结果都不再可能是 true 了。 var found = true; var result = (found &amp;&amp; someUndefinedVariable); // 这里会发生错误 alert(result); // 这一行不会执行 在上面的代码中，当执行逻辑与操作时会发生错误，因为变量 someUndefinedVariable 没有声 明。由于变量 found 的值是 true，所以逻辑与操作符会继续对变量 someUndefinedVariable 求值。 但 someUndefinedVariable 尚未定义，因此就会导致错误。 逻辑或 逻辑或操作符由两个竖线符号（||）表示，有两个操作数 var result = true || false; 如果第一个操作数是对象，则返回第一个操作数； 如果第一个操作数的求值结果为 false，则返回第二个操作数 如果两个操作数都是对象，则返回第一个操作数 如果两个操作数都是 null，则返回 null 如果两个操作数都是 NaN，则返回 NaN； 如果两个操作数都是 undefined，则返回 undefined。 我们可以利用逻辑或的这一行为来避免为变量赋 null 或 undefined 值。 var a =value1 || value2 当value1 有值的时候赋值给a，如果value1 为false 则 赋值value2 3.5.4乘性操作符ECMAScript 定义了 3 个乘性操作符：乘法、除法和求模。这些操作符与 Java、C 或者 Perl 中的相 应操作符用途类似，只不过在操作数为非数值的情况下会执行自动的类型转换。如果参与乘性计算的某 个操作数不是数值，后台会先使用 Number()转型函数将其转换为数值。也就是说，空字符串将被当作 0，布尔值 true 将被当作 1。 乘法 var a = 35*20 如果操作数都是数值，执行常规的乘法计算，即两个正数或两个负数相乘的结果还是正数，而 如果只有一个操作数有符号，那么结果就是负数。如果乘积超过了 ECMAScript 数值的表示范围， 则返回 Infinity 或-Infinity； 如果有一个操作数是 NaN，则结果是 NaN； 如果是 Infinity 与 0 相乘，则结果是 NaN； 如果是 Infinity 与非 0 数值相乘，则结果是 Infinity 或-Infinity，取决于有符号操作数 的符号； 如果是 Infinity 与 Infinity 相乘，则结果是 Infinity 如果有一个操作数不是数值， 则在后台调用 Number() 将其转换为数值， 然后再应用上面的 规则 除法 如果操作数都是数值，执行常规的除法计算，即两个正数或两个负数相除的结果还是正数，而 如果只有一个操作数有符号，那么结果就是负数。如果商超过了 ECMAScript 数值的表示范围， 则返回 Infinity 或-Infinity； 如果有一个操作数是 NaN，则结果是 NaN； 如果是 Infinity 被 Infinity 除，则结果是 NaN 如果是零被零除，则结果是 NaN 如果是非零的有限数除以零，则结果是 Infinity 或-Infinity，取决于有符号操作数的符号 如果是 Infinity 被任何非零数值除，则结果是 Infinity 或-Infinity，取决于有符号操作 如果有一个操作数不是数值，则在后台调用 Number()将其转换为数值，然后再应用上面的规则 Infinity / 9 值为Infinity 9 / Infinity 值为0 求模 求模（余数）操作符由一个百分号（%）表示 var result = 26 % 5 //1 3.5.5 加性操作符 加法（➕） 如果两个操作符都是数值，执行常规的加法计算，然后根据下列规则返回结果: 如果有一个操作数是 NaN，则结果是 NaN 如果是 Infinity 加-Infinity，则结果是 NaN 如果是 Infinity 加 Infinity，则结果是 Infinity 如果是 -Infinity 加 -Infinity，则结果是 -Infinity 如果是+0 加+0，则结果是+0 如果是-0 加-0，则结果是-0 如果是+0 加-0，则结果是+0 对于字符串来说： 如果两个操作数都是字符串，则将第二个操作数与第一个操作数拼接起来； 如果只有一个操作数是字符串， 则将另一个操作数转换为字符串， 然后再将两个字符串拼接起来 对于对象、数值、布尔值： 如果有一个操作数是对象、数值或布尔值，则调用它们的 toString()方法取得相应的字符串值， 然后再应用前面关于字符串的规则。对于 undefined 和 null，则分别调用 String()函数并取得字符 串”undefined”和”null” var result = 5 + '5' //55 减法 （跳过） 3.5.6 关系操作符小于（&lt;）、大于（&gt;）、小于等于（&lt;=）和大于等于（&gt;=）这几个关系操作符用于对两个值进行比 较，比较的规则与我们在数学课上所学的一样。这几个操作符都返回一个布尔值 如果两个操作数都是数值，则执行数值比较 如果两个操作数都是字符串，则比较两个字符串对应的字符编码值 如果一个操作数是数值，则将另一个操作数转换为一个数值，然后执行数值比较 如果一个操作数是对象，则调用这个对象的 valueOf()方法，用得到的结果按照前面的规则执 行比较。如果对象没有 valueOf()方法，则调用 toString()方法，并用得到的结果根据前面 的规则执行比较 如果一个操作数是布尔值，则先将其转换为数值，然后再执行比较 var result = &quot;Brick&quot; &lt; &quot;alphabet&quot;;//true 在这个例子中，字符串”Brick”被认为小于字符串”alphabet”。原因是字母 B 的字符编码为 66， 而字母 a 的字符编码是 97。如果要真正按字母表顺序比较字符串，就必须把两个操作数转换为相同的大 小写形式（全部大写或全部小写），然后再执行比较， 另一种奇怪的现象发生在比较两个数字字符串的情况下： var result = &quot;23&quot; &lt; &quot;3&quot;; 结果为true 这是因为两个操作数都是字符串， 而字符串比较的是字符编码（”2”的字符编码是 50，而”3”的字符编码是 51） var result = &quot;23&quot; &lt; 3; 结果为false 因为字符串23转换为了数值 var result = 3 &gt; 'a' 结果为false 因为字符串a被转换成了 NaN，任何与NaN作比较都为false var result = NaN &lt; 3 //false var result = NaN &gt;= 3 //false var result = NaN == NaN //false 3.5.7 相等操作符 相等和不相等 == != 这两个操作符 都会把值进行强制转换，然后再比较他们的相等性 遵循以下规则： 如果操作数有布尔值，则转换为数值，false转为0，true转为1 如果一个操作数是字符串，另一个操作数是数值，在比较相等性之前先将字符串转换为数值 如果一个操作数是对象，另一个操作数不是，则调用对象的 valueOf()方法，用得到的基本类 型值按照前面的规则进行比较 null 和 undefined 是相等的 要比较相等性之前，不能将 null 和 undefined 转换成其他任何值 如果有一个操作数是 NaN，则相等操作符返回 false，而不相等操作符返回 true。重要提示： 即使两个操作数都是 NaN，相等操作符也返回 false；因为按照规则，NaN 不等于 NaN 如果两个操作数都是对象，则比较它们是不是同一个对象。如果两个操作数都指向同一个对象， 则相等操作符返回 true；否则，返回 false 全等和不全等 除了在比较之前不转换操作数之外，全等和不全等操作符与相等和不相等操作符没有什么区别。全 等操作符由 3 个等于号（===）表示，它只在两个操作数未经转换就相等的情况下返回 true 55 === '55' //false 因为是两个不同类型的值 一个是数值，一个是字符串 undefined == null // true undefined === null //false 因为是不同类型的值，undefined值为undefined，null的值为null 3.5.8 条件操作符三目运算符 var result = 条件1 ? 答案1 : 答案2 3.5.9 赋值操作符基础： = 扩展：*= += -= %= /= 3.5.10 逗号操作符使用逗号操作符可以在一条语句中执行多个操作 var num1=1, num2=2, num3=3; 逗号操作符多用于声明多个变量；但除此之外，逗号操作符还可以用于赋值。在用于赋值时，逗号 操作符总会返回表达式中的最后一项 var num = (5, 1, 4, 8, 0); // num 的值为 0 取最后一项 3.6语句3.6.1 if语句if (condition) statement1 else statement2 3.6.2 do-while 语句do-while 语句是一种后测试循环语句，即只有在循环体中的代码执行之后，才会测试出口条件。 换句话说，在对条件表达式求值之前，循环体内的代码至少会被执行一次。 do {statement} while (expression); //while里面的条件必须为true才能循环 3.6.3 while 语句while(expression) statement 3.6.4 for 语句for (initialization; expression; post-loop-expression) statement 此外，for 语句中的初始化表达式、控制表达式和循环后表达式都是可选的。将这三个表达式全部 省略，就会创建一个无限循环 for (;;) { doSomething(); }// 无限循环 3.6.5 for-in语句for (property in expression) statement 3.6.6 label 语句使用 label 语句可以在代码中添加标签，以便将来使用。 label: statement start: for (var i=0; i &lt; count; i++) { alert(i); } //这个例子中定义的 start 标签可以在将来由 break 或 continue 语句引用。加标签的语句一般都 要与 for 语句等循环语句配合使用。 let str = &quot;&quot;; loop1: for (let i = 0; i &lt; 5; i++) { if (i === 1) { continue loop1; } str = str + i; } console.log(str); // expected output: &quot;0234&quot; 3.6.7 break和continue语句break 和 continue 语句用于在循环中精确地控制代码的执行。其中，break 语句会立即退出循环， 强制继续执行循环后面的语句。而 continue 语句虽然也是立即退出循环，但退出循环后会从循环的顶 部继续执行。 break：跳出循环 continue：退出循环，从循环的顶部继续执行 break 和 continue 语句都可以与 label 语句联合使用，从而返回代码中特定的位置。这种联合 使用的情况多发生在循环嵌套的情况下 3.6.8 with语句with 语句的作用是将代码的作用域设置到一个特定的对象中 with (expression) statement; 由于大量使用 with 语句会导致性能下降，同时也会给调试代码造成困难，因此 在开发大型应用程序时，不建议使用 with 语句 3.6.9 switch 语句var a = 1 switch(a){ case 1 : //do something break; case 2 : //do something break; }; //合并两种情形 switch(a){ case 1: case 2: //命中1或者2时 需要执行的代码 break; default: //do something 默认不命中的时候执行 } switch 语句中的每一种情形（case）的含义是：“如果表达式等于这个值（value），则执行后面的 语句（statement）”。而 break 关键字会导致代码执行流跳出 switch 语句。如果省略 break 关键字， 就会导致执行完当前 case 后，继续执行下一个 case。最后的 default 关键字则用于在表达式不匹配前 面任何一种情形的时候，执行机动代码（因此，也相当于一个 else 语句） switch 语句在比较值时使用的是全等操作符，因此不会发生类型转换（例如， 字符串”10”不等于数值 10） 3.7 函数函数对任何语言来说都是一个核心的概念。通过函数可以封装任意多条语句，而且可以在任何地方、 任何时候调用执行。ECMAScript 中的函数使用 function 关键字来声明，后跟一组参数以及函数体。 function functionName(arg0, arg1,...,argN) { statements } function name(){ return //返回一个值 alert(&quot;test&quot;) //不会被执行，因为已经有返回值 } //这个函数会在执行完 return 语句之后停止并立即退出。因此，位于 return 语句之后的任何代码 都永远不会执行。 3.7.1 理解函数ECMAScript 函数的参数与大多数其他语言中函数的参数有所不同。ECMAScript 函数不介意传递进 来多少个参数，也不在乎传进来参数是什么数据类型。也就是说，即便你定义的函数只接收两个参数， 在调用这个函数时也未必一定要传递两个参数。可以传递一个、三个甚至不传递参数，而解析器永远不 会有什么怨言。之所以会这样，原因是 ECMAScript 中的参数在内部是用一个数组来表示的。函数接收 到的始终都是这个数组，而不关心数组中包含哪些参数（如果有参数的话）。如果这个数组中不包含任 何元素，无所谓；如果包含多个元素，也没有问题。实际上，在函数体内可以通过 arguments 对象来 访问这个参数数组，从而获取传递给函数的每一个参数。 关于 arguments 的行为，还有一点比较有意思。那就是它的值永远与对应命名参数的值保持同步。 function doAdd(num1, num2) { arguments[1] = 10; alert(arguments[0] + num2); } 每次执行这个 doAdd()函数都会重写第二个参数，将第二个参数的值修改为 10。因为 arguments 对象中的值会自动反映到对应的命名参数，所以修改 arguments[1]，也就修改了 num2，结果它们的 值都会变成 10。不过，这并不是说读取这两个值会访问相同的内存空间；它们的内存空间是独立的，但 它们的值会同步。另外还要记住，如果只传入了一个参数，那么为 arguments[1]设置的值不会反应到 命名参数中。这是因为 arguments 对象的长度是由传入的参数个数决定的，不是由定义函数时的命名 参数的个数决定的。 关于参数还要记住最后一点：没有传递值的命名参数将自动被赋予 undefined 值。这就跟定义了 变量但又没有初始化一样。 例如， 如果只给 doAdd() 函数传递了一个参数， 则 num2 中就会保存 undefined 值。 严格模式对如何使用 arguments 对象做出了一些限制。首先，像前面例子中那样的赋值会变得无 效。 也就是说， 即使把 arguments[1] 设置为 10 ， num2 的值仍然还是 undefined 。 其次， 重写 arguments 的值会导致语法错误（代码将不会执行）。 ECMAScript 中的所有参数传递的都是值，不可能通过引用传递参数。 3.7.2 没有重载ECMAScript 函数不能像传统意义上那样实现重载。而在其他语言（如 Java）中，可以为一个函数 编写两个定义，只要这两个定义的签名（接受的参数的类型和数量）不同即可。如前所述，ECMAScirpt 函数没有签名，因为其参数是由包含零或多个值的数组来表示的。而没有函数签名，真正的重载是不可 能做到的。 如果在 ECMAScript 中定义了两个名字相同的函数，则该名字只属于后定义的函数 function addSomeNumber(num){ return num + 100; } function addSomeNumber(num) { return num + 200; } var result = addSomeNumber(100);//300","link":"/passages/%E3%80%90JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%91%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"},{"title":"【JS高级程序设计】第四章 变量、作用域和内存问题","text":"4.1基本类型和引用类型的值基本类型： undefined null Boolean Number String 引用类型： Object Function Array 引用类型的值是保存在内存中的对象。与其他语言不同，JavaScript 不允许直接访问内存中的位置， 也就是说不能直接操作对象的内存空间。在操作对象时，实际上是在操作对象的引用而不是实际的对象。 为此，引用类型的值是按引用访问的 4.1.1 动态的属性定义基本类型值和引用类型值的方式是类似的：创建一个变量并为该变量赋值。但是，当这个值保 存到变量中以后，对不同类型值可以执行的操作则大相径庭。对于引用类型的值，我们可以为其添加属 性和方法，也可以改变和删除其属性和方法。 var person = new Object() person.name = &quot;nico&quot; alert(person.name) //nico 以上代码创建了一个对象并将其保存在了变量 person 中。然后，我们为该对象添加了一个名为 name 的属性，并将字符串值”nico”赋给了这个属性。紧接着，又通过 alert()函数访问了这个 新属性。如果对象不被销毁或者这个属性不被删除，则这个属性将一直存在。 但是，我们不能给基本类型的值添加属性，尽管这样做不会导致任何错误: var name = &quot;nico&quot; name.age = 27 console.log(name.age) //undefined 我们为字符串 name 定义了一个名为 age 的属性，并为该属性赋值 27。但在下一 行访问这个属性时，发现该属性不见了。这说明只能给引用类型值动态地添加属性，以便将来使用。 4.1.2 复制变量的值除了保存的方式不同之外，在从一个变量向另一个变量复制基本类型值和引用类型值时，也存在不 同。如果从一个变量向另一个变量复制基本类型的值，会在变量对象上创建一个新值，然后把该值复制 到为新变量分配的位置上。 var num = 5 num1 = num 在此，num1 中保存的值是 5。当使用 num1 的值来初始化 num2 时，num2 中也保存了值 5。但 num2 中的 5 与 num1 中的 5 是完全独立的，该值只是 num1 中 5 的一个副本。此后，这两个变量可以参与任 何操作而不会相互影响。 当从一个变量向另一个变量复制引用类型的值时，同样也会将存储在变量对象中的值复制一份放到 为新变量分配的空间中。不同的是，这个值的副本实际上是一个指针，而这个指针指向存储在堆中的一 个对象。复制操作结束后，两个变量实际上将引用同一个对象。因此，改变其中一个变量，就会影响另 一个变量。 var obj1 = new Object() var obj2 = obj1 obj1.name = 'nico' console.log(obj2.name) //nico //此时共享一个堆 4.1.3 传递参数在向参数传递基本类型的值时， 被传递的值会被复制给一个局部变量（即命名参数， 或者用 ECMAScript 的概念来说，就是 arguments 对象中的一个元素）。在向参数传递引用类型的值时，会把 这个值在内存中的地址复制给一个局部变量，因此这个局部变量的变化会反映在函数的外部。 function addTen(num){ num += 10 return num } var a = 10 var result = addTen(a) a // 10 未改变 result // 20 这里的函数 addTen()有一个参数 num，而参数实际上是函数的局部变量。在调用这个函数时，变 量 count 作为参数被传递给函数，这个变量的值是20。于是，数值20被复制给参数 num 以便在 addTen() 中使用。在函数内部，参数 num 的值被加上了 10，但这一变化不会影响函数外部的 count 变量。参数 num 与变量 count 互不相识，它们仅仅是具有相同的值。假如 num 是按引用传递的话，那么变量 count 的值也将变成 30，从而反映函数内部的修改。 function setName(obj){ obj.name = 'nico' obj = new Object() obj.name = 'nico1' } var person = {} setName(person) person.name //nico 这个例子与前一个例子的唯一区别，就是在 setName()函数中添加了两行代码：一行代码为 obj 重新定义了一个对象，另一行代码为该对象定义了一个带有不同值的 name 属性。在把 person 传递给 setName()后，其 name 属性被设置为”Nicholas”。然后，又将一个新对象赋给变量 obj，同时将其 name 属性设置为”Greg”。如果 person 是按引用传递的，那么 person 就会自动被修改为指向其 name 属性值 为”Greg”的新对象。但是，当接下来再访问 person.name 时，显示的值仍然是”Nicholas”。这说明 即使在函数内部修改了参数的值，但原始的引用仍然保持未变。实际上，当在函数内部重写 obj 时，这 个变量引用的就是一个局部对象了。而这个局部对象会在函数执行完毕后立即被销毁。 可以把 ECMAScript 函数的参数想象成局部变量。 4.1.4 检测类型基本数据类型检测：typeof 对象类型检测：A instanceof B , A是B的实例对象 根据规定，所有引用类型的值都是 Object 的实例。因此，在检测一个引用类型值和 Object 构造 函数时，instanceof 操作符始终会返回 true。当然，如果使用 instanceof 操作符检测基本类型的 值，则该操作符始终会返回 false，因为基本类型不是对象。 4.2 执行环境执行环境（execution context，为简单起见，有时也称为“环境”）是 JavaScript 中最为重要的一个概 念。执行环境定义了变量或函数有权访问的其他数据，决定了它们各自的行为。每个执行环境都有一个 与之关联的变量对象（variable object），环境中定义的所有变量和函数都保存在这个对象中。虽然我们 编写的代码无法访问这个对象，但解析器在处理数据时会在后台使用它。 全局执行环境是最外围的一个执行环境。根据 ECMAScript 实现所在的宿主环境不同，表示执行环 境的对象也不一样。在 Web 浏览器中，全局执行环境被认为是 window 对象（第 7 章将详细讨论），因 此所有全局变量和函数都是作为 window 对象的属性和方法创建的。某个执行环境中的所有代码执行完 毕后，该环境被销毁，保存在其中的所有变量和函数定义也随之销毁（全局执行环境直到应用程序退 出——例如关闭网页或浏览器——时才会被销毁）。 每个函数都有自己的执行环境。当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。 而在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境。ECMAScript 程序中的执行流 正是由这个方便的机制控制着。 当代码在一个环境中执行时，会创建变量对象的一个作用域链（scope chain）。作用域链的用途，是 保证对执行环境有权访问的所有变量和函数的有序访问。作用域链的前端，始终都是当前执行的代码所 在环境的变量对象。如果这个环境是函数，则将其活动对象（activation object）作为变量对象。活动对 象在最开始时只包含一个变量，即 arguments 对象（这个对象在全局环境中是不存在的）。作用域链中 的下一个变量对象来自包含（外部）环境，而再下一个变量对象则来自下一个包含环境。这样，一直延 续到全局执行环境；全局执行环境的变量对象始终都是作用域链中的最后一个对象。 标识符解析是沿着作用域链一级一级地搜索标识符的过程。搜索过程始终从作用域链的前端开始， 然后逐级地向后回溯，直至找到标识符为止（如果找不到标识符，通常会导致错误发生）。 4.2.2 没有块级作用域JavaScript 没有块级作用域经常会导致理解上的困惑。在其他类 C 的语言中，由花括号封闭的代码 块都有自己的作用域（如果用 ECMAScript 的话来讲，就是它们自己的执行环境），因而支持根据条件来 定义变量。 例如，下面的代码在 JavaScript 中并不会得到想象中的结果： if (true) { var color = &quot;blue&quot;; } alert(color);//&quot;blue&quot; for(var i in arrs){ } //此时i为定义的全局变量，for语句执行完以后也不会被销毁 声明变量 使用 var 声明的变量会自动被添加到最接近的环境中。在函数内部，最接近的环境就是函数的局部 环境； 在 with 语句中，最接近的环境是函数环境。如果初始化变量时没有使用 var 声明，该变量会自 动被添加到全局环境。 查询标识符 当在某个环境中为了读取或写入而引用一个标识符时，必须通过搜索来确定该标识符实际代表什 么。搜索过程从作用域链的前端开始，向上逐级查询与给定名字匹配的标识符。如果在局部环境中找到 了该标识符，搜索过程停止，变量就绪。如果在局部环境中没有找到该变量名，则继续沿作用域链向上 搜索。搜索过程将一直追溯到全局环境的变量对象。如果在全局环境中也没有找到这个标识符，则意味 着该变量尚未声明。 var color = 'red' function getColor(){ return color } getColor() //red 调用本例中的函数 getColor()时会引用变量 color。为了确定变量 color 的值，将开始一个两 步的搜索过程。首先，搜索 getColor()的变量对象，查找其中是否包含一个名为 color 的标识符。 在没有找到的情况下， 搜索继续到下一个变量对象（全局环境的变量对象）， 然后在那里找到了名为 color 的标识符。因为搜索到了定义这个变量的变量对象，搜索过程宣告结束。 在这个搜索过程中，如果存在一个局部的变量的定义，则搜索会自动停止，不再进入另一个变量对 象。换句话说，如果局部环境中存在着同名标识符，就不会使用位于父环境中的标识符 var color = 'red' function getColor(){ var color = 'blue' return color } getColor() // blue 上述例子：先搜寻函数内部变量是否有color这个标识符，找到了就返回，不会再往上搜索 变量查询也不是没有代价的。很明显，访问局部变量要比访问全局变量更快，因 为不用向上搜索作用域链。JavaScript 引擎在优化标识符查询方面做得不错，因此这 个差别在将来恐怕就可以忽略不计了。 4.3 垃圾处理JavaScript 具有自动垃圾收集机制，也就是说，执行环境会负责管理代码执行过程中使用的内存。 在编写 JavaScript 程序时，开发人员不用再关心内存使用问题，所需内存的分配以及无 用内存的回收完全实现了自动管理。这种垃圾收集机制的原理其实很简单：找出那些不再继续使用的变 量，然后释放其占用的内存。为此，垃圾收集器会按照固定的时间间隔（或代码执行中预定的收集时间）， 周期性地执行这一操作。 4.3.1 标记清除JavaScript 中最常用的垃圾收集方式是标记清除（mark-and-sweep）。当变量进入环境（例如，在函 数中声明一个变量）时，就将这个变量标记为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。而当变量离开环境时，则将其 标记为“离开环境”。 可以使用任何方式来标记变量。比如，可以通过翻转某个特殊的位来记录一个变量何时进入环境， 或者使用一个“进入环境的”变量列表及一个“离开环境的”变量列表来跟踪哪个变量发生了变化。说 到底，如何标记变量其实并不重要，关键在于采取什么策略。 垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记（当然，可以使用任何标记方 式）。然后，它会去掉环境中的变量以及被环境中的变量引用的变量的标记。而在此之后再被加上标记 的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后，垃圾收集器 完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。 4.3.2 引用计数另一种不太常见的垃圾收集策略叫做引用计数（reference counting）。引用计数的含义是跟踪记录每 个值被引用的次数。当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是 1。 如果同一个值又被赋给另一个变量，则该值的引用次数加 1。相反，如果包含对这个值引用的变量又取 得了另外一个值，则这个值的引用次数减 1。当这个值的引用次数变成 0 时，则说明没有办法再访问这 个值了，因而就可以将其占用的内存空间回收回来。这样，当垃圾收集器下次再运行时，它就会释放那 些引用次数为零的值所占用的内存。 var a = { name : &quot;test&quot; } //此时在内存中的这个对象被引用了一次，被引用计数标记为1 var b = a //被引用计数标记为2 var a = {} //上一个对象的引用计数标记减少了一次，标记为1 var b = {} //第一个对象的引用计数少了一次，标记为0，被清理内存 Netscape Navigator 3.0 是最早使用引用计数策略的浏览器，但很快它就遇到了一个严重的问题：循 环引用。循环引用指的是对象 A 中包含一个指向对象 B 的指针，而对象 B 中也包含一个指向对象 A 的 引用。请看下面这个例子： function problem(){ var objectA = new Object(); var objectB = new Object(); objectA.someOtherObject = objectB; objectB.anotherObject = objectA; } 在这个例子中，objectA 和 objectB 通过各自的属性相互引用；也就是说，这两个对象的引用次 数都是 2。在采用标记清除策略的实现中，由于函数执行之后，这两个对象都离开了作用域，因此这种 相互引用不是个问题。但在采用引用计数策略的实现中，当函数执行完毕后，objectA 和 objectB 还 将继续存在，因为它们的引用次数永远不会是 0。假如这个函数被重复多次调用，就会导致大量内存得 不到回收。为此，Netscape 在 Navigator 4.0 中放弃了引用计数方式，转而采用标记清除来实现其垃圾收 集机制。可是，引用计数导致的麻烦并未就此终结。 4.3.3 性能问题垃圾收集器是周期性运行的，而且如果为变量分配的内存数量很可观，那么回收工作量也是相当大 的。在这种情况下，确定垃圾收集的时间间隔是一个非常重要的问题。说到垃圾收集器多长时间运行一 次，不禁让人联想到 IE 因此而声名狼藉的性能问题。IE 的垃圾收集器是根据内存分配量运行的，具体 一点说就是 256 个变量、4096 个对象（或数组）字面量和数组元素（slot）或者 64KB 的字符串。达到 上述任何一个临界值，垃圾收集器就会运行。这种实现方式的问题在于，如果一个脚本中包含那么多变 量，那么该脚本很可能会在其生命周期中一直保有那么多的变量。而这样一来，垃圾收集器就不得不频 繁地运行。结果，由此引发的严重性能问题促使 IE7 重写了其垃圾收集例程。 随着 IE7 的发布，其 JavaScript 引擎的垃圾收集例程改变了工作方式：触发垃圾收集的变量分配、 字面量和（或）数组元素的临界值被调整为动态修正。IE7 中的各项临界值在初始时与 IE6 相等。如果 垃圾收集例程回收的内存分配量低于 15%，则变量、字面量和（或）数组元素的临界值就会加倍。如果 例程回收了 85%的内存分配量，则将各种临界值重置回默认值。这一看似简单的调整，极大地提升了 IE 在运行包含大量 JavaScript 的页面时的性能。 4.3.4 管理内存使用具备垃圾收集机制的语言编写程序，开发人员一般不必操心内存管理的问题。但是，JavaScript 在进行内存管理及垃圾收集时面临的问题还是有点与众不同。其中最主要的一个问题，就是分配给 Web 浏览器的可用内存数量通常要比分配给桌面应用程序的少。这样做的目的主要是出于安全方面的考虑， 目的是防止运行 JavaScript 的网页耗尽全部系统内存而导致系统崩溃。内存限制问题不仅会影响给变量 分配内存，同时还会影响调用栈以及在一个线程中能够同时执行的语句数量。 因此，确保占用最少的内存可以让页面获得更好的性能。而优化内存占用的最佳方式，就是为执行 中的代码只保存必要的数据。一旦数据不再有用，最好通过将其值设置为 null 来释放其引用——这个 做法叫做解除引用（dereferencing）。这一做法适用于大多数全局变量和全局对象的属性。局部变量会在 它们离开执行环境时自动被解除引用 4.4小结 基本类型值在内存中占据固定大小的空间，因此被保存在栈内存中； 从一个变量向另一个变量复制基本类型的值，会创建这个值的一个副本； 引用类型的值是对象，保存在堆内存中； 包含引用类型值的变量实际上包含的并不是对象本身，而是一个指向该对象的指针； 从一个变量向另一个变量复制引用类型的值，复制的其实是指针，因此两个变量最终都指向同 一个对象； 确定一个值是哪种基本类型可以使用 typeof 操作符，而确定一个值是哪种引用类型可以使用 instanceof 操作符。 JavaScript 是一门具有自动垃圾收集机制的编程语言，开发人员不必关心内存分配和回收问题。可 以对 JavaScript 的垃圾收集例程作如下总结。 离开作用域的值将被自动标记为可以回收，因此将在垃圾收集期间被删除。 “标记清除”是目前主流的垃圾收集算法，这种算法的思想是给当前不使用的值加上标记，然 后再回收其内存。 另一种垃圾收集算法是“引用计数”，这种算法的思想是跟踪记录所有值被引用的次数。JavaScript 引擎目前都不再使用这种算法；但在 IE 中访问非原生 JavaScript 对象（如 DOM 元素）时，这种 算法仍然可能会导致问题。 当代码中存在循环引用现象时，“引用计数”算法就会导致问题。 解除变量的引用不仅有助于消除循环引用现象，而且对垃圾收集也有好处。为了确保有效地回 收内存，应该及时解除不再使用的全局对象、全局对象属性以及循环引用变量的引用。","link":"/passages/%E3%80%90JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%91%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%8F%98%E9%87%8F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%86%85%E5%AD%98%E9%97%AE%E9%A2%98/"},{"title":"原生 JavaScript 的 DOM 操作汇总","text":"​ 原文链接：https://harttle.land/2015/10/01/javascript-dom-api.html 经常有人讲在 IDE 中写 C#、Java 会越来越手残，那么经常用 jQuery 也会让我们忘记 JavaScript 是如何操作 DOM 的。 JavaScript的DOM操作也是面试中的常见问题，尤其是当你需要回答jQuery的性能问题时，便需要再次回到JavaScript DOM API。 什么是 DOM？外行看来前端工程师的工作就是改页面（HTML、CSS），写脚本（JavaScript）。当你意识到你不是在改HTML而是在操作DOM时，你就升级了！ 那么什么是DOM？ MDN: 文档对象模型 (DOM) 是HTML和XML文档的编程接口。它提供了对文档的结构化的表述，并定义了一种方式可以使从程序中对该结构进行访问，从而改变文档的结构，样式和内容。DOM 将文档解析为一个由节点和对象（包含属性和方法的对象）组成的结构集合。简言之，它会将web页面和脚本或程序语言连接起来。 说白了 DOM 就是浏览器为 JavaScript 提供的一系列接口（通过 window.documnet 提供的），通过这些接口我们可以操作web页面。 但DOM并不是编程语言，它是文档对象的模型，该模型是独立于编程语言的。比如我们在Python中也可以操作DOM： import xml.dom.minidom as m doc = m.parse(&quot;C:\\\\Projects\\\\Py\\\\chap1.xml&quot;); doc.nodeName # DOM property of document object; p_list = doc.getElementsByTagName(&quot;para&quot;); 所以Web前端常讲的DOM API (web 或 XML 页面) = DOM + JS (脚本语言) DOM 创建DOM节点（Node）通常对应于一个标签，一个文本，或者一个HTML属性。DOM节点有一个nodeType属性用来表示当前元素的类型，它是一个整数： Element，元素 Attribute，属性 Text，文本 DOM节点创建最常用的便是document.createElement和document.createTextNode方法： var el1 = document.createElement('div'); var el2 = document.createElement('input'); var node = document.createTextNode('hello world!'); DOM 查询元素查询的API返回的的结果是DOM节点或者DOM节点的列表。document提供了两种Query方法： // 返回当前文档中第一个类名为 &quot;myclass&quot; 的元素 var el = document.querySelector(&quot;.myclass&quot;); // 返回一个文档中所有的class为&quot;note&quot;或者 &quot;alert&quot;的div元素 var els = document.querySelectorAll(&quot;div.note, div.alert&quot;); // 获取元素 var el = document.getElementById('xxx'); var els = document.getElementsByClassName('highlight'); var els = document.getElementsByTagName('td'); Element也提供了很多相对于元素的DOM导航方法： // 获取父元素、父节点 var parent = ele.parentElement; var parent = ele.parentNode; // 获取子节点，子节点可以是任何一种节点，可以通过nodeType来判断 var nodes = ele.children; // 查询子元素 var els = ele.getElementsByTagName('td'); var els = ele.getElementsByClassName('highlight'); // 当前元素的第一个/最后一个子元素节点 var el = ele.firstElementChild; var el = ele.lastElementChild; // 下一个/上一个兄弟元素节点 var el = ele.nextElementSibling; var el = ele.previousElementSibling; DOM 更改// 添加、删除子元素 ele.appendChild(el); ele.removeChild(el); // 替换子元素 ele.replaceChild(el1, el2); // 插入子元素 parentElement.insertBefore(newElement, referenceElement); 属性操作// 获取一个{name, value}的数组 var attrs = el.attributes; // 获取、设置属性 var c = el.getAttribute('class'); el.setAttribute('class', 'highlight'); // 判断、移除属性 el.hasAttribute('class'); el.removeAttribute('class'); // 是否有属性设置 el.hasAttributes(); 常见的面试问题innerHTML 与 outerHTML 的区别？DOM 元素的 innerHTML, outerHTML, innerText, outerText 属性的区别也经常被面试官问到， 比如对于这样一个HTML元素：&lt;div&gt;content&lt;br/&gt;&lt;/div&gt;。 innerHTML：内部HTML，content&lt;br/&gt;； outerHTML：外部HTML，&lt;div&gt;content&lt;br/&gt;&lt;/div&gt;； innerText：内部文本，content； outerText：内部文本，content； 上述四个属性不仅可以读取，还可以赋值。outerText 和 innerText 的区别在于 outerText 赋值时会把标签一起赋值掉，另外 xxText 赋值时HTML特殊字符会被转义。 下图来源于：http://walsh.iteye.com/blog/261966 jQuery的html()与innerHTML的区别？jQuery的 .html() 会调用.innerHTML来操作，但是会捕获异常，然后用 .empty(), .append() 重新操作。 这是因为IE8中有些元素的 .innerHTML 是只读的。见：http://stackoverflow.com/questions/3563107/jquery-html-vs-innerhtml","link":"/passages/%E5%8E%9F%E7%94%9F-JavaScript-%E7%9A%84-DOM-%E6%93%8D%E4%BD%9C%E6%B1%87%E6%80%BB/"}],"tags":[{"name":"CentOS","slug":"CentOS","link":"/tags/CentOS/"},{"name":"防火墙","slug":"防火墙","link":"/tags/%E9%98%B2%E7%81%AB%E5%A2%99/"},{"name":"端口","slug":"端口","link":"/tags/%E7%AB%AF%E5%8F%A3/"},{"name":"DOM","slug":"DOM","link":"/tags/DOM/"},{"name":"DOM节点操作","slug":"DOM节点操作","link":"/tags/DOM%E8%8A%82%E7%82%B9%E6%93%8D%E4%BD%9C/"},{"name":"javascript-dom-编程艺术","slug":"javascript-dom-编程艺术","link":"/tags/javascript-dom-%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/"},{"name":"DOM结构","slug":"DOM结构","link":"/tags/DOM%E7%BB%93%E6%9E%84/"},{"name":"DOM文档对象","slug":"DOM文档对象","link":"/tags/DOM%E6%96%87%E6%A1%A3%E5%AF%B9%E8%B1%A1/"},{"name":"Javascript","slug":"Javascript","link":"/tags/Javascript/"},{"name":"Function","slug":"Function","link":"/tags/Function/"},{"name":"HTML标记","slug":"HTML标记","link":"/tags/HTML%E6%A0%87%E8%AE%B0/"},{"name":"图片库","slug":"图片库","link":"/tags/%E5%9B%BE%E7%89%87%E5%BA%93/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"this指针","slug":"this指针","link":"/tags/this%E6%8C%87%E9%92%88/"},{"name":"图片库改进","slug":"图片库改进","link":"/tags/%E5%9B%BE%E7%89%87%E5%BA%93%E6%94%B9%E8%BF%9B/"},{"name":"Array","slug":"Array","link":"/tags/Array/"},{"name":"最佳实践","slug":"最佳实践","link":"/tags/%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"},{"name":"效率","slug":"效率","link":"/tags/%E6%95%88%E7%8E%87/"},{"name":"快捷键","slug":"快捷键","link":"/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/"},{"name":"知识点","slug":"知识点","link":"/tags/%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"name":"MacOS 常用软件","slug":"MacOS-常用软件","link":"/tags/MacOS-%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/"},{"name":"TNT 破解版","slug":"TNT-破解版","link":"/tags/TNT-%E7%A0%B4%E8%A7%A3%E7%89%88/"},{"name":"JavaScript高级程序设计","slug":"JavaScript高级程序设计","link":"/tags/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"},{"name":"JS基本概念","slug":"JS基本概念","link":"/tags/JS%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"},{"name":"在HTML中使用JavaScript","slug":"在HTML中使用JavaScript","link":"/tags/%E5%9C%A8HTML%E4%B8%AD%E4%BD%BF%E7%94%A8JavaScript/"},{"name":"DOM操作","slug":"DOM操作","link":"/tags/DOM%E6%93%8D%E4%BD%9C/"}],"categories":[{"name":"centos","slug":"centos","link":"/categories/centos/"},{"name":"javascript","slug":"javascript","link":"/categories/javascript/"},{"name":"macos","slug":"macos","link":"/categories/macos/"}]}