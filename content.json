{"pages":[{"title":"categories","text":"","link":"/categories/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"CentOS 防火墙 启动&#x2F;停止&#x2F;重启&#x2F;永久开启端口","text":"# &gt;&gt;&gt; 开启端口 firewall-cmd --zone=public --add-port=8000/tcp --permanent # 命令含义： --zone #作用域 --add-port=80/tcp #添加端口，格式为：端口/通讯协议 --permanent #永久生效，没有此参数重启后失效 # &gt;&gt;&gt; 重启防火墙 firewall-cmd --reload ##重启防火墙 firewall-cmd --state ##查看防火墙状态，是否是running firewall-cmd --reload ##重新载入配置，比如添加规则之后，需要执行此命令 firewall-cmd --get-zones ##列出支持的zone firewall-cmd --get-services ##列出支持的服务，在列表中的服务是放行的 firewall-cmd --query-service ftp ##查看ftp服务是否支持，返回yes或者no firewall-cmd --add-service=ftp ##临时开放ftp服务 firewall-cmd --add-service=ftp --permanent ##永久开放ftp服务 firewall-cmd --remove-service=ftp --permanent ##永久移除ftp服务 firewall-cmd --add-port=80/tcp --permanent ##永久添加80端口 iptables -L -n ##查看规则，这个命令是和iptables的相同的 man firewall-cmd ##查看帮助 # &gt;&gt;&gt; CentOS 7.0默认使用的是firewall作为防火墙，使用iptables必须重新设置一下 # 1、直接关闭防火墙 systemctl stop firewalld.service #停止firewall systemctl disable firewalld.service #禁止firewall开机启动 # 2、设置 iptables service yum -y install iptables-services # 如果要修改防火墙配置，如增加防火墙端口3306 vi /etc/sysconfig/iptables # 增加规则 -A INPUT -m state --state NEW -m tcp -p tcp --dport 3306 -j ACCEPT # 保存退出后 systemctl restart iptables.service #重启防火墙使配置生效 systemctl enable iptables.service #设置防火墙开机启动 # 最后重启系统使设置生效即可。","link":"/passages/CentOS-%E9%98%B2%E7%81%AB%E5%A2%99-%E5%90%AF%E5%8A%A8-%E5%81%9C%E6%AD%A2-%E9%87%8D%E5%90%AF-%E6%B0%B8%E4%B9%85%E5%BC%80%E5%90%AF%E7%AB%AF%E5%8F%A3/"},{"title":"JS获取子节点、父节点和兄弟节点的若干种方式","text":"原文链接：https://blog.csdn.net/laok_/article/details/75760572 一、js获取子节点的方式1.通过获取dom方式直接获取子节点其中test的父标签id的值，div为标签的名字。getElementsByTagName是一个方法。返回的是一个数组。在访问的时候要按数组的形式访问。 var a = document.getElementById(&quot;test&quot;).getElementsByTagName(&quot;div&quot;); 2.通过childNodes获取子节点使用childNodes获取子节点的时候，childNodes返回的是子节点的集合，是一个数组的格式。他会把换行和空格也当成是节点信息。 var b =document.getElementById(&quot;test&quot;).childNodes; //为了不显示不必须的换行的空格，我们如果要使用childNodes就必须进行必要的过滤。通过正则表达式式取掉不必要的信息。 //去掉换行的空格 for(var i=0; i&lt;b.length;i++){ if(b[i].nodeName == &quot;#text&quot; &amp;&amp; !/\\s/.test(b.nodeValue)){ document.getElementById(&quot;test&quot;).removeChild(b[i]); } } //打印测试 for(var i=0;i&lt;b.length;i++){ console.log(i+&quot;---------&quot;) console.log(b[i]); } //补充 document.getElementById(&quot;test&quot;).childElementCount; 可以直接获取长度 同length 3.通过children来获取子节点var getFirstChild = document.getElementById(&quot;test&quot;).children[0];","link":"/passages/JS%E8%8E%B7%E5%8F%96%E5%AD%90%E8%8A%82%E7%82%B9%E3%80%81%E7%88%B6%E8%8A%82%E7%82%B9%E5%92%8C%E5%85%84%E5%BC%9F%E8%8A%82%E7%82%B9%E7%9A%84%E8%8B%A5%E5%B9%B2%E7%A7%8D%E6%96%B9%E5%BC%8F/"},{"title":"JavaScript-语法","text":"第二章：JavaScript语法变量赋值： var age,mood; // console.log(age,mood) 已定义的变量输出为undefined console.log(a) // 未定义的直接抛出错误 Uncaught ReferenceError: a is not defined 数据类型： JavaScript为弱语言类型 // var age = ‘thirty’ ; age = 33; 不会报错 字符串(String) 转义字符 “ \\ ” 示例： var mood = ‘don\\‘t ask’ ; var height =”about 5 ‘10\\“tall” ; 数值(Number) 整数 负数 浮点数(floating-point number) 布尔值(boolean) true false 数组(Array) 下标index+值value 的组合 index开始于0 length 数组长度 传统下标赋值（值可以有 任意基础类型） 二维数组嵌套 class[0][0] 第一班第一位 var people = []; people['name'] = 'john'; people['year'] = 1940; 这样的数组叫做关联数组。由于可以使用字符串来代替数字值,因而代码更具有可读性。但是,这种用法并不是一个好习惯,不推荐大家使用。本质上,在创建关联数组时,你创建的是Aray对象的属性。在 JavaScript中,所有的变量实际上都是某种类型的对象。比如,一个布尔值就是一个 Boolean类型的对象,一个数组就是一个Aray类型的对象。在上面这个例子中,你实际上是给 lennon数组添加了name、year和 living三个属性。理想情况下,你不应该修改Aray对象的属性,而应该使用通用的对象( object)。 对象 创建对象使用0bject关键字 var lennon ={ name: John”, year: 1940, living: false } // 创建对象 操作（operation） 算数操作符 加减乘除 + - * / 自增 自减 ++ -- +连接字符串 += -= *= /= // var a = a + 1 ; a+=1 ; 可进行字符串拼接 强制转换为字符串 var year = 2018; var message = &quot;this year&quot; + year; console.log(message) // 条件语句 if 条件语句 基本语法： if(条件语句){ //条件为真 往下执行 //执行语句 } if(1&gt;2) alert('false') //可写成一行 比较操作符 大于 小于 大于等于 小于等于 相等 全等 不等于 不全等（&gt; &lt; &gt;= &lt;= == === != !==） 逻辑操作符 或于切（|| 或、&amp;&amp; 且） 或 || 一个条件为真 就是真 且 两个条件为真 就是真 一个假就是假 循环语句 while循环 while(条件){ //只要条件为true就执行 //执行语句 } example ： var a = 1 ; while(a&lt;11){ a++; } do while 循环 do{ //语句 }while(条件) //先执行一次 //条件为真 继续运行 条件为假 退出 for 循环 for(var i = 1; i&lt;9 ; i++){ //statement } 函数 如果需要多次使用同一段代码,可以把它们封装成一个函数。函数( function)就是一组允许在你的代码里随时调用的语句。事实上,每个函数实际上是一个短小的脚本。 function(arguments){ //参数 形参 //执行语句 return '' //函数可以返回任意数据类型 包括函数 } 变量作用域 全局变量 局部变量 判断全局还是局部变量需要用var来判断，当函数内部有var的时候，是局部变量，当函数里没有var的时候是全局变量 function get(num){ total = num * num; return total; } var total = 33; var new = get(12); console.log(total) //144 //调用过程中，total市全局变量，并不是局部变量，当函数调用修改的时候total的值也发生了变化 //调整 function get(num){ var total = num * num; return total; } //此时total是get函数的局部变量 对象 对象( object)是一种非常重要的数据类型,但此前我们还没有认真对待它。对象是自包含的数据集合,包含在对象里的数据可以通过两种形式访间—属性( property.)和方法( method): 属性是隶属于某个特定对象的变量;方法是只有某个特定对象才能调用的函数 属性 property 共同调用方法 “.” 隶属于对象的变量 方法 method 隶属于对象的方法 可执行函数 实例对象（instance） function Person(){ this.age = '11' } //实例对象 操作符 new 通过实例化对象 把构造函数的属性和方法挂载到实例对象上 var chenyu = new Person(); console.log(chenyu.age) * 内建对象 * 数组对象Array * 数学对象Math * 日期对象Date * 宿主对象 &gt; 由浏览器提供的预定义对象被成为宿主对象 * document对象 * window对象","link":"/passages/JavaScrip-%E8%AF%AD%E6%B3%95/"},{"title":"JavaScript this","text":"this指向在浏览器环境中，当前的全局this为window对象 this.document === document //true this === window 一般函数的this，指向的是当前全局对象 在浏览器环境中，指向为window对象 function fn(){ return this } fn() === window //true 在nodejs环境中，指向为global对象 在严格模式中，指向为undefined function fn2(){ 'use strict'; return this; } fn2() === undefined 作为对象方法的函数this var o = { props :37 f:function(){ return this.props //此时this指向函数字面量o } } var o = { props : 37 } function fn(){ return this.props; //此时的this指向全局的window对象 } //将函数作为对象的方法，可以获取到该对象 o.f = fn; console.log(o.f()); //37 对象原型链上的this //this指向实例对象 var o = { f:function(){ return this.a + this.b } } var obj = Object.create(o); obj.a = 2; obj.b = 1; obj.f(); // 3 get/set方法上的this function modulus(){ return Math.sqrt(this.re * this.re + this.rm * this.rm) } var o = { re : 2, rm : 2, get phase(){ return Math.atan2(this.rm,this.re) } } Object.defineProperty(o,'modulus',{ get: modulus, enumerable:true, configurable:true }) console.log(o.phase,o.modulus) //都可以取到值 构造函数上的this function Person(){ this.age = '24' } var person1 = new Person(); //此时this指向到构造函数的prototype 此时Person.prototype.age person1.age // 24 此时this指向到实例对象的私有原型 __proto__ 可以直接拿到 //如果函数有return 返回值，切返回值为一个对象并包含该属性，则返回该属性 function Person(){ this.age = '24' return {age:'25'} } var person2 = new Person(); person2.age = 25 call/apply方法与this function add(c,d){ return this.a + this.b + c + d } var o = { a:1, b:2 } add.call(o,3,4) //此时函数上下文this为o, 返回1+2+3+4 add.apply(o,[3,4]) //返回1+2+3+4 function bar(){ console.log(Object.prototype.toString.call(this)) } bar.call(7) // [object number] bind方法与this //bind 绑定 当前的this function person(){ return this.a; } var g = person.bind({a:&quot;test&quot;}) g() // test 通过bind绑定当前的this为一个对象 var o = { a:36, f:peroson, g:g } o.f() // 36 o.g() // test 仍然按照绑定的来走 call / apply 注意事项function show(x,y){ console.log(x,y,this) } show.call(100,1,2) // 1,2,100 show.apply(100,[3,4]) //3,4,100 show.call(null) //undefined undefined window 此时this为全局变量window show.call(undefined) //undefined undefined window 此时this也指向全局变量window //严格模式下 function show(x,y){ 'use strict' console.log(x,y,this) } show.call(null) //undefined undefined null. undefined同理 bind方法注意事项this.x = 20; var module = { x:30, getX:function(){ return this.x } } var getX = module.getX; getX() //20 赋值到变量的时候 此时this指向到全局window对象 var boundGetX = getX.bind(module) boundGetX() // 30 绑定到module this指向module bind与currying//固定某些值，然后个性化改变某几个值 function show(a,b,c){ return a + b + c } var show1 = show.bind(null,2) show1(1,2) // 2 + 1 + 2 固定a，bc个性化设置 var show2 = show1.bind(null,3) show2(5) // 2+3+5 固定ab, c个性化设置 //举例 function getConfig(color,size,otheroptions){ console.log(color,size,otheroptions) } var defineConfig = getConfig(null,'#ffffff','1024*768') //固定两个参数 defineConfig('show') // '#ffffff','1024*768',show defineConfig('hide') //'#ffffff','1024*768',hide bind与newfunction foo(){ this.b = 100 return this.a } var foo1 = foo.bind({a:20}) foo1() //20 new foo() // {b:100} 整个函数作为返回值返回，作为构造函数扔掉返回值，bind作用会被忽略","link":"/passages/JavaScript-this/"},{"title":"JavaScript-DOM","text":"第三章 DOM document 文档 object 对象 model 模型 统称为文档对象模型 节点（node） 元素节点（element node） // div ul li a 文本节点 （text node） // 标签内容 属性节点（attribute）//标签的属性值 href CSS id class 获取元素 getElementById //通过id取得 document对象特有的函数 getElementsByTagName //通过表签名取得 获取到的是一个数组，可遍历，可使用Array对象中的默认属性 //获取全部标签 通配符* document.getElementsByTagName(&quot;*&quot;) //返回所有文档节点obj //获取指定标签内所有的标签 var shop = document.getElementById(&quot;shop&quot;); var allItems = shop.getElementsByTagName(&quot;*&quot;); getElementsByClassName //通过class属性获得 HTML5新增 document.getElementsByClassName(&quot;classname&quot;) //返回是数组 类似于tagname document.getElementsByClassName(&quot;classname1 classname2&quot;) //获取多个classname的标签 //获取指定id下所有特定class标签 var id = document.getElementById(&quot;id&quot;); var innerClass = id.getElementsByClassName(&quot;classname&quot;); //适应老浏览器做法 function getElementsByClassName(node,classname){ if(node.getElementsByClassName){ return node.getElementsByClassName(classname); }else{ var results = []; var allNode = document.getElementsByTagName('*'); for(var i in allNode){ if(allNode[i].className.indexOf(classname) != -1){ results[i] = allNode[i]; } } return results; } } //替换为 var id = document.getElementById(&quot;id&quot;); var innerClass = getElementsByClassName(id，&quot;classname&quot;); 获取和设置属性 获取元素以后，我们可以获取和设置这些元素的属性 获取属性值 obj.getAttribute(属性名) //不能通过document对象调用，只能通过元素节点调用 //获取所有p标签的title属性 var paras = document.getElementsByTagName('p'); var result = []; for(var i in paras){ result[i] = paras[i].getAttribute('title'); } 设置属性值 obj.setAttribute(“属性名”，”属性值”) var para = document.getElementById(&quot;par&quot;); para.setAttribute(&quot;title&quot;,&quot;我是标题&quot;) 这里有一个非常值得关注的细节:通过 setAttribute对文档做出修改后,在通过浏览器的view source(查看源代码)选项去查看文档的源代码时看到的仍将是改变前的属性值,也就是说,setAttribute做出的修改不会反映在文档本身的源代码里。这种“表里不一”的现象源自DOM的工作模式:先加载文档的静态内容,再动态刷新,动态刷新不影响文档的静态内容。这正是DOM的真正威力:对页面内容进行刷新却不需要在浏览器里刷新页面。","link":"/passages/JavaScript-DOM/"},{"title":"JavaScript 函数","text":"函数概念 函数是一块 JavaScript代码,被定义一次,但可执行和调用多次。JS中的函数也是对象,所以JS函数可以像其它对象那样操作和传递，所以我们也常叫JS中的函数为函数对象。 函数创建方法 函数声明 function func(){ //do something } 函数表达式 var func = function(){} //传入匿名函数 使用构造函数 var func = new Function('参数1','参数2','函数内部块'); //等价于 var func = Function() ; 不同创建方法，会有不同差别 //函数声明与函数表达式进行对比 var result = add(1,2) ; console.log(result) //输出3 function add(a,b){ return a+b } //等价于 function add(a,b){ return a+b } var result = add(1,2) ; console.log(result) //输出3 使用函数声明，可以进行函数提升，执行上下文之前，函数声明会提升到前面，可以直接进行调用 var result = add(1,2) console.log(result) //报错,Uncaught TypeError: add is not a function var add = function(a,b){ return a+b } //等价于 var add; //此时add刚刚被定义，值为undefined var result = add(1,2); console.log(result) add = function(a,b){ return a+b } 使用函数表达式创建函数，仅仅会把当前的变量进行提升，并不能对内部的匿名函数进行提升。 var result = add(1,2) console.log(result) //报错,Uncaught TypeError: add is not a function var add = new Function('a','b','return a+b'); //示例 var globalTime = 3; (function(){ var time = 2; var getTime = Function('return time') //undefined，无法访问到函数内部变量，却可以访问到全局变量（globalTime） }) 使用函数构造器构造函数时，函数也不会进行提升，不能访问到函数内部变量，可以访问全局变量。 函数属性与argumentsfunction foo(x,y,z){ arguments.length //实际传入两个形参 那么长度就是2 arguments[0] //返回1 arguments[0]=10 x //打印为10 （严格模式下赋值会失败） arguments[2] = 20 z //打印为20 arguments.callee === foo //arguments下的callee属性指向函数本身（严格模式下不能使用） } foo(1,2) foo.length // 函数的形参3个，所以长度为3 foo.name //名称foo 闭包在函数作用域外，仍然能通过一种形式访问到函数内部的局部变量。 function caller(){ var abc = 111; return abc } caller() ; // 111 此时只有调用函数的时候才能获取到abc的值 function caller(){ var abc = 111; return function(){ return abc; } } var func = caller(); func(); //可以获取到内部变量abc 闭包可以进行封装，灵活方便。但是容易造成空间浪费，内存泄漏，性能消耗等问题。 作用域 全局变量 var i = 0; function func(){ console.log(i) } func(); // 0 for(var j = 1 ; j&lt;6;j++){ } console.log(j) // 1 局部变量 function foo(){ var i = 0; } console.log(i) //undefined //特殊例子 function foo1(){ var i = 0 ; var foo2 = new Function('console.log(i)'); foo2() } foo1() ; // undefined eval() 内部声明的变量 利用函数作用域封装(function(){ })() //or !function(){ }() //变成函数表达式","link":"/passages/JavaScript-%E5%87%BD%E6%95%B0/"},{"title":"JavaScript-图片库","text":"第四章：JavaScript 图片交互&lt;ul&gt; &lt;li&gt;&lt;a href=&quot;images/3840x2160-3122452-creative-wallpapers.jpg&quot; onclick=&quot;showpic(this);return false;&quot;&gt;1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;images/3840x2160-3374593-free-dusk-wallpapers.jpg&quot; onclick=&quot;showpic(this);return false;&quot;&gt;2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;images/3840x2160-3957507-photos-wallpapers.jpg&quot;&gt;3&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;images/3840x2160-4279191-stunning-retina-wallpapers.jpg&quot;&gt;4&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; //占位符 &lt;img src=&quot;images/3840x2160-3122452-creative-wallpapers.jpg&quot; alt=&quot;&quot; id=&quot;placeholder&quot;&gt; function showpic(whichpic){ var imgPlaceholder = document.getElementById(&quot;placeholder&quot;); var nodeSource = whichpic.href; imgPlaceholder.src = nodeSource; } //控制图片href childNodes 属性 //获取一个元素的所有子元素 由 childnodes属性返回的数组包含所有类型的节点,而不仅仅是元素节点。事实上,文档里几乎每一样东西都是一个节点,甚至连空格和换行符都会被解释为节点,而它们也全都包含在childNodes属性所返回的数组当中。 var body_ele = document.getElementsByTagName('body')[0]; var body_all_child = body_ele.childNodes; //获取全部body 下面的子元素 //text元素、ul、img、script等 nodeType属性 //获取元素 节点的属性 body_ele.nodeType; //返回值1:元素节点，2:属性节点，3:文本节点 nodeValue 属性 //获取节点的值 var para = document.getElementById(&quot;paragraph&quot;); console.log(para.nodeValue) //返回值为null //para元素本身的nodeValue属性是空值 //para元素包含很多子元素 console.log(para.childNodes[0].nodeValue) //childNodes 获取当前元素的所有元素信息，第一个是元素的文本信息节点，第二个是元素下挂载的其他元素 firstChild和lastChild 属性 node.firstChild = node.childNodes[0]; node.lastChild = node.childNodes[node.childNodes.length-1]","link":"/passages/JavaScript-%E5%9B%BE%E7%89%87%E5%BA%93/"},{"title":"JavaScript 数组","text":"创建数组 数组是特殊的Object，包含很多方法，创建数组的方法有很多： //数组的创建 var arr = new Array(100) //创建一个长度为100的数组,所有的值都为undefined var arr1 = new Array('1','2',true) //创建一个包含数值和固定下标的字符串 var arr2 = [] //快捷创建一个数组 数组的方法 获取所有的数组方法: Array.prototype 所有在原型链上的方法 john 方法 将数组转换为字符串 var arr = [1,2,3] arr.join('/') //输出&quot;1/2/3“ var arr1 = [1,2,3,undefined]; arr.join('') //输出&quot;123&quot;忽略 undefined //利用join创建一个重复输出的函数 function repeatString(str,n){ return new Array(n+1).join(str) //创建一个n长度的数组，然后join连接符得以重复 } reverse方法 将数组顺序颠倒 var arr = [1,2,3] arr.reverse() //输出[3,2,1] 会修改原数组 sort方法 将数组排序 var arr = [15,22,17,58] arr.sort(); // 15,17,22,58 var arr1 = [13,24,3,58] arr1.sort(); // 13,24,3,58 并没有按照实际的数字大小进行排序，因为sort方法先将其转换为字符串然后进行排序，解决方法： var arr1 = [13,24,3,58]; arr1.sort(function(a,b){return a-b }) //根据大小排列 var items = [ { name: 'Edward', value: 21 }, { name: 'Sharpe', value: 37 }, { name: 'And', value: 45 }, { name: 'The', value: -12 }, { name: 'Magnetic' }, { name: 'Zeros', value: 37 } ]; // 根据值的大小排列 items.sort(function (a, b) { return (a.value - b.value) }); concat方法 连接返回一个数组 var arr = [1,2,3] arr.concat(1) // [1,2,3,1] arr.concat([10,11],12) // [1,2,3,10,11,12]拉平数组一次 arr.concat([10,11,[12,13]]) // [1,2,3,10,11,[12,13]] 只能拉平数组一次不能多次拉平 slice方法 返回部分数组 var arr = [1,2,3,4,5] arr.slice(1,3) //返回[2,3] 不包含结束的那个字符 arr.slice(1) //[2,3,4,5] arr.slice(1,-1) //[2,3,4] 从索引位置到最后一个的索引 不包含最后一个字符 arr.slice(-4,-3) // [2] splice方法 数组精简、指定位置增加 var arr = [1,2,3,4,5] arr.splice(1,1) arr //[1,3,4,5] 从第二个字符开始删除一个 arr.splice(2,2) arr //[1,2,5] 从第三个字符上开始删除两个 arr.splice(1,1,'a','b') arr //[1,'a','b',3,4,5] //从第二个索引删除一个，然后插入后续的值 ES5 方法：forEach方法，遍历数组 并不会修改当前数组 var arr = [1,2,3,4,5] arr.forEach(function(x,index,a){ //三个参数：x数组的值，index数组的索引，a数组本体 console.log(x+'|'+index+'|'+ (a === arr) ) }) ES5方法：map方法，遍历并返回一个数组 var arr = [1,2,3,4,5] var arr1 = arr.map(function(x){ return x * 2 }) arr1 //[2,4,6,8,10] var kvArray = [{key: 1, value: 10}, {key: 2, value: 20}, {key: 3, value: 30}]; var newKeyValueArray = kvArray.map(function(obj){ var sObj = {}; sObj[obj.key] = obj.value return sObj }) newKeyValueArray //[{1:10},{2:20},{3:30}] ES5方法：filter方法，接受一个callback，返回一个过滤的数组 var arr = [1,2,3,4,5]; arr.filter(function(x,index){ //接受两个参数x为值，index为索引 return index % 3 === 0 || index &gt; 1 }) // [4] ES5方法：every方法，对数组进行判断，全部符合返回一个boolean数值 ES5方法：some方法，对数组进行判断，符合一个则返回boolean数值 //every方法 var arr = [1,2,3,4,5]; arr.every(function(x){ return x &lt; 10 }) //true 因为全部小于10 arr.every(function(x){ return x &gt; 6 }) //false 因为没有大于6的 //some方法 arr.some(function(x){ return x === 3 }) //true 因为数组里面存在3 arr.some(function(x){ return x &lt;2 }) //true 因为1小于2 ES5方法：reduce方法，对数组相邻的值进行操作 //reduce var arr = [1,2,3,4,5] arr.reduce(function(x,y){ //此时x、y为1、2 第一个参数为索引1的值，第二个参数为索引2的值 return x+y },1) //此时1先作为x，与数组内数字相加，然后从左到右进行累加 reduceRight //顺序改变从右往左 ES5方法：indexOf / lastIndexOf方法，查找数组是否存在该值，如果存在返回当前索引位置，如果没有则返回-1 var arr = [1,2,3,2,1] arr.indexOf(1) //返回索引为0 arr.indexOf(1,2) //从第三个位置开始查找，返回索引为4 arr.indexOf(1,-2) //从倒数第二的位置（2）开始查找，返回索引为4 arr.lastIndexOf(3,-4) //从右往左找，从倒数第四个开始（2），返回索引为2 判断是否为数组 Array.isArray(obj) obj instanceof Array; //是否是数组实例 ({}).toString.apply([]) === “[object Array]” //true 调用对象的toString方法 [].constructor === Array //true 利用构造函数判断","link":"/passages/JavaScript-%E6%95%B0%E7%BB%84/"},{"title":"MacOS 常用快捷键","text":"快捷键是提高效率的捷径不管使用哪一个 App 或者操作系统，掌握快捷键永远提高效率最简单的方法。就像它的名字”shortcuts”一样，它的设计就是为了让你节省时间的捷径。 macOS 系统自带许多有用的快捷键，有全局的也有各个 App 自己的。Mac App 的特色是 Menubar 上的菜单如果是重要操作一般都会带有匹配的快捷键，而且实现起来非常简单。所以 macOS 生态里的快捷键非常统一。用户只需要学习一套快捷键操作，就可以复制到其他 App 里面。 大部分使用 macOS 的读者朋友应该都习惯了相当一部的快捷键，但可能还有些有用的快捷键没有用到。我在写作此文的时候也发现有些快捷键之前都不知道，整理的过程也是我学习的过程。 本文整理 macOS 几个大类的快捷键，希望能对读者朋友们有所帮助。更多主流 App 快捷键大家随时可以通过 Google 关键字: App Name + Shortcuts 或者是 App Name + Cheatsheat 来找到。 一、系统全局类系统自带的快捷键有一部分可以从 System Preferences -&gt; Keyboard -&gt; Shortcuts 里面找到 这里我们介绍几个比较常用到的全局快捷键: Key Action cmd + tab 在已经打开的 App 之间进行切换，按住 shift 可以反向选择 ctrl + left/right 左右切换 Workspace ctrl + up 显示 Mission Control ctrl + down 显示当前 App 所有 Windows option + cmd + l 在 Finder 打开 Downloads 目录 option + cmd + d 显示/隐藏 Dock option + cmd + esc 打开 Force Quit App 列表 shift + option + cmd + esc 直接 Force Quit 当前 App 二、窗口类 Key Action cmd + ` 在当前 App 的多个窗口直接切换 cmd + m 最小化当前窗口 cmd + h 隐藏当前 App cmd + opt + h 隐藏除了当前 App 以外的所有窗口 cmd + ctrl + f 进入/退出最大化 cmd + w 关掉当前窗口或者当前 Tab cmd + opt + w 关掉当前 App 的所有窗口 三、文本编辑操作对于开发者或者文字工作者，每天都在敲键盘打开，能够不用鼠标就完成选择文本、替换文本之类的操作是最好的。以下是文本编辑常用的快捷键: Key Action ctrl + a 跳到当前行的最前面 ctrl + e 跳到当前行的最后面 cmd + left/right 跳转到当前行的开头/结尾 cmd + up/down 跳转到当前文档的最顶部或最底部 cmd + del 删掉当前光标到行首之间的所有文本 shift + up/down/left/right 按住 shift 和上下左右可以选中文本 鼠标点击某处，再按住 shift 点击另外一处 可以直接选中两次点击之间的所有文本 alt + left/right 向左/右跳一个单词 双击鼠标 选中最靠近的一个单词 三击鼠标 选中当前行 文本选择小技巧 当我们按下 shift 之后我们就可以通过上下左右方向键来选择文本。这时候按住 cmd + 方向键的效果就带上了选择效果。比如 cmd + left 本来是跳转到光标所在行的最前面，加上了 shift 就自带了选中效果。 所以如果你想选择当前光标所在的位置到文本最底部，按住 shift + cmd + down 就可以了，非常方便。 这里的文本编辑快捷键是针对通用的文本编辑器而言的，喜欢 Vim/Emacs 的朋友也可以安装对应的插件，实现更加高效的操作。 比如在 Vim 里面，跳转到文档最顶部只需键入 gg 即可。选中当前光标到最顶部则只需 vgg，理论上是要更加省时间的做法。只是学习曲线要高得多，如非码农，一般也用不上。 ##四、截图类操作 Key Action shift + cmd + 3 截当前全屏并存文件到桌面 ctrl + shift + cmd + 3 截当前全屏并保存到剪贴板 shift + cmd + 4 按下后拖拽鼠标选择截图区域，或者按下 space 直接截取当前窗口并保存到文件 ctrl + shift + cmd + 4 按下后拖拽鼠标选择截图区域，或者按下 space 直接截取当前窗口并保存到剪贴板 五、大多数 App 标准快捷键 Key Action cmd + , 打开当前 App 的 Preferences 窗口 cmd + w 关闭当前窗口 cmd + 1/2/3 选中当前第 n 个窗口 ctrl + tab 切换到下一个窗口 shift + ctrl + tab 切换到上一个窗口 cmd + l 在 Safari/Chrome 中直接选中地址栏 cmd + r 在 Safari/Chrome 中刷新当前页 cmd + f 大部分支持搜索的 App 的搜索快捷键 cmd + opt + f VSCode/Sublime 之类的 App 可以支持完整 Workspace 搜索 cmd + t 大部分多 Tab 应用支持以此创建新 Tab cmd + shift + [ 大部分多 Tab 应用支持以此往左切换 tab cmd + shift + [ 大部分多 Tab 应用支持以此往右切换 tab cmd + shift + n 在 Finder 中创建新文件夹 Apple 官方有一份非常详尽的快捷键列表，有兴趣的朋友可以到这里查看: Mac keyboard shortcuts – Apple Support","link":"/passages/MacOS-%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/"},{"title":"JavaScript 动态创建标记","text":"传统创建标记方法 document.write方法 innerHTML属性 DOM方法 createElement 方法 创建元素节点方法：document.createElement(nodeName) //创建一个p元素 var para = document.createElement('p'); //此时p元素是文档碎片(document fragment)游离在文档之外 appendChild方法 添加到某元素的节点树 parent.appendChild(child) //创建一个p元素 var para = document.createElement('p'); var testdiv = document.getELementById(&quot;testdiv&quot;); //添加p元素到testdiv,成为testdiv的一个子元素节点 testdiv.appendChild(para); createTextNode方法 创建一个文本节点 document.createTextNode(“txt”) //创建一个文本节点 var text = document.createTextNode(&quot;hello world&quot;); //创建一个p元素 var para = document.createElement('p'); //添加文本节点到元素节点 para.appendChild(text); Example：创建复杂的示例 //创建 &lt;p&gt; this is &lt;em&gt;my&lt;/em&gt; content. &lt;/p&gt; var para = document.createElement(&quot;p&quot;); var txt1 = document.createTextNode(&quot;this is&quot;); para.appendChild(txt1) var em = document.createElement('em'); var txt2 = document.createTextNode('my'); em.appendChild(txt2) var txt3 = document.createTextNode('content.'); para.appendChild(em) para.appendChild(txt3) 获取body元素 //方法1 document.getElementsByTagName('body')[0] //方法2 document.body 在已有元素前插入一个新元素 insertBefore()方法 新元素newElement，目标元素targetElement，父元素parentElement（目标元素的父元素） parenetElement.insertBefore(newElement,targetElement) ==targetElement.parentNode.indsertBefore(newElement,targetElement) //在父元素内在目标元素前插入 // &lt;div id='demoParent'&gt; &lt;span id='demoChild'&gt; &lt;/span&gt; &lt;/div&gt; var obj = document.createElement('p'); var demoChild = document.getELmentById(&quot;demoChild&quot;); var demoParent = document.getELementById(&quot;demoParent&quot;); demoParent.insertBefore(obj,demoChild) == demoChild.parentNode.insertBefore(obj,demoChild) 在现有的元素后插入一个新元素（DOM未提供） 自制函数insertBefore() function insertBefore(new,target){ var parent = target.parentNode; if(parent.lastChild == target){ parent.appendChild(new) }else{ //目标元素的下一个兄弟元素 target.nextSibling parent.appendChild(new,target.nextSibling); } } *Ajax异步加载页面内容，无需刷新页面 XMLHttpRequest 对象Ajax技术的核心就是XMLHttpRequest对象。这个对象充当着浏览器中的脚本(客户端)与服务器之间的中间人的角色。以往的请求都由浏览器发出,而 JavaScript通过这个对象可以自己发送请求,同时也自己处理响应。","link":"/passages/JavaScript-%E5%8A%A8%E6%80%81%E5%88%9B%E5%BB%BA%E6%A0%87%E8%AE%B0/"},{"title":"JavaScript 图片库改进","text":"平隐退化 在没有javascript支持的情况下，是否网页会出现错误？ JavaScript和HTML分离 剥离页面元素与用户的逻辑操作，提供页面挂钩 Fn-prepareGallery 现在,需要编写一个简短的函数把有关操作关联到onc1ick事件上我将其命名为 prepareGallery。 下面是我想让这个函数完成的工作。口检查当前浏览器是否理解 getElementsBy TagName囗检査当前浏览器是否理解 getelementById。口检查当前网页是否存在一个d为 imagegal lery的元素。口遍历 imagegallery元素中的所有链接。口设置 onclick事件,让它在有关链接被点击时完成以下操作: ■把这个链接作为参数传递给 showPic函数; ■取消链接被点击时的默认行为,不让浏览器打开这个链接 function preparGallery(){ //检查是否支持get if(!document.getElementsByTagName || !document.getElementById){ return false } var imgGallery = document.getELementById(&quot;gallery&quot;); if(!imgGallery){ console.log('浏览器不支持获取id，请启用JavaScript') return false }else{ var aContent = imgGallery.getElementsByTagName('a'); for(var i in aContent){ if(aContent[i].href){ this.click = function(e){ e.preventDefault(); showPic(this) return false } } } } } //启用事件 window.onload = function(){ //fn1 //fn2 ... //fn[n] } //快速添加页面onload事件 function addEventAfterOnload(func){ var wonload = window.onload if(typeof window.onload != 'function'){ window.onload = func; }else{ window.onload = function(){ wonload(); func(); } } } addEventAfterOnload(func1) 三目运算符var result = condition ? result1 : result2 ; //结果为true返回result1 TIPS element.nodeName 返回值为大写字母","link":"/passages/JavaScript-%E5%9B%BE%E7%89%87%E5%BA%93%E6%94%B9%E8%BF%9B/"},{"title":"JavaScript 重要知识点","text":"重点 //赋值 var i = (1,2,3) // i = 3 逗号计算，返回最右 var obj = {x:1,x:2} // obj.x -&gt; 2 ,可以重复命名但返回最后一个 //try catch finally try{ console.error('error1') }catch(err){ console.log(err) } finally{ console.log('finally') } //顺序 抛出错误-&gt; 捕捉错误error1 -&gt;finally try{ try{ console.error(&quot;error2&quot;) }catch(err){ console.log(err) }finally{ console.log('finally2') } } catch(err){ console.log(&quot;outer&quot;,err) }finally{ console.log('finally3') } //顺序 抛出错误error2 -&gt; 捕捉错误error2 -&gt; finally2 -&gt; outer（接收不到err 已经在上个catch捕捉） -&gt; finally3 //删除对象 var person = {age:23,name:&quot;perter&quot;} delete person.age // true delete person['name'] //true person.age // undefined delete person.age //true ！依然返回true但是并不执行 var descriptor = Object.getOwnPropertyDescriptor(Object,'prototype'); descriptor // 获取当前对象的描述属性 -&gt; 读写、配置、枚举 //var 、 function 定义的属性不能被删除 var age = 23 delete age //false function test(){} delete test //false (function test(){ var local = 1; return delete local //false }) (function(){ function test(){} return delete test //false }) //隐式变量定义 oh = 1 delete oh //true //隐式创建类似于在window对象上添加属性 window.oh //1 delete oh == delete window.oh eval('var i = 1'); delete i //true //属性检测 var cat = new Object(); cat.legs = 4; cat.name ='kitty' 'legs' in cat // true 'name' in cat //true 'toString' in cat // in 往上找，一直找到Object.prototype -&gt; null cat.hasOwnProperty('legs') //true cat.hasOwnProperty('toString') //false 因为只是继承原型链上的方法，并不是其对象内部的方法 //用当前存在的对象创建新变量 var existObj = {x:1,y:2,z:3} var newObj = Object.create(existObj); newObj.x //1 如果仅仅想枚举当前对象上的属性 var key for(key in newObj){ if(newObj.hasOwnProperty(key)){ console.log(key) //屏蔽继承原型链上的属性，仅枚举当前对象上的属性。 } } //可/不可枚举 var cat = new Object(); Object.defineProperty(cat,'legs',{enumerable:false,value:4}); cat.x = 1;cat.y=2;cat.z=3; var key; for(key in cat){ console.log(key) //x,y,z 不包含legs 因为legs不能被枚举 } Object.defineProperty(cat,'legs',{enumerable:true}) for(var key in cat){ console.log(key) //legs x , y ,z 可以进行枚举 } //get/set方法 var man = { name:'chenyu', get age(){ return new Date().getFullYear() - 1995 }, set age(val){ console.log(&quot;can't set age&quot; + val) } } GET/SET 与原型链 obj.z //向上查找原型链上的z，在构造函数foo上寻找到z obj.z = 10 //原型链上有get/set方法，赋值时会调用，并不在对象内部创建属性，所以该赋值操作不能被执行，因为无法操作原型链上的方法。 //如何在实例对象上定义z属性？ Object.defineProperty(obj,'z',{value:1,configurable:true}) obj.z //返回1 在实例对象中查找到z为1 delete obj.z ; obj.z //10 创建对象o 定义o的属性x 为1，默认定义为不可写, 创建实例对象 var obj = Object.create(o) 继承o的原型链 实例对象上还是无法修改x 对象，因为x在原型链上为不可写状态 在当前实例对象上再次定义x，并且writable为true，当前obj.x 可都可写 Object.keys(obj) //获取obj的所有键 返回为数组 Object.values(obj) //获取obj的所有数值 返回为数组 //定义多个属性 var o = {} var obj = Object.create(o) Object.defineProperties(obj,{ name:{value:'chen',enmuerable:true}, age:{value:24,enmuerable:true}, salary:{value:7000,enmuerable:true,writable:true}, luck:{ get:function(){ return Math.random() &gt; 0.5 ? &quot;good&quot; : &quot;bad&quot; } }, promote:{ set:function(level){ this.salary *= 1 + level * 0.1 } } }) obj.salary // 7000 obj.promote = 1 obj.salary // 7700 //对象是否可扩展 Object.isExtensible(obj) //判断obj是否是可扩展属性 Object.preventExtensions(obj) //让obj变得不可扩展 Object.seal(obj) //让obj属性变得不可扩展 并且configurable为false Object.isSealed(obj) //判断obj是否密封 Object.freeze(obj) //冻结obj 不可扩展 configurable和writable为false Object.isFrozen(obj) //判断是否被冻结 以上不能改变原型链中的属性 //序列化 JSON.stringify(obj) //转换为字符串 JSON.parse(obj) // 将字符串转换为JavaScript对象 注意以下几点会异常序列化 val: undefined //当值为undefined的时候，不进行序列化转换 a: NaN //值为NaN的时候，直接转换为null //自定义o序列化的过程 var obj = { o:{ o1 : 1, o2 : 2, toJSON:function(){ //toJSON函数名称固定，当序列化的时候执行这个函数，返回一个值 return this.o1 + this.o2 } } } JSON.stringify(obj.o) // o:3 //对象的toString方法 对象的toString方法可以自己定义返回的字符串 当与字符串拼接时，自动转换为字符串类型 当做运算的时，转换为数字。","link":"/passages/JavaScript-%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"title":"【JS高级程序设计】 第二章 使用JavaScript","text":"2.1 “script”元素向 HTML 页面中插入 JavaScript 的主要方法，就是使用&lt;/script&gt;元素。这个元素由 Netscape 创造 并在 Netscape Navigator 2 中首先实现。后来，这个元素被加入到正式的 HTML 规范中。HTML 4.01 为 &lt;/script&gt;定义了下列 6 个属性： async : 可选。表示应该立即下载脚本，但不应妨碍页面中的其他操作，比如下载其他资源或等待加载其他脚本。只对外部脚本文件有效。 charset：可选。表示通过 src 属性指定的代码的字符集。由于大多数浏览器会忽略它的值， 因此这个属性很少有人用。 defer：可选。表示脚本可以延迟到文档完全被解析和显示之后再执行。只对外部脚本文件有效。IE7 及更早版本对嵌入脚本也支持这个属性。 language：已废弃。原来用于表示编写代码使用的脚本语言（如 JavaScript、JavaScript1.2 或 VBScript）。大多数浏览器会忽略这个属性，因此也没有必要再用了。 src：可选。表示包含要执行代码的外部文件。 type：可选。可以看成是 language 的替代属性；表示编写代码使用的脚本语言的内容类型（也称为 MIME 类型）。虽然 text/javascript 和 text/ecmascript 都已经不被推荐使用，但人 们一直以来使用的都还是 text/javascript。实际上，服务器在传送 JavaScript 文件时使用的 MIME 类型通常是 application/x–javascript，但在 type 中设置这个值却可能导致脚本被 忽略。另外，在非IE浏览器中还可以使用以下值：application/javascript 和 application/ecmascript 。 考虑到约定俗成和最大限度的浏览器兼容性， 目前 type 属性的值依旧还是 text/javascript。不过，这个属性并不是必需的，如果没有指定这个属性，则其默认值仍为 text/javascript。 ##2.1.3 异步脚本 HTML5为script元素定义了async属性。同样与 defer 类似，async 只适用于外部脚本文件，并告诉浏览器立即下载文件。但与 defer 不同的是，标记为 async 的脚本并不保证按照指定它们的先后顺序执行。 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Example HTML Page&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; async src=&quot;example1.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; async src=&quot;example2.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 这里放内容 --&gt; &lt;/body&gt; &lt;/html&gt; 第二个脚本可能会在第一个脚本之前执行，因此，需要确认两者没有相互的依赖关系。 指定 async 属性的目的是不让页面等待两个脚本下载和执行，从而异步加载页面其他内容。 为此，建议异步脚本不要在加载期间修改 DOM。 异步脚本一定会在页面的 load 事件前执行，但可能会在 DOMContentLoaded 事件触发之前或之 后执行。支持异步脚本的浏览器有 Firefox 3.6、Safari 5 和 Chrome。 2.2嵌入代码与维护性在 HTML 中嵌入 JavaScript 代码虽然没有问题，但一般认为最好的做法还是尽可能使用外部文件来 包含 JavaScript 代码。不过，并不存在必须使用外部文件的硬性规定，但支持使用外部文件的人多会强 调如下优点。 可维护性：遍及不同 HTML 页面的 JavaScript 会造成维护问题。但把所有 JavaScript 文件都放在 一个文件夹中，维护起来就轻松多了。而且开发人员因此也能够在不触及 HTML 标记的情况下， 集中精力编辑 JavaScript 代码。 可缓存：浏览器能够根据具体的设置缓存链接的所有外部 JavaScript 文件。也就是说，如果有两个 页面都使用同一个文件，那么这个文件只需下载一次。因此，最终结果就是能够加快页面加载的 速度。 适应未来：通过外部文件来包含 JavaScript 无须使用前面提到 XHTML 或注释 hack。HTML 和 XHTML 包含外部文件的语法是相同的。 #2.4&lt;\\noscript&gt;元素 noscript里面内容显示的前提条件： 浏览器不支持脚本 支持脚本但是禁用 //html页面 &lt;noscript&gt; &lt;p&gt;本页面需要浏览器支持（启用）JavaScript。 &lt;/noscript&gt; 2.5小结把 JavaScript 插入到 HTML 页面中要使用&lt;/script&gt;元素。使用这个元素可以把 JavaScript 嵌入到 HTML 页面中，让脚本与标记混合在一起；也可以包含外部的 JavaScript 文件。而我们需要注意的地方有： 在包含外部 JavaScript 文件时，必须将 src 属性设置为指向相应文件的 URL。而这个文件既可 以是与包含它的页面位于同一个服务器上的文件，也可以是其他任何域中的文件。 所有&lt;/script&gt;元素都会按照它们在页面中出现的先后顺序依次被解析。 在不使用 defer 和 async 属性的情况下， 只有在解析完前面 &lt;/script&gt; 元素中的代码之后， 才会开始解析后面 &lt;/script&gt;元素中的代码。 由于浏览器会先解析完不使用 defer 属性的&lt;/script&gt;元素中的代码，然后再解析后面的内容， 所以一般应该把&lt;/script&gt;元素放在页面最后，即主要内容后面，&lt;/body&gt;标签前面。 使用 defer 属性可以让脚本在文档完全呈现之后再执行。延迟脚本总是按照指定它们的顺序执行。 使用 async 属性可以表示当前脚本不必等待其他脚本，也不必阻塞文档呈现。不能保证异步脚本按照它们在页面中出现的顺序执行。 另外，使用&lt;\\noscript&gt;元素可以指定在不支持脚本的浏览器中显示的替代内容。但在启用了脚本的情况下，浏览器不会显示&lt;\\noscript&gt;元素中的任何内容。","link":"/passages/%E3%80%90JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%91%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%9C%A8HTML%E4%B8%AD%E4%BD%BF%E7%94%A8JavaScript/"},{"title":"JavaScript-最佳实践","text":"JavaScript相对独立 与HIML语言相比, JavaScript语言的生存环境的要求要苛刻得多。如果 JavaScript代码不符合语法规定, JavaScript解释器(对Web应用而言就是浏览器)将拒绝执行它们并报错;而浏览器在遇到不符合语法规定的HTML代码时,则会千方百计地将其呈现出来。尽管如此,在如今的Web上还是充斥着质量低劣的 JavaScript代码 JavaScript伪协议 “javascript:” 这个伪协议可以让我们通过一个链接来调用JavaScript函数 &lt;a href=&quot;javascript:popUp()&quot;&gt;示例&lt;/a&gt; 内嵌的事件处理函数&lt;a href=&quot;#&quot; onclick=&quot;popup()&quot;&gt; &lt;/a&gt; 分离JavaScript&lt;a href='#' class=&quot;popup&quot;&gt; &lt;/a&gt; //包装在函数里 利用window.onload 加载页面全部的节点 window.onload = choose(); function choose(){ var popup_class = document.getELementsByClassName('popup'); for(var i in popup_class){ if(popup_class[i].className = 'popup'){ this.click = function(){ //statement } } } } 性能考虑 尽量少访问DOM 尽量减少标记 对获取来的DOM进行存储，防止二次获取 合理放置脚本，脚本合并，减少http请求 压缩脚本，双版本，原版，.min.js版本","link":"/passages/JavaScript-%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"},{"title":"MacOS 常用破解软件","text":"列表更新事件：2019-08-20 软件来源：https://yun.naodai.org/Software/ https://xclient.info/ http://www.macbed.com/ 1、PDF Expert轻松在MAC上完成PDF编辑、阅读、批注、编辑文本、添加照片、填写表单、签署合同、合并PDF文档以及加密保护，只需轻轻点击几下即可，前所未有的体验。 版本号：2.4.23 链接：立即下载 2、CleanMyMac XMac OS X 系统下知名清理软件 CleanMyMac，这种垃圾清理类的软件似乎始终无法上架 Mac App Store，CleanMyMac 3 的宣传力度似乎并不如CleanMyMac 2，想当年 CleanMyMac 2 在MacPaw 网站上得倒计时挂了很久。这次，CleanMyMac 3 作为在 OS X Yosemite 系统下的软件，视觉风格上自然要满足扁平化和简约的设计路线。当然，版本号大升级，也需要拿出一点诚意，增加一些新功能。CleanMyMac 3 优化了清理体验，将复杂的操作和内容隐藏的更好，实际的操作流畅性更好一些。 版本号：4.4.6 链接：立即下载 3、Adobe Zii Adobe系列软件激活工具步骤： 1、下载creative cloud 安装正版Adobe软件 2、退出所有Adobe系列软件 3、运行Zii，点击patch，即可激活 版本号：4.4.2 链接：网盘地址","link":"/passages/MacOS-%E5%B8%B8%E7%94%A8%E7%A0%B4%E8%A7%A3%E8%BD%AF%E4%BB%B6/"},{"title":"原生 JavaScript 的 DOM 操作汇总","text":"​ 原文链接：https://harttle.land/2015/10/01/javascript-dom-api.html 经常有人讲在 IDE 中写 C#、Java 会越来越手残，那么经常用 jQuery 也会让我们忘记 JavaScript 是如何操作 DOM 的。 JavaScript的DOM操作也是面试中的常见问题，尤其是当你需要回答jQuery的性能问题时，便需要再次回到JavaScript DOM API。 什么是 DOM？外行看来前端工程师的工作就是改页面（HTML、CSS），写脚本（JavaScript）。当你意识到你不是在改HTML而是在操作DOM时，你就升级了！ 那么什么是DOM？ MDN: 文档对象模型 (DOM) 是HTML和XML文档的编程接口。它提供了对文档的结构化的表述，并定义了一种方式可以使从程序中对该结构进行访问，从而改变文档的结构，样式和内容。DOM 将文档解析为一个由节点和对象（包含属性和方法的对象）组成的结构集合。简言之，它会将web页面和脚本或程序语言连接起来。 说白了 DOM 就是浏览器为 JavaScript 提供的一系列接口（通过 window.documnet 提供的），通过这些接口我们可以操作web页面。 但DOM并不是编程语言，它是文档对象的模型，该模型是独立于编程语言的。比如我们在Python中也可以操作DOM： import xml.dom.minidom as m doc = m.parse(&quot;C:\\\\Projects\\\\Py\\\\chap1.xml&quot;); doc.nodeName # DOM property of document object; p_list = doc.getElementsByTagName(&quot;para&quot;); 所以Web前端常讲的DOM API (web 或 XML 页面) = DOM + JS (脚本语言) DOM 创建DOM节点（Node）通常对应于一个标签，一个文本，或者一个HTML属性。DOM节点有一个nodeType属性用来表示当前元素的类型，它是一个整数： Element，元素 Attribute，属性 Text，文本 DOM节点创建最常用的便是document.createElement和document.createTextNode方法： var el1 = document.createElement('div'); var el2 = document.createElement('input'); var node = document.createTextNode('hello world!'); DOM 查询元素查询的API返回的的结果是DOM节点或者DOM节点的列表。document提供了两种Query方法： // 返回当前文档中第一个类名为 &quot;myclass&quot; 的元素 var el = document.querySelector(&quot;.myclass&quot;); // 返回一个文档中所有的class为&quot;note&quot;或者 &quot;alert&quot;的div元素 var els = document.querySelectorAll(&quot;div.note, div.alert&quot;); // 获取元素 var el = document.getElementById('xxx'); var els = document.getElementsByClassName('highlight'); var els = document.getElementsByTagName('td'); Element也提供了很多相对于元素的DOM导航方法： // 获取父元素、父节点 var parent = ele.parentElement; var parent = ele.parentNode; // 获取子节点，子节点可以是任何一种节点，可以通过nodeType来判断 var nodes = ele.children; // 查询子元素 var els = ele.getElementsByTagName('td'); var els = ele.getElementsByClassName('highlight'); // 当前元素的第一个/最后一个子元素节点 var el = ele.firstElementChild; var el = ele.lastElementChild; // 下一个/上一个兄弟元素节点 var el = ele.nextElementSibling; var el = ele.previousElementSibling; DOM 更改// 添加、删除子元素 ele.appendChild(el); ele.removeChild(el); // 替换子元素 ele.replaceChild(el1, el2); // 插入子元素 parentElement.insertBefore(newElement, referenceElement); 属性操作// 获取一个{name, value}的数组 var attrs = el.attributes; // 获取、设置属性 var c = el.getAttribute('class'); el.setAttribute('class', 'highlight'); // 判断、移除属性 el.hasAttribute('class'); el.removeAttribute('class'); // 是否有属性设置 el.hasAttributes(); 常见的面试问题innerHTML 与 outerHTML 的区别？DOM 元素的 innerHTML, outerHTML, innerText, outerText 属性的区别也经常被面试官问到， 比如对于这样一个HTML元素：&lt;div&gt;content&lt;br/&gt;&lt;/div&gt;。 innerHTML：内部HTML，content&lt;br/&gt;； outerHTML：外部HTML，&lt;div&gt;content&lt;br/&gt;&lt;/div&gt;； innerText：内部文本，content； outerText：内部文本，content； 上述四个属性不仅可以读取，还可以赋值。outerText 和 innerText 的区别在于 outerText 赋值时会把标签一起赋值掉，另外 xxText 赋值时HTML特殊字符会被转义。 下图来源于：http://walsh.iteye.com/blog/261966 jQuery的html()与innerHTML的区别？jQuery的 .html() 会调用.innerHTML来操作，但是会捕获异常，然后用 .empty(), .append() 重新操作。 这是因为IE8中有些元素的 .innerHTML 是只读的。见：http://stackoverflow.com/questions/3563107/jquery-html-vs-innerhtml","link":"/passages/%E5%8E%9F%E7%94%9F-JavaScript-%E7%9A%84-DOM-%E6%93%8D%E4%BD%9C%E6%B1%87%E6%80%BB/"},{"title":"【JS高级程序设计】第三章 基本概念","text":"3.1语法 区分大小写 不能使用关键字/保留字 统一的命名规则 第一个字符必须是一个字母、下划线（_）或一个美元符号（$）； 其他字符可以是字母、下划线、美元符号或数字。 标识符中的字母也可以包含扩展的 ASCII 或 Unicode 字母字符（如 À 和 Æ），但我们不推荐这样做。 ECMAScript 标识符采用驼峰大小写格式： firstSecond myCar doSomethingImportant 虽然没有谁强制要求必须采用这种格式，但为了与 ECMAScript 内置的函数和对象命名格式保持一 致，可以将其当作一种最佳实践。 注释：单行/多行注释 // or /* */ ECMAScript5 提出严格模式：’use strict’ , 也可在函数内部执行 语句：推荐语句用分号结束 变量： //创建局部变量 function test(){ var msg = '1' } alert(msg) //抛出错误 //创建全局变量 function test(){ msg = '1' } alert(msg) // 1 3.4数据类型 5种简单类型：Undefined、Null、Number、String、Boolean 一种复杂类型：Object 3.4.1 typeof操作符typeof负责检测数据类型，以下为数据检测返回值： “undefined” // 如果这个值未定义 “object” //如果这个值为对象或者Null “number” //如果这个值为数值 “string” //如果这个值为字符串 “boolean” //如果这个值为true/false “function” // 如果这个值为函数 typeof(msg) 注意， typeof 是一个操作符而不是函数，因此例子中的圆括号尽管可以使用，但不是必需的 3.4.2 Undefined类型 undefined 只有一个值就是undefined，在var进行声明未进行赋值的情况下，返回undefined。 var msg ; // 等价与var msg = undefined alert( msg === undefined) //true alert(age) //产生错误 用typeof检测数据类型时，已定义和未定义的都返回undefined var msg; console.log(msg) //undefined console.log(age) //undefined 3.4.3 Null类型 Null 类型是第二个只有一个值的数据类型，这个特殊的值是 null。从逻辑角度来看，null 值表 示一个空对象指针，而这也正是使用 typeof 操作符检测 null 值时会返回”object”的原因 Null类型只有一个值就是null，null对象表示一个空对象指针，在定义一个位置obj的时候就可以使用null进行预定义 var person = null; console.log(typeof person ) //object 通常用来定义一个空对象 实际上，undefined 值是派生自 null 值的，因此 ECMA-262 规定对它们的相等性测试要返回 true： null == undefined //实际上进行了转换 Boolean(null) == Boolean(undefined) //true null常用在初始化一个对象 只要意在保存对象的变量还没有真正保存对象，就应该明确地让该变量保存 null 值。这样做不仅可以 体现 null 作为空对象指针的惯例，而且也有助于进一步区分 null 和 undefined。 3.4.4 Boolean类型值：true / false 区分大小写 所有类型都有一个boolean 的值，转换方式： var msg = 'hello world' var msgBoolean = Boolean(msg) 所有值转换列表： 数据类型 转换为true的值 数量 Boolean true 5 String 任何非空字符串 “” /空字符串 Number 任何非零数字值（包括无穷大） 0和NaN Object 任何对象 null Undefined n/a（not applicable 的缩写“不适用”） undefined 3.4.5 Number类型 浮点数值 由于保存浮点数值需要的内存空间是保存整数值的两倍，因此 ECMAScript 会不失时机地将浮点数值 转换为整数值。显然，如果小数点后面没有跟任何数字，那么这个数值就可以作为整数值来保存。同样 地，如果浮点数值本身表示的就是一个整数（如 1.0），那么该值也会被转换为整数，如下面的例子所示： var floatNum1 = 1.; var floatNum2 = 10.0; // 小数点后面没有数字——解析为 1 // 整数——解析为 10 //指数幂计数法： var count = 3.159e4 //31590 //在默认情况下，ECMASctipt 会将那些小数点后面带有 6个 零以上的浮点数值转换为以 e 表示法表示的数值（例如，0.0000003 会被转换成 3e7）。 console.log(0.1+0.2) //结果为 0.30000000000000004 //永远不要做浮点数相加判断 数值范围 ECMAScript 能够表示的最小数值保 存在 Number.MIN_VALUE 中——在大多数浏览器中，这个值是 5e-324；能够表示的最大数值保存在 Number.MAX_VALUE 中——在大多数浏览器中，这个值是 1.7976931348623157e+308。如果某次计算的 结果得到了一个超出 JavaScript 数值范围的值，那么这个数值将被自动转换成特殊的 Infinity 值。具 体来说，如果这个数值是负数，则会被转换成-Infinity（负无穷），如果这个数值是正数，则会被转 换成 Infinity（正无穷）, 。要想确定一个数值是不是有穷的（换句话说，是不是位于最 小和最大的数值之间），可以使用 isFinite()函数。这个函数在参数位于最小与最大数值之间时会返 回 true，如下面的例子所示： var result = Number.MAX_VALUE + Number.MAX_VALUE; alert(isFinite(result)); //超出范围false NaN 任何涉及NaN的操作都会返回NaN，NaN与自己不相等 检测一个值是否为NaN的函数： isNaN(); 任何涉及 NaN 的操作（例如 NaN/10）都会返回 NaN， 0 / 0 // NaN 8 / 0 //Infinity //使用isNaN()检测是否不是数值 console.log(isNaN(true)) // boolean true自动转换为1,是数字返回false alert(isNaN(NaN));//true alert(isNaN(10));//false（10 是一个数值） alert(isNaN(&quot;10&quot;));//false（可以被转换成数值 10） alert(isNaN(&quot;blue&quot;));//true（不能转换成数值） 数值转换 Number()函数 可转换所有类型 如果是boolean true -&gt;1 / false -&gt;0 数字，简单传入传出 null -&gt; 0 undefined -&gt; NaN（不是数字） 如果字符串中只包含数字（包括前面带正号或负号的情况），则将其转换为十进制数值，即”1” 会变成 1，”123”会变成 123，而”011”会变成 11（注意：前导的零被忽略了） 如果字符串中包含有效的浮点格式，如”1.1”，则将其转换为对应的浮点数值（同样，也会忽 略前导零）； 如果字符串中包含有效的十六进制格式， 例如 “0xf” ， 则将其转换为相同大小的十进制整 数值； 如果字符串是空的（不包含任何字符），则将其转换为 0； 如果字符串中包含除上述格式之外的字符，则将其转换为 NaN。 如果是对象，则调用对象的 valueOf()方法，然后依照前面的规则转换返回的值。如果转换 的结果是 NaN，则调用对象的 toString()方法，然后再次依照前面的规则转换返回的字符 串值。 //示例 Number('hello world') // NaN Number(null) // 0 Number(&quot;011&quot;) // 11 Number(true) // 1 Number(undefined) //NaN parseInt() 函数 由于 Number()函数在转换字符串时比较复杂而且不够合理，因此在处理整数的时候更常用的是 parseInt()函数。parseInt()函数在转换字符串时，更多的是看其是否符合数值模式。 parseInt()会替换掉空格，会忽略前导的0，如果字符串开头为字符则返回NaN。 parseInt(&quot;&quot;) //空字符串返回NaN parseInt(&quot;123abc&quot;) //123 parseInt(&quot;abc123&quot;) //NaN parseInt(‘’,进制) 接收一个进制，按照进制进行转换 parseFloat()函数 只解析10进制的数字，忽略前导的0 3.4.6 String类型 字符串字面量 反斜杠表示转义字符 \\n 换行 \\t 制表 \\b 空格 \\r 回车 \\f 进纸 \\\\ 斜杠 \\' 转义' \\&quot; 转义&quot; \\xnn 以十六进制代码nn表示的一个字符（其中n为0～F）。例如，\\x41表示&quot;A&quot; \\unnnn 以十六进制代码nnnn表示的一个Unicode字符（其中n为0～F）。例如，\\u03a3表示希腊字符Σ 字符串的特点 ECMAScript 中的字符串是不可变的，也就是说，字符串一旦创建，它们的值就不能改变。要改变 某个变量保存的字符串，首先要销毁原来的字符串，然后再用另一个包含新值的字符串填充该变量， 例如： var lang = &quot;Java&quot;; lang = lang + &quot;Script&quot;; 转换字符串 toString()方法，可以接收一个参数─进制 var age = 13; var ageAsString = age.toString(8); // 以8进制处理返回&quot;15&quot; 数值、布尔值、对象和字符串值（没错，每个字符串也都有一个 toString()方法，该方法返回字 符串的一个副本）都有 toString()方法。但 null 和 undefined 值没有这个方法。 String() 方法 如果值有 toString()方法，则调用该方法（没有参数）并返回相应的结果； 如果值是 null，则返回”null”； 如果值是 undefined，则返回”undefined”。 var value1 = 10; var value2 = true; var value3 = null; var value4 ; String(value1) // &quot;10&quot; String(value2) // &quot;true&quot; String(value3) // &quot;null&quot; String(value4) // &quot;undefined&quot; 要把某个值转换为字符串，可以使用加号操作符把它与一个字符 串（””）加在一起。 3.4.7 Object类型ECMAScript 中的对象其实就是一组数据和功能的集合。对象可以通过执行 new 操作符后跟要创建 的对象类型的名称来创建。而创建 Object 类型的实例并为其添加属性和（或）方法，就可以创建自定 义对象， var obj = new Object(); Object 的每个实例都具有下列属性和方法。 constructor：保存着用于创建当前对象的函数。对于前面的例子而言，构造函数（constructor） 就是 Object()。 hasOwnProperty(propertyName)：用于检查给定的属性在当前对象实例中（而不是在实例 的原型中）是否存在。其中，作为参数的属性名（propertyName）必须以字符串形式指定（例 如：o.hasOwnProperty(“name”)）。 isPrototypeOf(object)：用于检查传入的对象是否是传入对象的原型。 propertyIsEnumerable(propertyName)：用于检查给定的属性是否能够使用 for-in 语句来枚举。与 hasOwnProperty()方法一样，作为参数的属性名必须以字符串形式指定。 toLocaleString()：返回对象的字符串表示，该字符串与执行环境的地区对应。 toString()：返回对象的字符串表示。 valueOf() ：返回对象的字符串、数值或布尔值表示。 通常与 toString() 方法的返回值相同。 3.5 操作符ECMA-262 描述了一组用于操作数据值的操作符，包括算术操作符（如加号和减号）、位操作符、 关系操作符和相等操作符。ECMAScript 操作符的与众不同之处在于，它们能够适用于很多值，例如字 符串、数字值、布尔值，甚至对象。不过，在应用于对象时，相应的操作符通常都会调用对象的 valueOf() 和（或）toString()方法，以便取得可以操作的值。 3.5.1 一元操作符只能操作一个值的操作符叫做一元操作符。一元操作符是 ECMAScript 中最简单的操作符。 前置递增和递减操作 ++ / – ++ age ; -- age; //执行前置递增和递减操作时，变量的值都是在语句被求值以前改变的。（在计算机科学领域，这种 情况通常被称作副效应。） var age = 29 ; var anotherAge = --age + 2; //输出 age 28 anotherAge 30 //由于前置递增和递减操作与执行语句的优先级相等，因此整个语句会从左至右被求值 var num1 = 2;var num2 = 20; var num3 = –num1 + num2; //21var num4 = num1 + num2; //21 &gt; 加号/减号在前，先计算值，然后再计算表达式，值先增加/减少 &gt; &gt; 加号/减号在后，先计算表达式，然后再计算值，值后增加/减少 * 后置递增和递减操作 ```js var num1 = 2 var num2 = 20 var total = num1 ++ +num2 // 22 num1 //3 var total = num1 -- +num2 // 23 num1 //2 在应用于不同的值时，递增和递减操作符遵循下列规则: 在应用于一个包含有效数字字符的字符串时，先将其转换为数字值，再执行加减 1 的操作。字 符串变量变成数值变量。 在应用于一个不包含有效数字字符的字符串时，将变量的值设置为 NaN 字符串变量变成数值变量。 在应用于布尔值 false 时，先将其转换为 0 再执行加减 1 的操作。布尔值变量变成数值变量。 在应用于布尔值 true 时，先将其转换为 1 再执行加减 1 的操作。布尔值变量变成数值变量。 在应用于浮点数值时，执行加减 1 的操作。 在应用于对象时，先调用对象的 valueOf()方法以取得一个可供操作的 值。然后对该值应用前述规则。如果结果是 NaN，则在调用 toString()方法后再应用前述规 则。对象变量变成数值变量。 市例: var a = &quot;1&quot; a ++ // 1 a //2 typeof a // number var b = &quot;str&quot; b ++ // NaN b //NaN typeof b //number var c = false c++ // 0 c // 1 typeof c // number var d = true d++ // 1 d // 2 typeof d //number var e = 1.1 e ++ // 1.1 e // 2.1 typeof e // number var o = { valueOf : function(){ return 1 } } o ++ // 1 o // 2 typeof o // number 3.5.2 位操作符对于有符号的整数，32 位中的前 31 位用于表示整数的值。第 32 位用于表示数值的符号：0 表示正 数，1 表示负数。这个表示符号的位叫做符号位，符号位的值决定了其他位数值的格式。其中，正数以 纯二进制格式存储，31 位中的每一位都表示 2 的幂。第一位（叫做位 0）表示 2 0 ，第二位表示 2 1 ，以此 类 推 。 没 有 用 到 的 位 以 0 填 充 ， 即 忽 略 不 计 。 例 如 ， 数 值 18 的 二 进 制 表 示 是 00000000000000000000000000010010，或者更简洁的 10010。这是 5 个有效位，这 5 位本身就决定了实 际的值 var num = -18 num.toString(2) // &quot;-10010&quot; 按位非（NOT） 按位非操作符由一个波浪线（~）表示， 执行按位非的结果就是返回数值的反码 看不下去了，用到再补内容吧 3.5.3布尔操作符布尔操作符一共有 3 个：非（NOT）、与（AND）和或（OR） 逻辑非 逻辑非操作符由一个叹号（！）表示，可以应用于 ECMAScript 中的任何值。无论这个值是什么数据 类型，这个操作符都会返回一个布尔值。逻辑非操作符首先会将它的操作数转换为一个布尔值，然后再 对其求反。也就是说，逻辑非操作符遵循下列规则： 如果操作数是一个对象，返回 false；!{}//false 如果操作数是一个空字符串，返回 true；!&quot;&quot;//true 如果操作数是一个非空字符串，返回 false； !&quot;1&quot;//false 如果操作数是数值 0，返回 true；!0 //true 如果操作数是任意非 0 数值（包括 Infinity），返回 false；!2 //false !infinity //false 如果操作数是 null，返回 true； !null //true 如果操作数是 NaN，返回 true； !NaN //true 如果操作数是 undefined，返回 true。!undefined //true 双 !! 实际作用与 Boolean() 函数相当 逻辑与（短路操作符） 逻辑与操作符由两个和号（&amp;&amp;）表示，有两个操作数 var result = true &amp;&amp; false; 如果第一个操作数是对象，则返回第二个操作数 如果第二个操作数是对象， 则只有在第一个操作数的求值结果为 true 的情况下才会返回该 对象 如果两个操作数都是对象，则返回第二个操作数； 如果有一个操作数是 null，则返回 null； 如果有一个操作数是 NaN，则返回 NaN； 如果有一个操作数是 undefined，则返回 undefined。 逻辑与操作属于短路操作，即如果第一个操作数能够决定结果，那么就不会再对第二个操作数求值。 对于逻辑与操作而言，如果第一个操作数是 false，则无论第二个操作数是什么值，结果都不再可能是 true 了。 var found = true; var result = (found &amp;&amp; someUndefinedVariable); // 这里会发生错误 alert(result); // 这一行不会执行 在上面的代码中，当执行逻辑与操作时会发生错误，因为变量 someUndefinedVariable 没有声 明。由于变量 found 的值是 true，所以逻辑与操作符会继续对变量 someUndefinedVariable 求值。 但 someUndefinedVariable 尚未定义，因此就会导致错误。 逻辑或 逻辑或操作符由两个竖线符号（||）表示，有两个操作数 var result = true || false; 如果第一个操作数是对象，则返回第一个操作数； 如果第一个操作数的求值结果为 false，则返回第二个操作数 如果两个操作数都是对象，则返回第一个操作数 如果两个操作数都是 null，则返回 null 如果两个操作数都是 NaN，则返回 NaN； 如果两个操作数都是 undefined，则返回 undefined。 我们可以利用逻辑或的这一行为来避免为变量赋 null 或 undefined 值。 var a =value1 || value2 当value1 有值的时候赋值给a，如果value1 为false 则 赋值value2 3.5.4乘性操作符ECMAScript 定义了 3 个乘性操作符：乘法、除法和求模。这些操作符与 Java、C 或者 Perl 中的相 应操作符用途类似，只不过在操作数为非数值的情况下会执行自动的类型转换。如果参与乘性计算的某 个操作数不是数值，后台会先使用 Number()转型函数将其转换为数值。也就是说，空字符串将被当作 0，布尔值 true 将被当作 1。 乘法 var a = 35*20 如果操作数都是数值，执行常规的乘法计算，即两个正数或两个负数相乘的结果还是正数，而 如果只有一个操作数有符号，那么结果就是负数。如果乘积超过了 ECMAScript 数值的表示范围， 则返回 Infinity 或-Infinity； 如果有一个操作数是 NaN，则结果是 NaN； 如果是 Infinity 与 0 相乘，则结果是 NaN； 如果是 Infinity 与非 0 数值相乘，则结果是 Infinity 或-Infinity，取决于有符号操作数 的符号； 如果是 Infinity 与 Infinity 相乘，则结果是 Infinity 如果有一个操作数不是数值， 则在后台调用 Number() 将其转换为数值， 然后再应用上面的 规则 除法 如果操作数都是数值，执行常规的除法计算，即两个正数或两个负数相除的结果还是正数，而 如果只有一个操作数有符号，那么结果就是负数。如果商超过了 ECMAScript 数值的表示范围， 则返回 Infinity 或-Infinity； 如果有一个操作数是 NaN，则结果是 NaN； 如果是 Infinity 被 Infinity 除，则结果是 NaN 如果是零被零除，则结果是 NaN 如果是非零的有限数除以零，则结果是 Infinity 或-Infinity，取决于有符号操作数的符号 如果是 Infinity 被任何非零数值除，则结果是 Infinity 或-Infinity，取决于有符号操作 如果有一个操作数不是数值，则在后台调用 Number()将其转换为数值，然后再应用上面的规则 Infinity / 9 值为Infinity 9 / Infinity 值为0 求模 求模（余数）操作符由一个百分号（%）表示 var result = 26 % 5 //1 3.5.5 加性操作符 加法（➕） 如果两个操作符都是数值，执行常规的加法计算，然后根据下列规则返回结果: 如果有一个操作数是 NaN，则结果是 NaN 如果是 Infinity 加-Infinity，则结果是 NaN 如果是 Infinity 加 Infinity，则结果是 Infinity 如果是 -Infinity 加 -Infinity，则结果是 -Infinity 如果是+0 加+0，则结果是+0 如果是-0 加-0，则结果是-0 如果是+0 加-0，则结果是+0 对于字符串来说： 如果两个操作数都是字符串，则将第二个操作数与第一个操作数拼接起来； 如果只有一个操作数是字符串， 则将另一个操作数转换为字符串， 然后再将两个字符串拼接起来 对于对象、数值、布尔值： 如果有一个操作数是对象、数值或布尔值，则调用它们的 toString()方法取得相应的字符串值， 然后再应用前面关于字符串的规则。对于 undefined 和 null，则分别调用 String()函数并取得字符 串”undefined”和”null” var result = 5 + '5' //55 减法 （跳过） 3.5.6 关系操作符小于（&lt;）、大于（&gt;）、小于等于（&lt;=）和大于等于（&gt;=）这几个关系操作符用于对两个值进行比 较，比较的规则与我们在数学课上所学的一样。这几个操作符都返回一个布尔值 如果两个操作数都是数值，则执行数值比较 如果两个操作数都是字符串，则比较两个字符串对应的字符编码值 如果一个操作数是数值，则将另一个操作数转换为一个数值，然后执行数值比较 如果一个操作数是对象，则调用这个对象的 valueOf()方法，用得到的结果按照前面的规则执 行比较。如果对象没有 valueOf()方法，则调用 toString()方法，并用得到的结果根据前面 的规则执行比较 如果一个操作数是布尔值，则先将其转换为数值，然后再执行比较 var result = &quot;Brick&quot; &lt; &quot;alphabet&quot;;//true 在这个例子中，字符串”Brick”被认为小于字符串”alphabet”。原因是字母 B 的字符编码为 66， 而字母 a 的字符编码是 97。如果要真正按字母表顺序比较字符串，就必须把两个操作数转换为相同的大 小写形式（全部大写或全部小写），然后再执行比较， 另一种奇怪的现象发生在比较两个数字字符串的情况下： var result = &quot;23&quot; &lt; &quot;3&quot;; 结果为true 这是因为两个操作数都是字符串， 而字符串比较的是字符编码（”2”的字符编码是 50，而”3”的字符编码是 51） var result = &quot;23&quot; &lt; 3; 结果为false 因为字符串23转换为了数值 var result = 3 &gt; 'a' 结果为false 因为字符串a被转换成了 NaN，任何与NaN作比较都为false var result = NaN &lt; 3 //false var result = NaN &gt;= 3 //false var result = NaN == NaN //false 3.5.7 相等操作符 相等和不相等 == != 这两个操作符 都会把值进行强制转换，然后再比较他们的相等性 遵循以下规则： 如果操作数有布尔值，则转换为数值，false转为0，true转为1 如果一个操作数是字符串，另一个操作数是数值，在比较相等性之前先将字符串转换为数值 如果一个操作数是对象，另一个操作数不是，则调用对象的 valueOf()方法，用得到的基本类 型值按照前面的规则进行比较 null 和 undefined 是相等的 要比较相等性之前，不能将 null 和 undefined 转换成其他任何值 如果有一个操作数是 NaN，则相等操作符返回 false，而不相等操作符返回 true。重要提示： 即使两个操作数都是 NaN，相等操作符也返回 false；因为按照规则，NaN 不等于 NaN 如果两个操作数都是对象，则比较它们是不是同一个对象。如果两个操作数都指向同一个对象， 则相等操作符返回 true；否则，返回 false 全等和不全等 除了在比较之前不转换操作数之外，全等和不全等操作符与相等和不相等操作符没有什么区别。全 等操作符由 3 个等于号（===）表示，它只在两个操作数未经转换就相等的情况下返回 true 55 === '55' //false 因为是两个不同类型的值 一个是数值，一个是字符串 undefined == null // true undefined === null //false 因为是不同类型的值，undefined值为undefined，null的值为null 3.5.8 条件操作符三目运算符 var result = 条件1 ? 答案1 : 答案2 3.5.9 赋值操作符基础： = 扩展：*= += -= %= /= 3.5.10 逗号操作符使用逗号操作符可以在一条语句中执行多个操作 var num1=1, num2=2, num3=3; 逗号操作符多用于声明多个变量；但除此之外，逗号操作符还可以用于赋值。在用于赋值时，逗号 操作符总会返回表达式中的最后一项 var num = (5, 1, 4, 8, 0); // num 的值为 0 取最后一项 3.6语句3.6.1 if语句if (condition) statement1 else statement2 3.6.2 do-while 语句do-while 语句是一种后测试循环语句，即只有在循环体中的代码执行之后，才会测试出口条件。 换句话说，在对条件表达式求值之前，循环体内的代码至少会被执行一次。 do {statement} while (expression); //while里面的条件必须为true才能循环 3.6.3 while 语句while(expression) statement 3.6.4 for 语句for (initialization; expression; post-loop-expression) statement 此外，for 语句中的初始化表达式、控制表达式和循环后表达式都是可选的。将这三个表达式全部 省略，就会创建一个无限循环 for (;;) { doSomething(); }// 无限循环 3.6.5 for-in语句for (property in expression) statement 3.6.6 label 语句使用 label 语句可以在代码中添加标签，以便将来使用。 label: statement start: for (var i=0; i &lt; count; i++) { alert(i); } //这个例子中定义的 start 标签可以在将来由 break 或 continue 语句引用。加标签的语句一般都 要与 for 语句等循环语句配合使用。 let str = &quot;&quot;; loop1: for (let i = 0; i &lt; 5; i++) { if (i === 1) { continue loop1; } str = str + i; } console.log(str); // expected output: &quot;0234&quot; 3.6.7 break和continue语句break 和 continue 语句用于在循环中精确地控制代码的执行。其中，break 语句会立即退出循环， 强制继续执行循环后面的语句。而 continue 语句虽然也是立即退出循环，但退出循环后会从循环的顶 部继续执行。 break：跳出循环 continue：退出循环，从循环的顶部继续执行 break 和 continue 语句都可以与 label 语句联合使用，从而返回代码中特定的位置。这种联合 使用的情况多发生在循环嵌套的情况下 3.6.8 with语句with 语句的作用是将代码的作用域设置到一个特定的对象中 with (expression) statement; 由于大量使用 with 语句会导致性能下降，同时也会给调试代码造成困难，因此 在开发大型应用程序时，不建议使用 with 语句 3.6.9 switch 语句var a = 1 switch(a){ case 1 : //do something break; case 2 : //do something break; }; //合并两种情形 switch(a){ case 1: case 2: //命中1或者2时 需要执行的代码 break; default: //do something 默认不命中的时候执行 } switch 语句中的每一种情形（case）的含义是：“如果表达式等于这个值（value），则执行后面的 语句（statement）”。而 break 关键字会导致代码执行流跳出 switch 语句。如果省略 break 关键字， 就会导致执行完当前 case 后，继续执行下一个 case。最后的 default 关键字则用于在表达式不匹配前 面任何一种情形的时候，执行机动代码（因此，也相当于一个 else 语句） switch 语句在比较值时使用的是全等操作符，因此不会发生类型转换（例如， 字符串”10”不等于数值 10） 3.7 函数函数对任何语言来说都是一个核心的概念。通过函数可以封装任意多条语句，而且可以在任何地方、 任何时候调用执行。ECMAScript 中的函数使用 function 关键字来声明，后跟一组参数以及函数体。 function functionName(arg0, arg1,...,argN) { statements } function name(){ return //返回一个值 alert(&quot;test&quot;) //不会被执行，因为已经有返回值 } //这个函数会在执行完 return 语句之后停止并立即退出。因此，位于 return 语句之后的任何代码 都永远不会执行。 3.7.1 理解函数ECMAScript 函数的参数与大多数其他语言中函数的参数有所不同。ECMAScript 函数不介意传递进 来多少个参数，也不在乎传进来参数是什么数据类型。也就是说，即便你定义的函数只接收两个参数， 在调用这个函数时也未必一定要传递两个参数。可以传递一个、三个甚至不传递参数，而解析器永远不 会有什么怨言。之所以会这样，原因是 ECMAScript 中的参数在内部是用一个数组来表示的。函数接收 到的始终都是这个数组，而不关心数组中包含哪些参数（如果有参数的话）。如果这个数组中不包含任 何元素，无所谓；如果包含多个元素，也没有问题。实际上，在函数体内可以通过 arguments 对象来 访问这个参数数组，从而获取传递给函数的每一个参数。 关于 arguments 的行为，还有一点比较有意思。那就是它的值永远与对应命名参数的值保持同步。 function doAdd(num1, num2) { arguments[1] = 10; alert(arguments[0] + num2); } 每次执行这个 doAdd()函数都会重写第二个参数，将第二个参数的值修改为 10。因为 arguments 对象中的值会自动反映到对应的命名参数，所以修改 arguments[1]，也就修改了 num2，结果它们的 值都会变成 10。不过，这并不是说读取这两个值会访问相同的内存空间；它们的内存空间是独立的，但 它们的值会同步。另外还要记住，如果只传入了一个参数，那么为 arguments[1]设置的值不会反应到 命名参数中。这是因为 arguments 对象的长度是由传入的参数个数决定的，不是由定义函数时的命名 参数的个数决定的。 关于参数还要记住最后一点：没有传递值的命名参数将自动被赋予 undefined 值。这就跟定义了 变量但又没有初始化一样。 例如， 如果只给 doAdd() 函数传递了一个参数， 则 num2 中就会保存 undefined 值。 严格模式对如何使用 arguments 对象做出了一些限制。首先，像前面例子中那样的赋值会变得无 效。 也就是说， 即使把 arguments[1] 设置为 10 ， num2 的值仍然还是 undefined 。 其次， 重写 arguments 的值会导致语法错误（代码将不会执行）。 ECMAScript 中的所有参数传递的都是值，不可能通过引用传递参数。 3.7.2 没有重载ECMAScript 函数不能像传统意义上那样实现重载。而在其他语言（如 Java）中，可以为一个函数 编写两个定义，只要这两个定义的签名（接受的参数的类型和数量）不同即可。如前所述，ECMAScirpt 函数没有签名，因为其参数是由包含零或多个值的数组来表示的。而没有函数签名，真正的重载是不可 能做到的。 如果在 ECMAScript 中定义了两个名字相同的函数，则该名字只属于后定义的函数 function addSomeNumber(num){ return num + 100; } function addSomeNumber(num) { return num + 200; } var result = addSomeNumber(100);//300","link":"/passages/%E3%80%90JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%91%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"}],"tags":[{"name":"CentOS","slug":"CentOS","link":"/tags/CentOS/"},{"name":"防火墙","slug":"防火墙","link":"/tags/%E9%98%B2%E7%81%AB%E5%A2%99/"},{"name":"端口","slug":"端口","link":"/tags/%E7%AB%AF%E5%8F%A3/"},{"name":"DOM","slug":"DOM","link":"/tags/DOM/"},{"name":"DOM节点操作","slug":"DOM节点操作","link":"/tags/DOM%E8%8A%82%E7%82%B9%E6%93%8D%E4%BD%9C/"},{"name":"javascript-dom-编程艺术","slug":"javascript-dom-编程艺术","link":"/tags/javascript-dom-%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/"},{"name":"DOM结构","slug":"DOM结构","link":"/tags/DOM%E7%BB%93%E6%9E%84/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"this指针","slug":"this指针","link":"/tags/this%E6%8C%87%E9%92%88/"},{"name":"DOM文档对象","slug":"DOM文档对象","link":"/tags/DOM%E6%96%87%E6%A1%A3%E5%AF%B9%E8%B1%A1/"},{"name":"Javascript","slug":"Javascript","link":"/tags/Javascript/"},{"name":"Function","slug":"Function","link":"/tags/Function/"},{"name":"图片库","slug":"图片库","link":"/tags/%E5%9B%BE%E7%89%87%E5%BA%93/"},{"name":"Array","slug":"Array","link":"/tags/Array/"},{"name":"效率","slug":"效率","link":"/tags/%E6%95%88%E7%8E%87/"},{"name":"快捷键","slug":"快捷键","link":"/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/"},{"name":"HTML标记","slug":"HTML标记","link":"/tags/HTML%E6%A0%87%E8%AE%B0/"},{"name":"图片库改进","slug":"图片库改进","link":"/tags/%E5%9B%BE%E7%89%87%E5%BA%93%E6%94%B9%E8%BF%9B/"},{"name":"知识点","slug":"知识点","link":"/tags/%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"name":"JavaScript高级程序设计","slug":"JavaScript高级程序设计","link":"/tags/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"},{"name":"在HTML中使用JavaScript","slug":"在HTML中使用JavaScript","link":"/tags/%E5%9C%A8HTML%E4%B8%AD%E4%BD%BF%E7%94%A8JavaScript/"},{"name":"最佳实践","slug":"最佳实践","link":"/tags/%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"},{"name":"MacOS 常用软件","slug":"MacOS-常用软件","link":"/tags/MacOS-%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/"},{"name":"TNT 破解版","slug":"TNT-破解版","link":"/tags/TNT-%E7%A0%B4%E8%A7%A3%E7%89%88/"},{"name":"DOM操作","slug":"DOM操作","link":"/tags/DOM%E6%93%8D%E4%BD%9C/"},{"name":"JS基本概念","slug":"JS基本概念","link":"/tags/JS%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"}],"categories":[{"name":"centos","slug":"centos","link":"/categories/centos/"},{"name":"javascript","slug":"javascript","link":"/categories/javascript/"},{"name":"macos","slug":"macos","link":"/categories/macos/"}]}