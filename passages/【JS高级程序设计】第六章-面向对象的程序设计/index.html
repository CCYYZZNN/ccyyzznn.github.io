<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="generator" content="Hexo 4.2.0"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>【JS高级程序设计】第六章 面向对象的程序设计 - Matrix</title><meta description="面向对象（Object-Oriented，OO）的语言有一个标志，那就是它们都有类的概念，而通过类可 以创建任意多个具有相同属性和方法的对象。前面提到过，ECMAScript 中没有类的概念，因 此它的对象也与基于类的语言中的对象有所不同。 6.1  理解对象简单创建一个对象 var person &amp;#x3D; new Object() person.name &amp;#x3D; &amp;#39;chenyu&amp;#39; pers"><meta property="og:type" content="blog"><meta property="og:title" content="【JS高级程序设计】第六章 面向对象的程序设计"><meta property="og:url" content="http://timemachine.top/"><meta property="og:site_name" content="Matrix"><meta property="og:description" content="面向对象（Object-Oriented，OO）的语言有一个标志，那就是它们都有类的概念，而通过类可 以创建任意多个具有相同属性和方法的对象。前面提到过，ECMAScript 中没有类的概念，因 此它的对象也与基于类的语言中的对象有所不同。 6.1  理解对象简单创建一个对象 var person &amp;#x3D; new Object() person.name &amp;#x3D; &amp;#39;chenyu&amp;#39; pers"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://s2.ax1x.com/2019/08/19/mlQ5rj.jpg"><meta property="article:published_time" content="2020-04-06T14:04:03.000Z"><meta property="article:modified_time" content="2020-04-23T14:47:55.555Z"><meta property="article:author" content="CCYYZZNN"><meta property="article:tag" content="JavaScript高级程序设计"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://s2.ax1x.com/2019/08/19/mlQ5rj.jpg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://timemachine.top/passages/%E3%80%90JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%91%E7%AC%AC%E5%85%AD%E7%AB%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"},"headline":"Matrix","image":["https://s2.ax1x.com/2019/08/19/mlQ5rj.jpg"],"datePublished":"2020-04-06T14:04:03.000Z","dateModified":"2020-04-23T14:47:55.555Z","author":{"@type":"Person","name":"CCYYZZNN"},"description":"面向对象（Object-Oriented，OO）的语言有一个标志，那就是它们都有类的概念，而通过类可 以创建任意多个具有相同属性和方法的对象。前面提到过，ECMAScript 中没有类的概念，因 此它的对象也与基于类的语言中的对象有所不同。 6.1  理解对象简单创建一个对象 var person &#x3D; new Object() person.name &#x3D; &#39;chenyu&#39; pers"}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="Matrix" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">主页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><div class="card-image"><span class="image is-7by3"><img class="thumbnail" src="https://s2.ax1x.com/2019/08/19/mlQ5rj.jpg" alt="【JS高级程序设计】第六章 面向对象的程序设计"></span></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-04-06T14:04:03.000Z" title="2020-04-06T14:04:03.000Z">2020-04-06</time><span class="level-item"><a class="link-muted" href="/categories/javascript/">javascript</a></span><span class="level-item">38 分钟 读完 (大约 5637 个字)</span><span class="level-item" id="busuanzi_container_page_pv"><i class="far fa-eye"></i>&nbsp;&nbsp;<span id="busuanzi_value_page_pv">0</span>次访问</span></div></div><h1 class="title is-3 is-size-4-mobile">【JS高级程序设计】第六章 面向对象的程序设计</h1><div class="content"><p>面向对象（Object-Oriented，OO）的语言有一个标志，那就是它们都有类的概念，而通过类可 以创建任意多个具有相同属性和方法的对象。前面提到过，ECMAScript 中没有类的概念，因 此它的对象也与基于类的语言中的对象有所不同。</p>
<h1 id="6-1-理解对象"><a href="#6-1-理解对象" class="headerlink" title="6.1  理解对象"></a>6.1  理解对象</h1><p>简单创建一个对象</p>
<pre><code class="js">var person = new Object()
person.name = &#39;chenyu&#39;
person.age = 25
person.sayName = function(){
  return this.name
}</code></pre>
<p>使用字面量创建对象</p>
<pre><code class="js">var person = {
  name: &quot;chenyu&quot;,
  age:25,
  sayName:function(){
    return this.name
  }
}</code></pre>
<h2 id="6-1-1-属性类型"><a href="#6-1-1-属性类型" class="headerlink" title="6.1.1 属性类型"></a>6.1.1 属性类型</h2><p>ECMAScript 中有两种属性：数据属性和访问器属性。</p>
<ol>
<li>数据属性</li>
</ol>
<ul>
<li>[[Configurable]]：表示能否通过 delete 删除属性从而重新定义属性，能否修改属性的特 性，或者能否把属性修改为访问器属性。像前面例子中那样直接在对象上定义的属性，它们的 这个特性默认值为 true。</li>
<li>[[Enumerable]]：表示能否通过 for-in 循环返回属性。像前面例子中那样直接在对象上定 义的属性，它们的这个特性默认值为 true。</li>
<li>[[Writable]]：表示能否修改属性的值。像前面例子中那样直接在对象上定义的属性，它们的 这个特性默认值为 true。</li>
<li>[[Value]]：包含这个属性的数据值。读取属性值的时候，从这个位置读；写入属性值的时候， 把新值保存在这个位置。这个特性的默认值为 undefined。</li>
</ul>
<p>对于像前面例子中那样直接在对象上定义的属性，它们的[[Configurable]]、[[Enumerable]] 和[[Writable]]特性都被设置为 true，而[[Value]]特性被设置为指定的值。</p>
<p>要修改属性默认的特性，必须使用 ECMAScript 5 的 Object.defineProperty()方法。这个方法 接收三个参数：属性所在的对象、属性的名字和一个描述符对象。其中，描述符（descriptor）对象的属 性必须是：configurable、enumerable、writable 和 value。设置其中的一或多个值，可以修改 对应的特性值。</p>
<pre><code class="js">var person = {}
Object.defineProperty(&#39;person&#39;,&#39;name&#39;,{
  value:&quot;chenyu&quot;,
  writable:false
})

person.name // chenyu
person.name = &#39;test&#39; 
person.name // chenyu</code></pre>
<p>类似的规则也适用于不可配置的属性。</p>
<pre><code class="js">var person = {}
Object.defineProperty(&#39;person&#39;,&#39;name&#39;,{
  value:&quot;chenyu&quot;,
  configurable:false
})

person.name // chenyu
person.name = &#39;test&#39; 
delete person.name //false
person.name // chenyu</code></pre>
<p>一旦把属性定义为不可配置的， 就不能再把它变回可配置了。</p>
<p>此时，再调用 Object.defineProperty()方法修改除 writable 之外 的特性，都会导致错误</p>
<blockquote>
<p>在调用 Object.defineProperty() 方法时， 如果不指定， configurable 、 enumerable 和 writable 特性的默认值都是 false。多数情况下，可能都没有必要利用 Object.defineProperty() 方法提供的这些高级功能。不过，理解这些概念对理解 JavaScript 对象却非常有用。</p>
</blockquote>
<ol start="2">
<li>访问器属性</li>
</ol>
<p>访问器属性不包含数据值；它们包含一对儿 getter 和 setter 函数（不过，这两个函数都不是必需的）。 在读取访问器属性时，会调用 getter 函数，这个函数负责返回有效的值；在写入访问器属性时，会调用 setter 函数并传入新值，这个函数负责决定如何处理数据。访问器属性有如下 4 个特性。</p>
<ul>
<li>[[Configurable]]：表示能否通过 delete 删除属性从而重新定义属性，能否修改属性的特 性， 或者能否把属性修改为数据属性。 对于直接在对象上定义的属性， 这个特性的默认值为 true。</li>
<li>[[Enumerable]]：表示能否通过 for-in 循环返回属性。对于直接在对象上定义的属性，这 个特性的默认值为 true。</li>
<li>[[Get]]：在读取属性时调用的函数。默认值为 undefined。</li>
<li>[[Set]]：在写入属性时调用的函数。默认值为 undefined。</li>
</ul>
<pre><code class="js">var book = { _year: 2004, edition: 1 };
Object.defineProperty(book,&#39;year&#39;,{
  get:function(){
    return this._year
  },
  set:function(newValue){
    if(newValue &gt; this._year){
       this._year = newValue
      this.edition += newValue - 2004
       }
  }
})</code></pre>
<p>以上代码创建了一个 book 对象，并给它定义两个默认的属性：_year 和 edition。_year 前面 的下划线是一种常用的记号，用于表示只能通过对象方法访问的属性。而访问器属性 year 则包含一个 getter 函数和一个 setter 函数。getter 函数返回_year 的值，setter 函数通过计算来确定正确的版本。因此， 把 year 属性修改为 2005 会导致_year 变成 2005，而 edition 变为 2。这是使用访问器属性的常见方 式，即设置一个属性的值会导致其他属性发生变化。</p>
<p>不一定非要同时指定 getter 和 setter。只指定 getter 意味着属性是不能写，尝试写入属性会被忽略。 在严格模式下，尝试写入只指定了 getter 函数的属性会抛出错误。类似地，只指定 setter 函数的属性也 不能读，否则在非严格模式下会返回 undefined，而在严格模式下会抛出错误。</p>
<blockquote>
<p>支持 ECMAScript 5 的这个方法的浏览器有 IE9+（IE8 只是部分实现）、Firefox 4+、Safari 5+、Opera 12+ 和 Chrome 。 在 这 个 方 法 之 前 ， 要 创 建 访 问 器 属 性 ， 一 般 都 使 用 两 个 非 标 准 的 方 法 ： __defineGetter__()和__defineSetter__()。这两个方法最初是由 Firefox 引入的，后来 Safari 3、 Chrome 1 和 Opera 9.5 也给出了相同的实现。</p>
</blockquote>
<h2 id="6-1-2-定义多个属性"><a href="#6-1-2-定义多个属性" class="headerlink" title="6.1.2 定义多个属性"></a>6.1.2 定义多个属性</h2><p>由于为对象定义多个属性的可能性很大， ECMAScript 5 又定义了一个 Object.defineProperties()方法。利用这个方法可以通过描述符一次定义多个属性。这个方法接收两个对象参数：第一 个对象是要添加和修改其属性的对象，第二个对象的属性与第一个对象中要添加或修改的属性一一对 应。</p>
<pre><code class="js">var person  = {}
Object.defineProperties(person,{
  _year:{
    value:2004
  },
  edition:{
    value:1
  },
  name:{
    value:&#39;chenyu&#39;,
    configurable:false
  },
  year:{
    get:function(){
      return this._year
    },
    set:function(newValue){
      if(newValue &gt; 2004){
             this._year = newValue,
            this.edition += newValue - 2004
         }
    }
  }
})</code></pre>
<h2 id="6-1-3-读取属性的特性"><a href="#6-1-3-读取属性的特性" class="headerlink" title="6.1.3 读取属性的特性"></a>6.1.3 读取属性的特性</h2><p>使用 ECMAScript 5 的 Object.getOwnPropertyDescriptor()方法，可以取得给定属性的描述符。这个方法接收两个参数：属性所在的对象和要读取其描述符的属性名称。返回值是一个对象，如果 是访问器属性，这个对象的属性有 configurable、enumerable、get 和 set；如果是数据属性，这 个对象的属性有 configurable、enumerable、writable 和 value</p>
<pre><code class="js">var person  = {}
Object.defineProperties(person,{
  _year:{
    value:2004
  },
  edition:{
    value:1
  },
  name:{
    value:&#39;chenyu&#39;,
    configurable:false
  },
  year:{
    get:function(){
      return this._year
    },
    set:function(newValue){
      if(newValue &gt; 2004){
             this._year = newValue,
            this.edition += newValue - 2004
         }
    }
  }
})

var properties = Object.getOwnPropertyDescriptor(book,&#39;name&#39;) 
// {value: &quot;chenyu&quot;, writable: false, enumerable: false, configurable: false}
Object.getOwnPropertyDescriptor(person,&#39;year&#39;)
//{enumerable: false, configurable: false, get: ƒ, set: ƒ}</code></pre>
<h1 id="6-2-创建对象"><a href="#6-2-创建对象" class="headerlink" title="6.2 创建对象"></a>6.2 创建对象</h1><p>虽然 Object 构造函数或对象字面量都可以用来创建单个对象，但这些方式有个明显的缺点：使用同 一个接口创建很多对象，会产生大量的重复代码。为解决这个问题，人们开始使用工厂模式的一种变体。</p>
<h2 id="6-2-1-工厂模式（用于创建出相似的对象）"><a href="#6-2-1-工厂模式（用于创建出相似的对象）" class="headerlink" title="6.2.1 工厂模式（用于创建出相似的对象）"></a>6.2.1 工厂模式（用于创建出相似的对象）</h2><p>工厂模式是软件工程领域一种广为人知的设计模式，这种模式抽象了创建具体对象的过程，考虑到在 ECMAScript 中无法创建类，开发人员 就发明了一种函数，用函数来封装以特定接口创建对象的细节。</p>
<pre><code class="js">function createPerson(name,age,job){
  var o = new Object()
  o.name = name
  o.age = age
  o.job = job
  o.sayName = function(){
    alert(this.name)
  }
  return o
}

var tom = createPerson(&#39;tom&#39;,20,&#39;The engineer&#39;)
var jerry = createPerson(&#39;jerry&#39;,20,&#39;mouse&#39;)</code></pre>
<p>函数 createPerson()能够根据接受的参数来构建一个包含所有必要信息的 Person 对象。可以无 数次地调用这个函数，而每次它都会返回一个包含三个属性一个方法的对象。工厂模式虽然解决了创建 多个相似对象的问题，但却没有解决对象识别的问题（即怎样知道一个对象的类型）。随着 JavaScript 的发展，又一个新模式出现了。</p>
<h2 id="6-2-2-构造函数模式（区别对象的类型）"><a href="#6-2-2-构造函数模式（区别对象的类型）" class="headerlink" title="6.2.2 构造函数模式（区别对象的类型）"></a>6.2.2 构造函数模式（区别对象的类型）</h2><p>上述代码可以改写成：</p>
<pre><code class="js">function Person(name,age,job){
  this.name = name
  this.age = age
  this.job = job
  this.sayName = function(){
    alert(this.name)
  }
}
var tom = new Person(&#39;tom&#39;,20,&#39;The engineer&#39;)
var jerry = new Person(&#39;jerry&#39;,20,&#39;mouse&#39;)</code></pre>
<p>创建了两个实例对象Tom、Jerry，他们都有一个构造函数属性指向构造函数</p>
<pre><code class="js">tom.constructor  == Person
jerry.constructor  == Person</code></pre>
<p>在这个例子中，Person()函数取代了 createPerson()函数。我们注意到，Person()中的代码 除了与 createPerson()中相同的部分外，还存在以下不同之处：</p>
<ul>
<li>没有显式地创建对象；</li>
<li>直接将属性和方法赋给了 this 对象；</li>
<li>没有 return 语句</li>
</ul>
<blockquote>
<p>此外，还应该注意到函数名 Person 使用的是大写字母 P。按照惯例，构造函数始终都应该以一个 大写字母开头，而非构造函数则应该以一个小写字母开头。这个做法借鉴自其他 OO 语言，主要是为了 区别于 ECMAScript 中的其他函数；因为构造函数本身也是函数，只不过可以用来创建对象而已。</p>
</blockquote>
<p>要创建 Person 的新实例，必须使用 new 操作符。以这种方式调用构造函数实际上会经历以下 4 个步骤：</p>
<ol>
<li>创建一个新对象；</li>
<li>将函数的作用域赋值给新对象，当前的this会指向新对象</li>
<li>执行构造函数中的代码（为这个新对象添加属性）；</li>
<li>返回新对象</li>
</ol>
<p>对象的 constructor 属性最初是用来标识对象类型的。但是，提到检测对象类型，还是 instanceof 操作符要更可靠一些。我们在这个例子中创建的所有对象既是 Object 的实例，同时也是 Person 的实例，这一点通过 instanceof 操作符可以得到验证。</p>
<pre><code class="js">tom instanceof Object // true
tom instanceof Person // true
jerry instanceof Object // true
jerry instanceof Person // true</code></pre>
<p>创建自定义的构造函数意味着将来可以将它的实例标识为一种特定的类型；而这正是构造函数模式 胜过工厂模式的地方。在这个例子中，person1 和 person2 之所以同时是 Object 的实例，是因为所 有对象均继承自 Object。</p>
<ol>
<li>将构造函数当作函数</li>
</ol>
<p>构造函数与其他函数的唯一区别，就在于调用它们的方式不同。不过，构造函数毕竟也是函数，不 存在定义构造函数的特殊语法。任何函数，只要通过 new 操作符来调用，那它就可以作为构造函数；而 任何函数，如果不通过 new 操作符来调用，那它跟普通函数也不会有什么两样。例如，前面例子中定义 的 Person()函数可以通过下列任何一种方式来调用。</p>
<pre><code class="js">// 当作构造函数使用
var person = new Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;); 
person.sayName();  //&quot;Nicholas&quot;

//当作普通函数使用
Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;); 
window.name  // Nicholas

//在另一个对象的作用域中调用
var o = new Object
Person.call(o,&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;)
o.name // Nicholas</code></pre>
<p>这个例子中的前两行代码展示了构造函数的典型用法，即使用 new 操作符来创建一个新对象。接下 来的两行代码展示了不使用 new 操作符调用 Person()会出现什么结果：属性和方法都被添加给 window 对象了。有读者可能还记得，当在全局作用域中调用一个函数时，this 对象总是指向 Global 对象（在 浏览器中就是 window 对象）。因此，在调用完函数之后，可以通过 window 对象来调用 sayName()方 法，并且还返回了”Greg”。最后，也可以使用 call()（或者 apply()）在某个特殊对象的作用域中 调用 Person()函数。这里是在对象 o 的作用域中调用的，因此调用后 o 就拥有了所有属性和 sayName() 方法。</p>
<ol start="2">
<li>构造函数的问题</li>
</ol>
<p>构造函数模式虽然好用，但也并非没有缺点。使用构造函数的主要问题，就是每个方法都要在每个 实例上重新创建一遍。在前面的例子中，person1 和 person2 都有一个名为 sayName()的方法，但那 两个方法不是同一个 Function 的实例。不要忘了——ECMAScript 中的函数是对象，因此每定义一个 函数，也就是实例化了一个对象。从逻辑角度讲，此时的构造函数也可以这样定义。</p>
<pre><code class="js">function Person(name, age, job){ this.name = name; this.age = age; this.job = job; this.sayName = new Function(&quot;alert(this.name)&quot;); // 与声明函数在逻辑上是等价的 }</code></pre>
<p>从这个角度上来看构造函数，更容易明白每个 Person 实例都包含一个不同的 Function 实例（以 显示 name 属性）的本质。说明白些，以这种方式创建函数，会导致不同的作用域链和标识符解析，但 创建 Function 新实例的机制仍然是相同的。</p>
<pre><code class="js">tom.sayName == jerry.sayName // false</code></pre>
<pre><code class="js">function Person(name, age, job){ this.name = name; this.age = age; this.job = job; this.sayName = sayName; }
function sayName(){
  alert(this.name)
}
var person1 = new Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;); 
var person2 = new Person(&quot;Greg&quot;, 27, &quot;Doctor&quot;);
person1.sayName == person2.sayName // true</code></pre>
<p>在这个例子中，我们把 sayName()函数的定义转移到了构造函数外部。而在构造函数内部，我们 将 sayName 属性设置成等于全局的 sayName 函数。这样一来，由于 sayName 包含的是一个指向函数 的指针，因此 person1 和 person2 对象就共享了在全局作用域中定义的同一个 sayName()函数。这 样做确实解决了两个函数做同一件事的问题，可是新问题又来了：在全局作用域中定义的函数实际上只 能被某个对象调用，这让全局作用域有点名不副实。而更让人无法接受的是：如果对象需要定义很多方 法，那么就要定义很多个全局函数，于是我们这个自定义的引用类型就丝毫没有封装性可言了。好在， 这些问题可以通过使用原型模式来解决。</p>
<h2 id="6-2-3-原型模式"><a href="#6-2-3-原型模式" class="headerlink" title="6.2.3 原型模式"></a>6.2.3 原型模式</h2><p>我们创建的每个函数都有一个 prototype（原型）属性，这个属性是一个指针，指向一个对象， 而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。如果按照字面意思来理解，那 么 prototype 就是通过调用构造函数而创建的那个对象实例的原型对象。使用原型对象的好处是可以 让所有对象实例共享它所包含的属性和方法。换句话说，不必在构造函数中定义对象实例的信息，而是 可以将这些信息直接添加到原型对象中，如下面的例子所示。</p>
<pre><code class="js">function Person(){ }
Person.prototype.name = &quot;Nicholas&quot;;
Person.prototype.age = 29; 
Person.prototype.job = &quot;Software Engineer&quot;; 
Person.prototype.sayName = function(){ alert(this.name); };
var person1 = new Person(); person1.sayName(); //&quot;Nicholas&quot;
var person2 = new Person();
person2.sayName(); //&quot;Nicholas&quot;
alert(person1.sayName == person2.sayName);//true</code></pre>
<p>在此，我们将 sayName()方法和所有属性直接添加到了 Person 的 prototype 属性中，构造函数 变成了空函数。即使如此，也仍然可以通过调用构造函数来创建新对象，而且新对象还会具有相同的属 性和方法。但与构造函数模式不同的是，新对象的这些属性和方法是由所有实例共享的。换句话说， person1 和 person2 访问的都是同一组属性和同一个 sayName()函数。要理解原型模式的工作原理， 必须先理解 ECMAScript 中原型对象的性质。</p>
<ol>
<li>理解原型对象</li>
</ol>
<p>无论什么时候，只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个 prototype 属性，这个属性指向函数的原型对象。在默认情况下，所有原型对象都会自动获得一个 constructor （构造函数）属性，这个属性包含一个指向 prototype 属性所在函数的指针。就拿前面的例子来说， Person.prototype. constructor 指向 Person。而通过这个构造函数，我们还可继续为原型对象 添加其他属性和方法。</p>
<p>创建了自定义的构造函数之后，其原型对象默认只会取得 constructor 属性；至于其他方法，则 都是从 Object 继承而来的。当调用构造函数创建一个新实例后，该实例的内部将包含一个指针（内部 属性），指向构造函数的原型对象。ECMA-262 第 5 版中管这个指针叫[[Prototype]]。虽然在脚本中 没有标准的方式访问 [[Prototype]] ， 但 Firefox、Safari 和 Chrome 在每个对象上都支持一个属性 <strong>proto</strong>；而在其他实现中，这个属性对脚本则是完全不可见的。<strong><em>不过，要明确的真正重要的一点就 是，这个连接存在于实例与构造函数的原型对象之间，而不是存在于实例与构造函数之间。</em></strong></p>
<p>虽然在所有实现中都无法访问到[[Prototype]]，但可以通过 isPrototypeOf()方法来确定对象之 间是否存在这种关系。 从本质上讲， 如果 [[Prototype]] 指向调用 isPrototypeOf() 方法的对象 （Person.prototype），那么这个方法就返回 true</p>
<pre><code class="js">Person.prototype.isProtytypeOf(person1) //true
Person.prototype.isPrototypeOf(person2) // true</code></pre>
<p>ECMAScript 5 增加了一个新方法，叫 Object.getPrototypeOf()，在所有支持的实现中，这个 方法返回[[Prototype]]的值。例如：</p>
<pre><code class="js">Object.getPrototypeOf(person1) == Person.prototype //true

Object.getPrototypeOf(person1).name //Nicholas</code></pre>
<blockquote>
<p>使用 Object.getPrototypeOf() 可以方便地取得一个对象的原型，而这在利用原型实现继承（本章稍后会讨论）的情况下是非常重要的。</p>
</blockquote>
<p>​    每当代码读取某个对象的某个属性时，都会执行一次搜索，目标是具有给定名字的属性。搜索首先 从对象实例本身开始。如果在实例中找到了具有给定名字的属性，则返回该属性的值；如果没有找到， 则继续搜索指针指向的原型对象，在原型对象中查找具有给定名字的属性。如果在原型对象中找到了这 个属性，则返回该属性的值。也就是说，在我们调用 person1.sayName()的时候，会先后执行两次搜 索。首先，解析器会问：“实例 person1 有 sayName 属性吗？”答：“没有。”然后，它继续搜索，再 问：“person1 的原型有 sayName 属性吗？”答：“有。”于是，它就读取那个保存在原型对象中的函 数。当我们调用 person2.sayName()时，将会重现相同的搜索过程，得到相同的结果。而这正是多个 对象实例共享原型所保存的属性和方法的基本原理。</p>
<blockquote>
<p>前面提到过，原型最初只包含 constructor 属性，而该属性也是共享的，因此 可以通过对象实例访问。</p>
</blockquote>
<p>如果在实例对象中定义的属性名与原型对象中的属性名冲突，则会屏蔽原型对象中的属性值</p>
<pre><code class="js">function Person(){}
Person.prototype,name = &#39;Nicholas&#39;
Person.prototype.age = 20
Person.prototype.sayName = function(){
  return this.name
}

var person1 = new Person()
var person2 = new Person()
person1.name // &#39;Nicholas&#39;
person1.name = &#39;chenyu&#39; 
person1.name // chenyu
person2.name // &#39;Nicholas&#39;</code></pre>
<p>在这个例子中，person1 的 name 被一个新值给屏蔽了。但无论访问 person1.name 还是访问 person2.name 都能够正常地返回值，即分别是”Greg”（来自对象实例）和”Nicholas”（来自原型）。 当在 alert()中访问 person1.name 时，需要读取它的值，因此就会在这个实例上搜索一个名为 name 的属性。这个属性确实存在，于是就返回它的值而不必再搜索原型了。当以同样的方式访问 person2. name 时，并没有在实例上发现该属性，因此就会继续搜索原型，结果在那里找到了 name 属性。</p>
<p>当为对象实例添加一个属性时，这个属性就会屏蔽原型对象中保存的同名属性；换句话说，添加这 个属性只会阻止我们访问原型中的那个属性，但不会修改那个属性。即使将这个属性设置为 null，也 只会在实例中设置这个属性，而不会恢复其指向原型的连接。不过，使用 delete 操作符则可以完全删 除实例属性，从而让我们能够重新访问原型中的属性，</p>
<pre><code class="js">delete person1.name 
person1.name // &quot;Nicholas&quot;</code></pre>
<p>使用 hasOwnProperty()方法可以检测一个属性是存在于实例中，还是存在于原型中。这个方法（不 要忘了它是从 Object 继承来的）只在给定属性存在于对象实例中时，才会返回 true。</p>
<ol start="2">
<li>原型与in操作符</li>
</ol>
<p>当in单独使用时，in 操作符会在通 过对象能够访问给定属性时返回 true，无论该属性存在于实例中还是原型中。</p>
<pre><code class="js"></code></pre>
</div><div class="article-tags size-small is-uppercase mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">JavaScript高级程序设计</a><a class="link-muted mr-2" rel="tag" href="/tags/JS%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/">JS基本概念</a></div><div class="sharethis-inline-share-buttons"></div><script src="https://platform-api.sharethis.com/js/sharethis.js#property=5e880dcb362ea900110ed107&amp;product=inline-share-buttons" defer></script></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/passages/%E3%80%90JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%91%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/"><span class="level-item">【JS高级程序设计】第五章 引用类型</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div class="content" id="valine-thread"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="https://cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js"></script><script>new Valine({
            el: '#valine-thread' ,
            notify: false,
            verify: false,
            appId: 'SeCPf9THzi6bJu0qyj9WSdro-gzGzoHsz',
            appKey: 'n8YuImTKnhgvlQEVT9BuL9AA',
            placeholder: '有问题，请留言',
            avatar: 'mm',
            avatarForce: false,
            meta: ["nick","mail","link"],
            pageSize: 10,
            visitor: false,
            highlight: true,
            recordIP: false
        });</script></div></div></div><!--!--><div class="column column-right is-4-tablet is-4-desktop is-4-widescreen  order-3"><div class="card widget"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="is-rounded" src="https://avatars0.githubusercontent.com/u/29906331?s=460&amp;u=801fa238d3ef38451f6efdb19618e2e6a9125cdc&amp;v=4" alt="麦吹克斯"></figure><p class="title is-size-4 is-block line-height-inherit">麦吹克斯</p><p class="is-size-6 is-block">学习JavaScript，折腾MacOS</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>🌍一个地球</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">20</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">3</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">26</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="http://www.timemachine.top" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/CCYYZZNN"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com/CCYYZZNN"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><!--!--><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/categories/centos/"><span class="level-start"><span class="level-item">centos</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/javascript/"><span class="level-start"><span class="level-item">javascript</span></span><span class="level-end"><span class="level-item tag">17</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/macos/"><span class="level-start"><span class="level-item">macos</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><a class="media-left" href="/passages/%E3%80%90JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%91%E7%AC%AC%E5%85%AD%E7%AB%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"><p class="image is-64x64"><img class="thumbnail" src="https://s2.ax1x.com/2019/08/19/mlQ5rj.jpg" alt="【JS高级程序设计】第六章 面向对象的程序设计"></p></a><div class="media-content size-small"><p><time dateTime="2020-04-06T14:04:03.000Z">2020-04-06</time></p><p class="title is-6"><a class="link-muted" href="/passages/%E3%80%90JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%91%E7%AC%AC%E5%85%AD%E7%AB%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">【JS高级程序设计】第六章 面向对象的程序设计</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/javascript/">javascript</a></p></div></article><article class="media"><a class="media-left" href="/passages/%E3%80%90JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%91%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/"><p class="image is-64x64"><img class="thumbnail" src="https://s2.ax1x.com/2019/08/19/mlQ5rj.jpg" alt="【JS高级程序设计】第五章 引用类型"></p></a><div class="media-content size-small"><p><time dateTime="2020-04-06T14:04:03.000Z">2020-04-06</time></p><p class="title is-6"><a class="link-muted" href="/passages/%E3%80%90JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%91%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/">【JS高级程序设计】第五章 引用类型</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/javascript/">javascript</a></p></div></article><article class="media"><a class="media-left" href="/passages/%E3%80%90JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%91%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%8F%98%E9%87%8F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%86%85%E5%AD%98%E9%97%AE%E9%A2%98/"><p class="image is-64x64"><img class="thumbnail" src="https://s2.ax1x.com/2019/08/19/mlQ5rj.jpg" alt="【JS高级程序设计】第四章 变量、作用域和内存问题"></p></a><div class="media-content size-small"><p><time dateTime="2020-04-05T15:37:18.000Z">2020-04-05</time></p><p class="title is-6"><a class="link-muted" href="/passages/%E3%80%90JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%91%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%8F%98%E9%87%8F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%86%85%E5%AD%98%E9%97%AE%E9%A2%98/">【JS高级程序设计】第四章 变量、作用域和内存问题</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/javascript/">javascript</a></p></div></article><article class="media"><a class="media-left" href="/passages/%E3%80%90JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%91%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"><p class="image is-64x64"><img class="thumbnail" src="https://s2.ax1x.com/2019/08/19/mlQ5rj.jpg" alt="【JS高级程序设计】第三章 基本概念"></p></a><div class="media-content size-small"><p><time dateTime="2020-04-01T13:38:17.000Z">2020-04-01</time></p><p class="title is-6"><a class="link-muted" href="/passages/%E3%80%90JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%91%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/">【JS高级程序设计】第三章 基本概念</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/javascript/">javascript</a></p></div></article><article class="media"><a class="media-left" href="/passages/%E3%80%90JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%91%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%9C%A8HTML%E4%B8%AD%E4%BD%BF%E7%94%A8JavaScript/"><p class="image is-64x64"><img class="thumbnail" src="https://s2.ax1x.com/2019/08/19/mlQ5rj.jpg" alt="【JS高级程序设计】 第二章 使用JavaScript"></p></a><div class="media-content size-small"><p><time dateTime="2020-04-01T09:31:16.000Z">2020-04-01</time></p><p class="title is-6"><a class="link-muted" href="/passages/%E3%80%90JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%91%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%9C%A8HTML%E4%B8%AD%E4%BD%BF%E7%94%A8JavaScript/">【JS高级程序设计】 第二章 使用JavaScript</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/javascript/">javascript</a></p></div></article></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/archives/2020/04/"><span class="level-start"><span class="level-item">四月 2020</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/03/"><span class="level-start"><span class="level-item">三月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/10/"><span class="level-start"><span class="level-item">十月 2019</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/09/"><span class="level-start"><span class="level-item">九月 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/08/"><span class="level-start"><span class="level-item">八月 2019</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Array/"><span class="tag">Array</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CentOS/"><span class="tag">CentOS</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/DOM/"><span class="tag">DOM</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/DOM%E6%93%8D%E4%BD%9C/"><span class="tag">DOM操作</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/DOM%E6%96%87%E6%A1%A3%E5%AF%B9%E8%B1%A1/"><span class="tag">DOM文档对象</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/DOM%E7%BB%93%E6%9E%84/"><span class="tag">DOM结构</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/DOM%E8%8A%82%E7%82%B9%E6%93%8D%E4%BD%9C/"><span class="tag">DOM节点操作</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Function/"><span class="tag">Function</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/HTML%E6%A0%87%E8%AE%B0/"><span class="tag">HTML标记</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/JS%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"><span class="tag">JS基本概念</span><span class="tag is-grey-lightest">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/JavaScript/"><span class="tag">JavaScript</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"><span class="tag">JavaScript高级程序设计</span><span class="tag is-grey-lightest">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Javascript/"><span class="tag">Javascript</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/MacOS-%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/"><span class="tag">MacOS 常用软件</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/TNT-%E7%A0%B4%E8%A7%A3%E7%89%88/"><span class="tag">TNT 破解版</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/javascript-dom-%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/"><span class="tag">javascript-dom-编程艺术</span><span class="tag is-grey-lightest">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/this%E6%8C%87%E9%92%88/"><span class="tag">this指针</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%9B%BE%E7%89%87%E5%BA%93/"><span class="tag">图片库</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%9B%BE%E7%89%87%E5%BA%93%E6%94%B9%E8%BF%9B/"><span class="tag">图片库改进</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%9C%A8HTML%E4%B8%AD%E4%BD%BF%E7%94%A8JavaScript/"><span class="tag">在HTML中使用JavaScript</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/"><span class="tag">快捷键</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%88%E7%8E%87/"><span class="tag">效率</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"><span class="tag">最佳实践</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%9F%A5%E8%AF%86%E7%82%B9/"><span class="tag">知识点</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%AB%AF%E5%8F%A3/"><span class="tag">端口</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%98%B2%E7%81%AB%E5%A2%99/"><span class="tag">防火墙</span><span class="tag is-grey-lightest">1</span></a></div></div></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">订阅更新</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button is-primary" type="submit" value="订阅"></div></div></form></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="Matrix" height="28"></a><p class="size-small"><span>&copy; 2020 CCYYZZNN</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">共<span id="busuanzi_value_site_uv">0</span>个访客</span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            site: {
                url: 'http://timemachine.top',
                external_link: {"enable":true,"exclude":[]}
            },
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>