<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="generator" content="Hexo 4.2.0"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>【JS高级程序设计】第六章 面向对象的程序设计 - Matrix</title><meta description="面向对象（Object-Oriented，OO）的语言有一个标志，那就是它们都有类的概念，而通过类可 以创建任意多个具有相同属性和方法的对象。前面提到过，ECMAScript 中没有类的概念，因 此它的对象也与基于类的语言中的对象有所不同。"><meta property="og:type" content="blog"><meta property="og:title" content="【JS高级程序设计】第六章 面向对象的程序设计"><meta property="og:url" content="http://timemachine.top/"><meta property="og:site_name" content="Matrix"><meta property="og:description" content="面向对象（Object-Oriented，OO）的语言有一个标志，那就是它们都有类的概念，而通过类可 以创建任意多个具有相同属性和方法的对象。前面提到过，ECMAScript 中没有类的概念，因 此它的对象也与基于类的语言中的对象有所不同。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://s2.ax1x.com/2019/08/19/mlQ5rj.jpg"><meta property="article:published_time" content="2020-04-06T14:04:03.000Z"><meta property="article:modified_time" content="2020-04-28T14:24:51.483Z"><meta property="article:author" content="CCYYZZNN"><meta property="article:tag" content="JavaScript高级程序设计"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://s2.ax1x.com/2019/08/19/mlQ5rj.jpg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://timemachine.top/passages/%E3%80%90JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%91%E7%AC%AC%E5%85%AD%E7%AB%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"},"headline":"Matrix","image":["https://s2.ax1x.com/2019/08/19/mlQ5rj.jpg"],"datePublished":"2020-04-06T14:04:03.000Z","dateModified":"2020-04-28T14:24:51.483Z","author":{"@type":"Person","name":"CCYYZZNN"},"description":"面向对象（Object-Oriented，OO）的语言有一个标志，那就是它们都有类的概念，而通过类可 以创建任意多个具有相同属性和方法的对象。前面提到过，ECMAScript 中没有类的概念，因 此它的对象也与基于类的语言中的对象有所不同。"}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="Matrix" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">主页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><div class="card-image"><span class="image is-7by3"><img class="thumbnail" src="https://s2.ax1x.com/2019/08/19/mlQ5rj.jpg" alt="【JS高级程序设计】第六章 面向对象的程序设计"></span></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-04-06T14:04:03.000Z" title="2020-04-06T14:04:03.000Z">2020-04-06</time><span class="level-item"><a class="link-muted" href="/categories/javascript/">javascript</a></span><span class="level-item">2 小时 读完 (大约 14498 个字)</span><span class="level-item" id="busuanzi_container_page_pv"><i class="far fa-eye"></i>&nbsp;&nbsp;<span id="busuanzi_value_page_pv">0</span>次访问</span></div></div><h1 class="title is-3 is-size-4-mobile">【JS高级程序设计】第六章 面向对象的程序设计</h1><div class="content"><p>面向对象（Object-Oriented，OO）的语言有一个标志，那就是它们都有类的概念，而通过类可 以创建任意多个具有相同属性和方法的对象。前面提到过，ECMAScript 中没有类的概念，因 此它的对象也与基于类的语言中的对象有所不同。<a id="more"></a></p>
<h1 id="6-1-理解对象"><a href="#6-1-理解对象" class="headerlink" title="6.1  理解对象"></a>6.1  理解对象</h1><p>简单创建一个对象</p>
<pre><code class="js">var person = new Object()
person.name = &#39;chenyu&#39;
person.age = 25
person.sayName = function(){
  return this.name
}</code></pre>
<p>使用字面量创建对象</p>
<pre><code class="js">var person = {
  name: &quot;chenyu&quot;,
  age:25,
  sayName:function(){
    return this.name
  }
}</code></pre>
<h2 id="6-1-1-属性类型"><a href="#6-1-1-属性类型" class="headerlink" title="6.1.1 属性类型"></a>6.1.1 属性类型</h2><p>ECMAScript 中有两种属性：数据属性和访问器属性。</p>
<ol>
<li>数据属性</li>
</ol>
<ul>
<li>[[Configurable]]：表示能否通过 delete 删除属性从而重新定义属性，能否修改属性的特 性，或者能否把属性修改为访问器属性。像前面例子中那样直接在对象上定义的属性，它们的 这个特性默认值为 true。</li>
<li>[[Enumerable]]：表示能否通过 for-in 循环返回属性。像前面例子中那样直接在对象上定 义的属性，它们的这个特性默认值为 true。</li>
<li>[[Writable]]：表示能否修改属性的值。像前面例子中那样直接在对象上定义的属性，它们的 这个特性默认值为 true。</li>
<li>[[Value]]：包含这个属性的数据值。读取属性值的时候，从这个位置读；写入属性值的时候， 把新值保存在这个位置。这个特性的默认值为 undefined。</li>
</ul>
<p>对于像前面例子中那样直接在对象上定义的属性，它们的[[Configurable]]、[[Enumerable]] 和[[Writable]]特性都被设置为 true，而[[Value]]特性被设置为指定的值。</p>
<p>要修改属性默认的特性，必须使用 ECMAScript 5 的 Object.defineProperty()方法。这个方法 接收三个参数：属性所在的对象、属性的名字和一个描述符对象。其中，描述符（descriptor）对象的属 性必须是：configurable、enumerable、writable 和 value。设置其中的一或多个值，可以修改 对应的特性值。</p>
<pre><code class="js">var person = {}
Object.defineProperty(&#39;person&#39;,&#39;name&#39;,{
  value:&quot;chenyu&quot;,
  writable:false
})

person.name // chenyu
person.name = &#39;test&#39; 
person.name // chenyu</code></pre>
<p>类似的规则也适用于不可配置的属性。</p>
<pre><code class="js">var person = {}
Object.defineProperty(&#39;person&#39;,&#39;name&#39;,{
  value:&quot;chenyu&quot;,
  configurable:false
})

person.name // chenyu
person.name = &#39;test&#39; 
delete person.name //false
person.name // chenyu</code></pre>
<p>一旦把属性定义为不可配置的， 就不能再把它变回可配置了。</p>
<p>此时，再调用 Object.defineProperty()方法修改除 writable 之外 的特性，都会导致错误</p>
<blockquote>
<p>在调用 Object.defineProperty() 方法时， 如果不指定， configurable 、 enumerable 和 writable 特性的默认值都是 false。多数情况下，可能都没有必要利用 Object.defineProperty() 方法提供的这些高级功能。不过，理解这些概念对理解 JavaScript 对象却非常有用。</p>
</blockquote>
<ol start="2">
<li>访问器属性</li>
</ol>
<p>访问器属性不包含数据值；它们包含一对儿 getter 和 setter 函数（不过，这两个函数都不是必需的）。 在读取访问器属性时，会调用 getter 函数，这个函数负责返回有效的值；在写入访问器属性时，会调用 setter 函数并传入新值，这个函数负责决定如何处理数据。访问器属性有如下 4 个特性。</p>
<ul>
<li>[[Configurable]]：表示能否通过 delete 删除属性从而重新定义属性，能否修改属性的特 性， 或者能否把属性修改为数据属性。 对于直接在对象上定义的属性， 这个特性的默认值为 true。</li>
<li>[[Enumerable]]：表示能否通过 for-in 循环返回属性。对于直接在对象上定义的属性，这 个特性的默认值为 true。</li>
<li>[[Get]]：在读取属性时调用的函数。默认值为 undefined。</li>
<li>[[Set]]：在写入属性时调用的函数。默认值为 undefined。</li>
</ul>
<pre><code class="js">var book = { _year: 2004, edition: 1 };
Object.defineProperty(book,&#39;year&#39;,{
  get:function(){
    return this._year
  },
  set:function(newValue){
    if(newValue &gt; this._year){
       this._year = newValue
      this.edition += newValue - 2004
       }
  }
})</code></pre>
<p>以上代码创建了一个 book 对象，并给它定义两个默认的属性：_year 和 edition。_year 前面 的下划线是一种常用的记号，用于表示只能通过对象方法访问的属性。而访问器属性 year 则包含一个 getter 函数和一个 setter 函数。getter 函数返回_year 的值，setter 函数通过计算来确定正确的版本。因此， 把 year 属性修改为 2005 会导致_year 变成 2005，而 edition 变为 2。这是使用访问器属性的常见方 式，即设置一个属性的值会导致其他属性发生变化。</p>
<p>不一定非要同时指定 getter 和 setter。只指定 getter 意味着属性是不能写，尝试写入属性会被忽略。 在严格模式下，尝试写入只指定了 getter 函数的属性会抛出错误。类似地，只指定 setter 函数的属性也 不能读，否则在非严格模式下会返回 undefined，而在严格模式下会抛出错误。</p>
<blockquote>
<p>支持 ECMAScript 5 的这个方法的浏览器有 IE9+（IE8 只是部分实现）、Firefox 4+、Safari 5+、Opera 12+ 和 Chrome 。 在 这 个 方 法 之 前 ， 要 创 建 访 问 器 属 性 ， 一 般 都 使 用 两 个 非 标 准 的 方 法 ： __defineGetter__()和__defineSetter__()。这两个方法最初是由 Firefox 引入的，后来 Safari 3、 Chrome 1 和 Opera 9.5 也给出了相同的实现。</p>
</blockquote>
<h2 id="6-1-2-定义多个属性"><a href="#6-1-2-定义多个属性" class="headerlink" title="6.1.2 定义多个属性"></a>6.1.2 定义多个属性</h2><p>由于为对象定义多个属性的可能性很大， ECMAScript 5 又定义了一个 Object.defineProperties()方法。利用这个方法可以通过描述符一次定义多个属性。这个方法接收两个对象参数：第一 个对象是要添加和修改其属性的对象，第二个对象的属性与第一个对象中要添加或修改的属性一一对 应。</p>
<pre><code class="js">var person  = {}
Object.defineProperties(person,{
  _year:{
    value:2004
  },
  edition:{
    value:1
  },
  name:{
    value:&#39;chenyu&#39;,
    configurable:false
  },
  year:{
    get:function(){
      return this._year
    },
    set:function(newValue){
      if(newValue &gt; 2004){
             this._year = newValue,
            this.edition += newValue - 2004
         }
    }
  }
})</code></pre>
<h2 id="6-1-3-读取属性的特性"><a href="#6-1-3-读取属性的特性" class="headerlink" title="6.1.3 读取属性的特性"></a>6.1.3 读取属性的特性</h2><p>使用 ECMAScript 5 的 Object.getOwnPropertyDescriptor()方法，可以取得给定属性的描述符。这个方法接收两个参数：属性所在的对象和要读取其描述符的属性名称。返回值是一个对象，如果 是访问器属性，这个对象的属性有 configurable、enumerable、get 和 set；如果是数据属性，这 个对象的属性有 configurable、enumerable、writable 和 value</p>
<pre><code class="js">var person  = {}
Object.defineProperties(person,{
  _year:{
    value:2004
  },
  edition:{
    value:1
  },
  name:{
    value:&#39;chenyu&#39;,
    configurable:false
  },
  year:{
    get:function(){
      return this._year
    },
    set:function(newValue){
      if(newValue &gt; 2004){
             this._year = newValue,
            this.edition += newValue - 2004
         }
    }
  }
})

var properties = Object.getOwnPropertyDescriptor(book,&#39;name&#39;) 
// {value: &quot;chenyu&quot;, writable: false, enumerable: false, configurable: false}
Object.getOwnPropertyDescriptor(person,&#39;year&#39;)
//{enumerable: false, configurable: false, get: ƒ, set: ƒ}</code></pre>
<h1 id="6-2-创建对象"><a href="#6-2-创建对象" class="headerlink" title="6.2 创建对象"></a>6.2 创建对象</h1><p>虽然 Object 构造函数或对象字面量都可以用来创建单个对象，但这些方式有个明显的缺点：使用同 一个接口创建很多对象，会产生大量的重复代码。为解决这个问题，人们开始使用工厂模式的一种变体。</p>
<h2 id="6-2-1-工厂模式（用于创建出相似的对象）"><a href="#6-2-1-工厂模式（用于创建出相似的对象）" class="headerlink" title="6.2.1 工厂模式（用于创建出相似的对象）"></a>6.2.1 工厂模式（用于创建出相似的对象）</h2><p>工厂模式是软件工程领域一种广为人知的设计模式，这种模式抽象了创建具体对象的过程，考虑到在 ECMAScript 中无法创建类，开发人员 就发明了一种函数，用函数来封装以特定接口创建对象的细节。</p>
<pre><code class="js">function createPerson(name,age,job){
  var o = new Object()
  o.name = name
  o.age = age
  o.job = job
  o.sayName = function(){
    alert(this.name)
  }
  return o
}

var tom = createPerson(&#39;tom&#39;,20,&#39;The engineer&#39;)
var jerry = createPerson(&#39;jerry&#39;,20,&#39;mouse&#39;)</code></pre>
<p>函数 createPerson()能够根据接受的参数来构建一个包含所有必要信息的 Person 对象。可以无 数次地调用这个函数，而每次它都会返回一个包含三个属性一个方法的对象。工厂模式虽然解决了创建 多个相似对象的问题，但却没有解决对象识别的问题（即怎样知道一个对象的类型）。随着 JavaScript 的发展，又一个新模式出现了。</p>
<h2 id="6-2-2-构造函数模式（区别对象的类型）"><a href="#6-2-2-构造函数模式（区别对象的类型）" class="headerlink" title="6.2.2 构造函数模式（区别对象的类型）"></a>6.2.2 构造函数模式（区别对象的类型）</h2><p>上述代码可以改写成：</p>
<pre><code class="js">function Person(name,age,job){
  this.name = name
  this.age = age
  this.job = job
  this.sayName = function(){
    alert(this.name)
  }
}
var tom = new Person(&#39;tom&#39;,20,&#39;The engineer&#39;)
var jerry = new Person(&#39;jerry&#39;,20,&#39;mouse&#39;)</code></pre>
<p>创建了两个实例对象Tom、Jerry，他们都有一个构造函数属性指向构造函数</p>
<pre><code class="js">tom.constructor  == Person
jerry.constructor  == Person</code></pre>
<p>在这个例子中，Person()函数取代了 createPerson()函数。我们注意到，Person()中的代码 除了与 createPerson()中相同的部分外，还存在以下不同之处：</p>
<ul>
<li>没有显式地创建对象；</li>
<li>直接将属性和方法赋给了 this 对象；</li>
<li>没有 return 语句</li>
</ul>
<blockquote>
<p>此外，还应该注意到函数名 Person 使用的是大写字母 P。按照惯例，构造函数始终都应该以一个 大写字母开头，而非构造函数则应该以一个小写字母开头。这个做法借鉴自其他 OO 语言，主要是为了 区别于 ECMAScript 中的其他函数；因为构造函数本身也是函数，只不过可以用来创建对象而已。</p>
</blockquote>
<p>要创建 Person 的新实例，必须使用 new 操作符。以这种方式调用构造函数实际上会经历以下 4 个步骤：</p>
<ol>
<li>创建一个新对象；</li>
<li>将函数的作用域赋值给新对象，当前的this会指向新对象</li>
<li>执行构造函数中的代码（为这个新对象添加属性）；</li>
<li>返回新对象</li>
</ol>
<p>对象的 constructor 属性最初是用来标识对象类型的。但是，提到检测对象类型，还是 instanceof 操作符要更可靠一些。我们在这个例子中创建的所有对象既是 Object 的实例，同时也是 Person 的实例，这一点通过 instanceof 操作符可以得到验证。</p>
<pre><code class="js">tom instanceof Object // true
tom instanceof Person // true
jerry instanceof Object // true
jerry instanceof Person // true</code></pre>
<p>创建自定义的构造函数意味着将来可以将它的实例标识为一种特定的类型；而这正是构造函数模式 胜过工厂模式的地方。在这个例子中，person1 和 person2 之所以同时是 Object 的实例，是因为所 有对象均继承自 Object。</p>
<ol>
<li>将构造函数当作函数</li>
</ol>
<p>构造函数与其他函数的唯一区别，就在于调用它们的方式不同。不过，构造函数毕竟也是函数，不 存在定义构造函数的特殊语法。任何函数，只要通过 new 操作符来调用，那它就可以作为构造函数；而 任何函数，如果不通过 new 操作符来调用，那它跟普通函数也不会有什么两样。例如，前面例子中定义 的 Person()函数可以通过下列任何一种方式来调用。</p>
<pre><code class="js">// 当作构造函数使用
var person = new Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;); 
person.sayName();  //&quot;Nicholas&quot;

//当作普通函数使用
Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;); 
window.name  // Nicholas

//在另一个对象的作用域中调用
var o = new Object
Person.call(o,&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;)
o.name // Nicholas</code></pre>
<p>这个例子中的前两行代码展示了构造函数的典型用法，即使用 new 操作符来创建一个新对象。接下 来的两行代码展示了不使用 new 操作符调用 Person()会出现什么结果：属性和方法都被添加给 window 对象了。有读者可能还记得，当在全局作用域中调用一个函数时，this 对象总是指向 Global 对象（在 浏览器中就是 window 对象）。因此，在调用完函数之后，可以通过 window 对象来调用 sayName()方 法，并且还返回了”Greg”。最后，也可以使用 call()（或者 apply()）在某个特殊对象的作用域中 调用 Person()函数。这里是在对象 o 的作用域中调用的，因此调用后 o 就拥有了所有属性和 sayName() 方法。</p>
<ol start="2">
<li>构造函数的问题</li>
</ol>
<p>构造函数模式虽然好用，但也并非没有缺点。使用构造函数的主要问题，就是每个方法都要在每个 实例上重新创建一遍。在前面的例子中，person1 和 person2 都有一个名为 sayName()的方法，但那 两个方法不是同一个 Function 的实例。不要忘了——ECMAScript 中的函数是对象，因此每定义一个 函数，也就是实例化了一个对象。从逻辑角度讲，此时的构造函数也可以这样定义。</p>
<pre><code class="js">function Person(name, age, job){ this.name = name; this.age = age; this.job = job; this.sayName = new Function(&quot;alert(this.name)&quot;); // 与声明函数在逻辑上是等价的 }</code></pre>
<p>从这个角度上来看构造函数，更容易明白每个 Person 实例都包含一个不同的 Function 实例（以 显示 name 属性）的本质。说明白些，以这种方式创建函数，会导致不同的作用域链和标识符解析，但 创建 Function 新实例的机制仍然是相同的。</p>
<pre><code class="js">tom.sayName == jerry.sayName // false</code></pre>
<pre><code class="js">function Person(name, age, job){ this.name = name; this.age = age; this.job = job; this.sayName = sayName; }
function sayName(){
  alert(this.name)
}
var person1 = new Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;); 
var person2 = new Person(&quot;Greg&quot;, 27, &quot;Doctor&quot;);
person1.sayName == person2.sayName // true</code></pre>
<p>在这个例子中，我们把 sayName()函数的定义转移到了构造函数外部。而在构造函数内部，我们 将 sayName 属性设置成等于全局的 sayName 函数。这样一来，由于 sayName 包含的是一个指向函数 的指针，因此 person1 和 person2 对象就共享了在全局作用域中定义的同一个 sayName()函数。这 样做确实解决了两个函数做同一件事的问题，可是新问题又来了：在全局作用域中定义的函数实际上只 能被某个对象调用，这让全局作用域有点名不副实。而更让人无法接受的是：如果对象需要定义很多方 法，那么就要定义很多个全局函数，于是我们这个自定义的引用类型就丝毫没有封装性可言了。好在， 这些问题可以通过使用原型模式来解决。</p>
<h2 id="6-2-3-原型模式"><a href="#6-2-3-原型模式" class="headerlink" title="6.2.3 原型模式"></a>6.2.3 原型模式</h2><p>我们创建的每个函数都有一个 prototype（原型）属性，这个属性是一个指针，指向一个对象， 而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。如果按照字面意思来理解，那 么 prototype 就是通过调用构造函数而创建的那个对象实例的原型对象。使用原型对象的好处是可以 让所有对象实例共享它所包含的属性和方法。换句话说，不必在构造函数中定义对象实例的信息，而是 可以将这些信息直接添加到原型对象中，如下面的例子所示。</p>
<pre><code class="js">function Person(){ }
Person.prototype.name = &quot;Nicholas&quot;;
Person.prototype.age = 29; 
Person.prototype.job = &quot;Software Engineer&quot;; 
Person.prototype.sayName = function(){ alert(this.name); };
var person1 = new Person(); person1.sayName(); //&quot;Nicholas&quot;
var person2 = new Person();
person2.sayName(); //&quot;Nicholas&quot;
alert(person1.sayName == person2.sayName);//true</code></pre>
<p>在此，我们将 sayName()方法和所有属性直接添加到了 Person 的 prototype 属性中，构造函数 变成了空函数。即使如此，也仍然可以通过调用构造函数来创建新对象，而且新对象还会具有相同的属 性和方法。但与构造函数模式不同的是，新对象的这些属性和方法是由所有实例共享的。换句话说， person1 和 person2 访问的都是同一组属性和同一个 sayName()函数。要理解原型模式的工作原理， 必须先理解 ECMAScript 中原型对象的性质。</p>
<ol>
<li>理解原型对象</li>
</ol>
<p>无论什么时候，只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个 prototype 属性，这个属性指向函数的原型对象。在默认情况下，所有原型对象都会自动获得一个 constructor （构造函数）属性，这个属性包含一个指向 prototype 属性所在函数的指针。就拿前面的例子来说， Person.prototype. constructor 指向 Person。而通过这个构造函数，我们还可继续为原型对象 添加其他属性和方法。</p>
<p>创建了自定义的构造函数之后，其原型对象默认只会取得 constructor 属性；至于其他方法，则 都是从 Object 继承而来的。当调用构造函数创建一个新实例后，该实例的内部将包含一个指针（内部 属性），指向构造函数的原型对象。ECMA-262 第 5 版中管这个指针叫[[Prototype]]。虽然在脚本中 没有标准的方式访问 [[Prototype]] ， 但 Firefox、Safari 和 Chrome 在每个对象上都支持一个属性 <strong>proto</strong>；而在其他实现中，这个属性对脚本则是完全不可见的。<strong><em>不过，要明确的真正重要的一点就 是，这个连接存在于实例与构造函数的原型对象之间，而不是存在于实例与构造函数之间。</em></strong></p>
<p>虽然在所有实现中都无法访问到[[Prototype]]，但可以通过 isPrototypeOf()方法来确定对象之 间是否存在这种关系。 从本质上讲， 如果 [[Prototype]] 指向调用 isPrototypeOf() 方法的对象 （Person.prototype），那么这个方法就返回 true</p>
<pre><code class="js">Person.prototype.isProtytypeOf(person1) //true
Person.prototype.isPrototypeOf(person2) // true</code></pre>
<p>ECMAScript 5 增加了一个新方法，叫 Object.getPrototypeOf()，在所有支持的实现中，这个 方法返回[[Prototype]]的值。例如：</p>
<pre><code class="js">Object.getPrototypeOf(person1) == Person.prototype //true

Object.getPrototypeOf(person1).name //Nicholas</code></pre>
<blockquote>
<p>使用 Object.getPrototypeOf() 可以方便地取得一个对象的原型，而这在利用原型实现继承（本章稍后会讨论）的情况下是非常重要的。</p>
</blockquote>
<p>​    每当代码读取某个对象的某个属性时，都会执行一次搜索，目标是具有给定名字的属性。搜索首先 从对象实例本身开始。如果在实例中找到了具有给定名字的属性，则返回该属性的值；如果没有找到， 则继续搜索指针指向的原型对象，在原型对象中查找具有给定名字的属性。如果在原型对象中找到了这 个属性，则返回该属性的值。也就是说，在我们调用 person1.sayName()的时候，会先后执行两次搜 索。首先，解析器会问：“实例 person1 有 sayName 属性吗？”答：“没有。”然后，它继续搜索，再 问：“person1 的原型有 sayName 属性吗？”答：“有。”于是，它就读取那个保存在原型对象中的函 数。当我们调用 person2.sayName()时，将会重现相同的搜索过程，得到相同的结果。而这正是多个 对象实例共享原型所保存的属性和方法的基本原理。</p>
<blockquote>
<p>前面提到过，原型最初只包含 constructor 属性，而该属性也是共享的，因此 可以通过对象实例访问。</p>
</blockquote>
<p>如果在实例对象中定义的属性名与原型对象中的属性名冲突，则会屏蔽原型对象中的属性值</p>
<pre><code class="js">function Person(){}
Person.prototype,name = &#39;Nicholas&#39;
Person.prototype.age = 20
Person.prototype.sayName = function(){
  return this.name
}

var person1 = new Person()
var person2 = new Person()
person1.name // &#39;Nicholas&#39;
person1.name = &#39;chenyu&#39; 
person1.name // chenyu
person2.name // &#39;Nicholas&#39;</code></pre>
<p>在这个例子中，person1 的 name 被一个新值给屏蔽了。但无论访问 person1.name 还是访问 person2.name 都能够正常地返回值，即分别是”Greg”（来自对象实例）和”Nicholas”（来自原型）。 当在 alert()中访问 person1.name 时，需要读取它的值，因此就会在这个实例上搜索一个名为 name 的属性。这个属性确实存在，于是就返回它的值而不必再搜索原型了。当以同样的方式访问 person2. name 时，并没有在实例上发现该属性，因此就会继续搜索原型，结果在那里找到了 name 属性。</p>
<p>当为对象实例添加一个属性时，这个属性就会屏蔽原型对象中保存的同名属性；换句话说，添加这 个属性只会阻止我们访问原型中的那个属性，但不会修改那个属性。即使将这个属性设置为 null，也 只会在实例中设置这个属性，而不会恢复其指向原型的连接。不过，使用 delete 操作符则可以完全删 除实例属性，从而让我们能够重新访问原型中的属性，</p>
<pre><code class="js">delete person1.name 
person1.name // &quot;Nicholas&quot;</code></pre>
<p>使用 hasOwnProperty()方法可以检测一个属性是存在于实例中，还是存在于原型中。这个方法（不 要忘了它是从 Object 继承来的）只在给定属性存在于对象实例中时，才会返回 true。</p>
<ol start="2">
<li>原型与in操作符</li>
</ol>
<p>当in单独使用时，in 操作符会在通 过对象能够访问给定属性时返回 true，无论该属性存在于实例中还是原型中。</p>
<pre><code class="js">function Person(){}
Person.prototype,name = &#39;Nicholas&#39;
Person.prototype.age = 20
Person.prototype.sayName = function(){
  return this.name
}

var person1 = new Person()
var person2 = new Person()

&#39;name&#39; in person1 // true
person1.name = &#39;test&#39;
&#39;name&#39; in person1 // true</code></pre>
<p>在以上代码执行的整个过程中，name 属性要么是直接在对象上访问到的，要么是通过原型访问到 的。因此，调用”name” in person1 始终都返回 true，无论该属性存在于实例中还是存在于原型中。 同时使用 hasOwnProperty()方法和 in 操作符，就可以确定该属性到底是存在于对象中，还是存在于 原型中</p>
<pre><code class="js">function hasOwnPrototype(obj,name){
return ! obj.hasOwnProperty(name) &amp;&amp; (name in obj) 
}</code></pre>
<p>由于 in 操作符只要通过对象能够访问到属性就返回 true，hasOwnProperty()只在属性存在于 实例中时才返回 true，因此只要 in 操作符返回 true 而 hasOwnProperty()返回 false，就可以确 定属性是原型中的属性。下面来看一看上面定义的函数 hasPrototypeProperty()的用法。</p>
<p>在使用 for-in 循环时，当实例对象中的属性设置描述符enumerable为false时，无法进行枚举。</p>
<p>要取得对象上所有可枚举的实例属性，可以使用 ECMAScript 5 的 Object.keys()方法。这个方法 接收一个对象作为参数，返回一个包含所有可枚举属性的字符串数组。</p>
<pre><code class="js">function Person(){}
Person.prototype,name = &#39;Nicholas&#39;
Person.prototype.age = 20
Person.prototype.sayName = function(){
  return this.name
}

Object.keys(Person.prototype) // name ,age ,sayName

var p1 = new Person()
p1.name = &#39;rob&#39;
p1.age = 21
var p1Keys = Object.keys(p1)
p1Keys // name , age</code></pre>
<p>这里，变量 keys 中将保存一个数组，数组中是字符串”name”、”age”、”job”和”sayName”。这 个顺序也是它们在 for-in 循环中出现的顺序。如果是通过 Person 的实例调用，则 Object.keys() 返回的数组只包含”name”和”age”这两个实例属性。</p>
<blockquote>
<p>如果你想要得到所有实例属性，无论它是否可枚举，都可以使用 <code>Object.getOwnPropertyNames()</code>方法。</p>
</blockquote>
<pre><code class="js">var keys = Object.getOwnPropertyNames(Person.prototype)
keys // constructor , name , age , sayName</code></pre>
<p>注意结果中包含了不可枚举的 constructor 属性。Object.keys()和 Object.getOwnPropertyNames()方法都可以用来替代 for-in 循环。</p>
<ol start="3">
<li>更简单的原型语法</li>
</ol>
<p>前面例子中每添加一个属性和方法就要敲一遍 Person.prototype。为减少 不必要的输入，也为了从视觉上更好地封装原型的功能，更常见的做法是用一个包含所有属性和方法的 对象字面量来重写整个原型对象</p>
<pre><code class="js">function Person(){}
Person.prototype = {
  name : &#39;chenyu&#39;,
  age:25,
  sayName:function(){
    return this.name
  }
}</code></pre>
<p>在上面的代码中，我们将 Person.prototype 设置为等于一个以对象字面量形式创建的新对象。 最终结果相同，但有一个例外：constructor 属性不再指向 Person 了。前面曾经介绍过，每创建一 个函数，就会同时创建它的 prototype 对象，这个对象也会自动获得 constructor 属性。而我们在 这里使用的语法，本质上完全重写了默认的 prototype 对象，因此 constructor 属性也就变成了新 对象的 constructor 属性（指向 Object 构造函数），不再指向 Person 函数。此时，尽管 instanceof 操作符还能返回正确的结果，但通过 constructor 已经无法确定对象的类型了</p>
<pre><code class="js">var friend = new Person()
friend instanceof Person // true
friend.constructor  == Person // false
friend.constructor == Object // true</code></pre>
<p>创建覆盖的原型对象时，添加构造函数属性指针</p>
<pre><code class="js">Person.prototype = {
  constructor: Person,
  name: &#39;chenyu&#39;,
  age:21,
  sayName:function(){
    return this.name
  }
}</code></pre>
<p>字面量创建的constructor属性是可以被枚举的，可以使用Object.defineProperty()进行描述符修改</p>
<pre><code class="js">Person.prototype = {
  name: &#39;chenyu&#39;,
  age:21,
  sayName:function(){
    return this.name
  }
}

Obejct.defineProperty(Person.prototype,&#39;constructor&#39;,{
  enumerable:false,
  value:Person
})</code></pre>
<ol start="4">
<li>原型的动态性</li>
</ol>
<p>由于在原型中查找值的过程是一次搜索，因此我们对原型对象所做的任何修改都能够立即从实例上反映出来——即使是先创建了实例后修改原型也照样如此。</p>
<pre><code class="js">var friend = new Person()
Person.prototype.sayHi = function(){
  alert(&#39;hi&#39;)
}
friend.sayHi() // hi</code></pre>
<p>以上代码先创建了 Person 的一个实例，并将其保存在 person 中。然后，下一条语句在 Person. prototype 中添加了一个方法 sayHi()。即使 person 实例是在添加新方法之前创建的，但它仍然可 以访问这个新方法。其原因可以归结为实例与原型之间的松散连接关系。当我们调用 person.sayHi() 时，首先会在实例中搜索名为 sayHi 的属性，在没找到的情况下，会继续搜索原型。因为实例与原型 之间的连接只不过是一个指针，而非一个副本，因此就可以在原型中找到新的 sayHi 属性并返回保存 在那里的函数。</p>
<p>尽管可以随时为原型添加属性和方法，并且修改能够立即在所有对象实例中反映出来，但如果是重 写整个原型对象，那么情况就不一样了。我们知道，调用构造函数时会为实例添加一个指向最初原型的 [[Prototype]]指针，而把原型修改为另外一个对象就等于切断了构造函数与最初原型之间的联系。 请记住：实例中的指针仅指向原型，而不指向构造函数。看下面的例子。</p>
<pre><code class="js">var friend = new Person()
Person.prototype = {
  sayHi : function(){
  alert(&#39;hi&#39;)
}
}
friend.sayHi() // error</code></pre>
<ol start="5">
<li>原生对象的原型</li>
</ol>
<p>原型模式的重要性不仅体现在创建自定义类型方面，就连所有原生的引用类型，都是采用这种模式 创建的。所有原生引用类型（Object、Array、String，等等）都在其构造函数的原型上定义了方法。 例如， 在 Array.prototype 中可以找到 sort() 方法， 而在 String.prototype 中可以找到 substring()方法</p>
<p>通过原生对象的原型，不仅可以取得所有默认方法的引用，而且也可以定义新方法。可以像修改自 定义对象的原型一样修改原生对象的原型， 因此可以随时添加方法。 下面的代码就给基本包装类型 String 添加了一个名为 startsWith()的方法。</p>
<pre><code class="js">String.prototype.startsWith = function (text) { return this.indexOf(text) == 0; };
var msg = &quot;Hello world!&quot;; 
alert(msg.startsWith(&quot;Hello&quot;));</code></pre>
<p>这里新定义的 startsWith()方法会在传入的文本位于一个字符串开始时返回 true。既然方法被 添加给了 String.prototype，那么当前环境中的所有字符串就都可以调用它。由于 msg 是字符串， 而且后台会调用 String 基本包装函数创建这个字符串，因此通过 msg 就可以调用 startsWith()方法。</p>
<ol start="6">
<li>原型对象的问题</li>
</ol>
<p>原型模式也不是没有缺点。首先，它省略了为构造函数传递初始化参数这一环节，结果所有实例在 默认情况下都将取得相同的属性值。虽然这会在某种程度上带来一些不方便，但还不是原型的最大问题。 原型模式的最大问题是由其共享的本性所导致的。</p>
<p>原型中所有属性是被很多实例共享的，这种共享对于函数非常合适。对于那些包含基本值的属性倒 也说得过去，毕竟（如前面的例子所示），通过在实例上添加一个同名属性，可以隐藏原型中的对应属 性。然而，对于包含引用类型值的属性来说，问题就比较突出了。</p>
<pre><code class="js">function Person(){}
Person.prototype = {
  name:&#39;chenyu&#39;,
  age:25,
  friends:[&#39;1&#39;,&#39;2&#39;]
}
var person1 = new Person()
var person2 = new Person()
person1.friends.push(&#39;3&#39;) // [1,2,3]
person2.friends // [1,2,3] 随着改变
person1.friends == person2.friends // 指向同一个引用类型
</code></pre>
<p>在此，Person.prototype 对象有一个名为 friends 的属性，该属性包含一个字符串数组。然后， 创建了 Person 的两个实例。接着，修改了 person1.friends 引用的数组，向数组中添加了一个字符 串。由于 friends 数组存在于 Person.prototype 而非 person1 中，所以刚刚提到的修改也会通过 person2.friends（与 person1.friends 指向同一个数组）反映出来。假如我们的初衷就是像这样 在所有实例中共享一个数组，那么对这个结果我没有话可说。可是，实例一般都是要有属于自己的全部 属性的。而这个问题正是我们很少看到有人单独使用原型模式的原因所在。</p>
<h2 id="6-2-4-组合使用构造函数模式和原型模式"><a href="#6-2-4-组合使用构造函数模式和原型模式" class="headerlink" title="6.2.4 组合使用构造函数模式和原型模式"></a>6.2.4 组合使用构造函数模式和原型模式</h2><p>创建自定义类型的最常见方式，就是组合使用构造函数模式与原型模式。构造函数模式用于定义实 例属性，而原型模式用于定义方法和共享的属性。结果，每个实例都会有自己的一份实例属性的副本， 但同时又共享着对方法的引用，最大限度地节省了内存。另外，这种混成模式还支持向构造函数传递参 数；可谓是集两种模式之长。</p>
<pre><code class="js">function Person(name,age){
  this.name = name 
  this.age = age
  this.friends = [1,2,3]
}

Person.prototype = {
  constructor : Person,
  sayName:function(){
    return this.name
  }
}

var person1 = new Person(&#39;tom&#39;,23)
var person2 = new Person(&#39;jerry&#39;, 22)
person1.friends.push(4) // [1,2,3,4]
person2.friends // [1,2,3]

person1.friends == person2.friends // false
person1.sayName == person2.sayName // true
</code></pre>
<p>在这个例子中，实例属性都是在构造函数中定义的，而由所有实例共享的属性 constructor 和方 法 sayName()则是在原型中定义的。而修改了 person1.friends（向其中添加一个新字符串），并不 会影响到 person2.friends，因为它们分别引用了不同的数组。</p>
<blockquote>
<p>这种构造函数与原型混成的模式，是目前在 ECMAScript 中使用最广泛、认同度最高的一种创建自定义类型的方法。可以说，这是用来定义引用类型的一种默认模式。</p>
</blockquote>
<h2 id="动态原型模式"><a href="#动态原型模式" class="headerlink" title="动态原型模式"></a>动态原型模式</h2><p>有其他 OO 语言经验的开发人员在看到独立的构造函数和原型时，很可能会感到非常困惑。动态原 型模式正是致力于解决这个问题的一个方案，它把所有信息都封装在了构造函数中，而通过在构造函数 中初始化原型（仅在必要的情况下），又保持了同时使用构造函数和原型的优点。换句话说，可以通过 检查某个应该存在的方法是否有效，来决定是否需要初始化原型。</p>
<pre><code class="js">function Person(name,age){
  this.name= name 
  this.age = age
  if(typeof person.prototype.sayName != &#39;function&#39;){
         Person.prototype.sayName = function(){
    return this.name
      }
     }
}

var friend = new Person(&#39;tom&#39;,28)
friend.sayName() // tom</code></pre>
<p>这里只在 sayName()方法不存在的情况下，才会将它添加到原 型中。这段代码只会在初次调用构造函数时才会执行。此后，原型已经完成初始化，不需要再做什么修 改了。不过要记住，这里对原型所做的修改，能够立即在所有实例中得到反映。因此，这种方法确实可 以说非常完美。其中，if 语句检查的可以是初始化之后应该存在的任何属性或方法——不必用一大堆 if 语句检查每个属性和每个方法；只要检查其中一个即可。对于采用这种模式创建的对象，还可以使 用 instanceof 操作符确定它的类型。</p>
<h2 id="6-2-6-寄生构造函数模式"><a href="#6-2-6-寄生构造函数模式" class="headerlink" title="6.2.6 寄生构造函数模式"></a>6.2.6 寄生构造函数模式</h2><p>在前述的几种模式都不适用的情况下，可以使用寄生（parasitic）构造函数模式。这种模式 的基本思想是创建一个函数，该函数的作用仅仅是封装创建对象的代码，然后再返回新创建的对象；但 从表面上看，这个函数又很像是典型的构造函数。</p>
<pre><code class="js">function Person(name, age, job){ 
  var o = new Object(); 
  o.name = name; 
  o.age = age; 
  o.job = job; 
  o.sayName = function(){ alert(this.name); }; 
  return o;
}
var friend = new Person(&#39;tom&#39;,29,&#39;The engineer&#39;)
friend,sayName() //tom</code></pre>
<p>在这个例子中，Person 函数创建了一个新对象，并以相应的属性和方法初始化该对象，然后又返 回了这个对象。除了使用 new 操作符并把使用的包装函数叫做构造函数之外，这个模式跟工厂模式其实 是一模一样的。构造函数在不返回值的情况下，默认会返回新对象实例。而通过在构造函数的末尾添加一个 return 语句，可以重写调用构造函数时返回的值。</p>
<p>关于寄生构造函数模式，有一点需要说明：首先，返回的对象与构造函数或者与构造函数的原型属 性之间没有关系；也就是说，构造函数返回的对象与在构造函数外部创建的对象没有什么不同。为此， 不能依赖 instanceof 操作符来确定对象类型。由于存在上述问题，我们建议在可以使用其他模式的情 况下，不要使用这种模式。</p>
<h2 id="6-2-7-稳妥构造函数模式"><a href="#6-2-7-稳妥构造函数模式" class="headerlink" title="6.2.7 稳妥构造函数模式"></a>6.2.7 稳妥构造函数模式</h2><pre><code class="js">function Person(name,age){
  var o = new Object()
  o.sayName(){
    return name
  }
  return o
}</code></pre>
<p>仅仅能通过sayName获取name属性，其他方法无法获得。构造函数中，不使用this，不使用原型。</p>
<h1 id="6-3-继承"><a href="#6-3-继承" class="headerlink" title="6.3 继承"></a>6.3 继承</h1><h2 id="6-3-1-原型链"><a href="#6-3-1-原型链" class="headerlink" title="6.3.1 原型链"></a>6.3.1 原型链</h2><p>ECMAScript 中描述了原型链的概念，并将原型链作为实现继承的主要方法。其基本思想是利用原 型让一个引用类型继承另一个引用类型的属性和方法。简单回顾一下构造函数、原型和实例的关系：每 个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型 对象的内部指针。那么，假如我们让原型对象等于另一个类型的实例，结果会怎么样呢？显然，此时的 原型对象将包含一个指向另一个原型的指针，相应地，另一个原型中也包含着一个指向另一个构造函数 的指针。假如另一个原型又是另一个类型的实例，那么上述关系依然成立，如此层层递进，就构成了实 例与原型的链条。这就是所谓原型链的基本概念。</p>
<p>实现原型链有一种基本模式，其代码大致如下。</p>
<pre><code class="js">function superType(){
 this.property = true  
}
superType.prototype.superCall = function(){
  return this.property
}

function subType(){
  this.subproperty = false
}
subType.prototype = new superType()
subType.prototype.getSubValue = function(){
  return this.subproperty
}

var instance = new SubType()
instance.superCall() // true</code></pre>
<p>以上代码定义了两个类型：SuperType 和 SubType。每个类型分别有一个属性和一个方法。它们 的主要区别是 SubType 继承了 SuperType，而继承是通过创建 SuperType 的实例，并将该实例赋给 SubType.prototype 实现的。实现的本质是重写原型对象，代之以一个新类型的实例。换句话说，原 来存在于 SuperType 的实例中的所有属性和方法，现在也存在于 SubType.prototype 中了。在确立了 继承关系之后，我们给 SubType.prototype 添加了一个方法，这样就在继承了 SuperType 的属性和方 法的基础上又添加了一个新方法。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ge773ru1apj30ou0bhtab.jpg" alt="image-20200426152201518"></p>
<p>既然 SubType.prototype 现在是 SuperType的实例，那么 property 当然就位于该实例中了。此外，要注意 instance.constructor 现在指向的 是 SuperType，这是因为原来 SubType.prototype 中的 constructor 被重写了的缘故 。</p>
<p>通过实现原型链，本质上扩展了本章前面介绍的原型搜索机制。读者大概还记得，当以读取模式访 问一个实例属性时，首先会在实例中搜索该属性。如果没有找到该属性，则会继续搜索实例的原型。在 通过原型链实现继承的情况下， 搜索过程就得以沿着原型链继续向上。 就拿上面的例子来说， 调用 instance.getSuperValue()会经历三个搜索步骤：1）搜索实例；2）搜索 SubType.prototype； 3）搜索 SuperType.prototype，最后一步才会找到该方法。在找不到属性或方法的情况下，搜索过 程总是要一环一环地前行到原型链末端才会停下来。</p>
<ol>
<li>别忘记默认的原型</li>
</ol>
<p>事实上，前面例子中展示的原型链还少一环。我们知道，所有引用类型默认都继承了 Object，而 这个继承也是通过原型链实现的。大家要记住，所有函数的默认原型都是 Object 的实例，因此默认原 型都会包含一个内部指针，指向 Object.prototype。这也正是所有自定义类型都会继承 toString()、 valueOf()等默认方法的根本原因。所以，我们说上面例子展示的原型链中还应该包括另外一个继承层 次。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ge77cagzfkj30ox0ixq63.jpg" alt="image-20200426153006959"></p>
<p>一句话，SubType 继承了 SuperType，而 SuperType 继承了 Object。当调用 instance.toString() 时，实际上调用的是保存在 Object.prototype 中的那个方法。</p>
<ol start="2">
<li>确定原型和实例的关系</li>
</ol>
<p>可以通过两种方式来确定原型和实例之间的关系。第一种方式是使用 instanceof 操作符，只要用 这个操作符来测试实例与原型链中出现过的构造函数，结果就会返回 true。以下几行代码就说明了这 一点。</p>
<p>可以通过两种方式来确定原型和实例之间的关系。第一种方式是使用 instanceof 操作符，只要用 这个操作符来测试实例与原型链中出现过的构造函数，结果就会返回 true。以下几行代码就说明了这 一点。</p>
<pre><code class="js">alert(instance instanceof Object); //全部是true
alert(instance instanceof SuperType);
alert(instance instanceof SubType);</code></pre>
<p>由于原型链的关系，我们可以说 instance 是 Object、SuperType 或 SubType 中任何一个类型 的实例。因此，测试这三个构造函数的结果都返回了 true。</p>
<p>第二种方式是使用 isPrototypeOf()方法。同样，只要是原型链中出现过的原型，都可以说是该 原型链所派生的实例的原型，因此 isPrototypeOf()方法也会返回 true</p>
<pre><code class="js">Object.prototype.isPrototypeOf(instance)
SuperType.prototype.isPrototypeOf(instance)
SubType.prototype.isPrototypeOf(instance)</code></pre>
<ol start="3">
<li>谨慎的定义方法</li>
</ol>
<p>子类型有时候需要重写超类型中的某个方法，或者需要添加超类型中不存在的某个方法。但不管怎 样，给原型添加方法的代码一定要放在替换原型的语句之后。</p>
<pre><code class="js">function SuperType(){
  this.property = true
}
SuperType.prototype.getSuperValue = function(){
  return this.property
}

function SubType(){
  this.subProperty =  false
}
SubType.prototype = new SuperType()
SubType.prototype.getSuperValue = function(){
  return false
}
var instance = new SubType()
instance.getSuperValue // false</code></pre>
<p>在以上代码中，加粗的部分是两个方法的定义。第一个方法 getSubValue()被添加到了 SubType 中。第二个方法 getSuperValue()是原型链中已经存在的一个方法，但重写这个方法将会屏蔽原来的 那个方法。换句话说，当通过 SubType 的实例调用 getSuperValue()时，调用的就是这个重新定义 的方法；但通过 SuperType 的实例调用 getSuperValue()时，还会继续调用原来的那个方法。这里 要格外注意的是，必须在用 SuperType 的实例替换原型之后，再定义这两个方法。</p>
<p>还有一点需要提醒，即在通过原型链实现继承时，不能使用对象字面量创建原型方法。因为这 样做就会重写原型链</p>
<pre><code class="js">function SuperType(){
  this.property = true
}
SuperType.prototype.getSuperValue = function(){
  return this.property
}

function SubType(){
  this.subProperty =  false
}
SubType.prototype = new SuperType()
SubType.prototype = {
  getSubValue : function (){ return this.subproperty; },
} //使用字面量会重写原型 并无法访问超类型的属性和方法
</code></pre>
<p>以上代码展示了刚刚把 SuperType 的实例赋值给原型，紧接着又将原型替换成一个对象字面量而 导致的问题。由于现在的原型包含的是一个 Object 的实例，而非 SuperType 的实例，因此我们设想 中的原型链已经被切断——SubType 和 SuperType 之间已经没有关系了。</p>
<ol start="4">
<li>原型链的问题</li>
</ol>
<p>原型链虽然很强大，可以用它来实现继承，但它也存在一些问题。其中，最主要的问题来自包含引 用类型值的原型。想必大家还记得，我们前面介绍过包含引用类型值的原型属性会被所有实例共享；而 这也正是为什么要在构造函数中，而不是在原型对象中定义属性的原因。在通过原型来实现继承时，原 型实际上会变成另一个类型的实例。于是，原先的实例属性也就顺理成章地变成了现在的原型属性了</p>
<p>（如果构造函数中存在引用类型，则生成的实例共享当前引用类型）</p>
<h2 id="6-3-2-借用构造函数"><a href="#6-3-2-借用构造函数" class="headerlink" title="6.3.2 借用构造函数"></a>6.3.2 借用构造函数</h2><p>在解决原型中包含引用类型值所带来问题的过程中， 开发人员开始使用一种叫做借用构造函数 （constructor stealing）的技术（有时候也叫做伪造对象或经典继承）。这种技术的基本思想相当简单，即 在子类型构造函数的内部调用超类型构造函数。别忘了，函数只不过是在特定环境中执行代码的对象， 因此通过使用 apply()和 call()方法也可以在（将来）新创建的对象上执行构造函数</p>
<pre><code class="js">function SuperType(){
    this.colors = [&#39;red&#39;,&#39;blue&#39;,&#39;orange&#39;]
}

function SubType(){
  superType.call(this)
}

var instance1 = new SubType()
var instance2 = new SubType()
instance1.push(&#39;green&#39;) // [&#39;red&#39;,&#39;blue&#39;,&#39;orange&#39;,&#39;green&#39;]
instance2 // [&#39;red&#39;,&#39;blue&#39;,&#39;orange&#39;]
</code></pre>
<ol>
<li>传递参数</li>
</ol>
<p>相对于原型链而言，借用构造函数有一个很大的优势，即可以在子类型构造函数中向超类型构造函 数传递参数。</p>
<pre><code class="js">function SuperType(name){ this.name = name; }
function SubType(){
//继承了 SuperType，同时还传递了参数
  SuperType.call(this, &quot;Nicholas&quot;);
//实例属性
  this.age = 29;
}
var instance = new SubType();
alert(instance.name); //&quot;Nicholas&quot;;
alert(instance.age); //29</code></pre>
<p>以上代码中的 SuperType 只接受一个参数 name，该参数会直接赋给一个属性。在 SubType 构造 函数内部调用 SuperType 构造函数时，实际上是为 SubType 的实例设置了 name 属性。为了确保 SuperType 构造函数不会重写子类型的属性，可以在调用超类型构造函数后，再添加应该在子类型中 定义的属性。</p>
<ol start="2">
<li>借用构造函数的问题</li>
</ol>
<p>如果仅仅是借用构造函数，那么也将无法避免构造函数模式存在的问题——方法都在构造函数中定 义，因此函数复用就无从谈起了。而且，在超类型的原型中定义的方法，对子类型而言也是不可见的，结 果所有类型都只能使用构造函数模式。考虑到这些问题，借用构造函数的技术也是很少单独使用的。</p>
<h2 id="6-3-3-组合继承"><a href="#6-3-3-组合继承" class="headerlink" title="6.3.3 组合继承"></a>6.3.3 组合继承</h2><p>组合继承 = 原型链继承（原型的属性和方法继承-实例之前的共享）+ 构造函数继承（实例对象的属性和方法继承）</p>
<pre><code class="js">function SuperType(name){this.name = name;this.colors=[&#39;red&#39;,&#39;blue&#39;]}
SuperType.prototype.sayName = function(){
  return this.name
}

function SubType(name,age){
  SuperType.call(this,name)
  this.age = age
}

SubType.prototype = new SuperType()
SubType.prototype.constructor = SubType

var instance1 = new SubType(&#39;instance1&#39;,28)
var instance2 = new SubType(&#39;instance2&#39;,26)

instance1.colors.push(&#39;green&#39;) // [&#39;red&#39;,&#39;blue&#39;,&#39;green&#39;]
instance2.colors // [&#39;red&#39;,&#39;blue&#39;]
</code></pre>
<p>在这个例子中，SuperType 构造函数定义了两个属性：name 和 colors。SuperType 的原型定义 了一个方法 sayName()。SubType 构造函数在调用 SuperType 构造函数时传入了 name 参数，紧接着 又定义了它自己的属性 age。然后，将 SuperType 的实例赋值给 SubType 的原型，然后又在该新原型 上定义了方法 sayAge()。这样一来，就可以让两个不同的 SubType 实例既分别拥有自己属性——包 括 colors 属性，又可以使用相同的方法了。</p>
<p>组合继承避免了原型链和借用构造函数的缺陷，融合了它们的优点，成为 JavaScript 中最常用的继 承模式。而且，instanceof 和 isPrototypeOf()也能够用于识别基于组合继承创建的对象。</p>
<h2 id="6-3-4-原型式继承"><a href="#6-3-4-原型式继承" class="headerlink" title="6.3.4 原型式继承"></a>6.3.4 原型式继承</h2><p>道格拉斯·克罗克福德在 2006 年写了一篇文章，题为 Prototypal Inheritance in JavaScript （JavaScript 中的原型式继承）。在这篇文章中，他介绍了一种实现继承的方法，这种方法并没有使用严格意义上的 构造函数。他的想法是借助原型可以基于已有的对象创建新对象，同时还不必因此创建自定义类型。为 了达到这个目的，他给出了如下函数。</p>
<pre><code class="js">function object(o){
  function F(){} 
  F.prototype = o; 
  return new F(); 
}</code></pre>
<p>在 object()函数内部，先创建了一个临时性的构造函数，然后将传入的对象作为这个构造函数的 原型，最后返回了这个临时类型的一个新实例。从本质上讲，object()对传入其中的对象执行了一次浅复制。</p>
<p>克罗克福德主张的这种原型式继承，要求你必须有一个对象可以作为另一个对象的基础。如果有这么 一个对象的话，可以把它传递给 object()函数，然后再根据具体需求对得到的对象加以修改即可。在这 个例子中，可以作为另一个对象基础的是 person 对象，于是我们把它传入到 object()函数中，然后该 函数就会返回一个新对象。这个新对象将 person 作为原型，所以它的原型中就包含一个基本类型值属性 和一个引用类型值属性。这意味着 person.friends 不仅属于 person 所有，而且也会被 anotherPerson 以及 yetAnotherPerson 共享。实际上，这就相当于又创建了 person 对象的两个副本。</p>
<p>ECMAScript 5 通过新增 Object.create()方法规范化了原型式继承。这个方法接收两个参数：一 个用作新对象原型的对象和（可选的）一个为新对象定义额外属性的对象。在传入一个参数的情况下， Object.create()与 object()方法的行为相同。</p>
<p>Object.create()方法的第二个参数与 Object.defineProperties()方法的第二个参数格式相 同：每个属性都是通过自己的描述符定义的。以这种方式指定的任何属性都会覆盖原型对象上的同名属性。</p>
<p>支持 Object.create()方法的浏览器有 IE9+、Firefox 4+、Safari 5+、Opera 12+和 Chrome。 在没有必要兴师动众地创建构造函数，而只想让一个对象与另一个对象保持类似的情况下，原型式 继承是完全可以胜任的。不过别忘了，包含引用类型值的属性始终都会共享相应的值，就像使用原型模 式一样。</p>
<h2 id="6-3-5-寄生式继承"><a href="#6-3-5-寄生式继承" class="headerlink" title="6.3.5 寄生式继承"></a>6.3.5 寄生式继承</h2><p>寄生式（parasitic）继承是与原型式继承紧密相关的一种思路，并且同样也是由克罗克福德推而广 之的。寄生式继承的思路与寄生构造函数和工厂模式类似，即创建一个仅用于封装继承过程的函数，该 函数在内部以某种方式来增强对象，最后再像真地是它做了所有工作一样返回对象。</p>
<h2 id="6-3-6-寄生组合式继承"><a href="#6-3-6-寄生组合式继承" class="headerlink" title="6.3.6 寄生组合式继承"></a>6.3.6 寄生组合式继承</h2><p>前面说过，组合继承是 JavaScript 最常用的继承模式；不过，它也有自己的不足。组合继承最大的 问题就是无论什么情况下，都会调用两次超类型构造函数：一次是在创建子类型原型的时候，另一次是 在子类型构造函数内部。没错，子类型最终会包含超类型对象的全部实例属性，但我们不得不在调用子 类型构造函数时重写这些属性。</p>
<pre><code class="js">function SuperType(name){this.name = name}
SuperType.prototype.sayName = function(){
  return this.name
}

function SubType(name,age){
  SuperType.call(this,name) // 第二次调用SuperType构造函数
  this.age = age
}

SubType.prototype = new SuperType() //第一次调用SuperType构造函数
SubType.prototype.constructor = SubType
</code></pre>
<p>在第一次调用 SuperType 构造函数时， SubType.prototype 会得到两个属性：name 和 colors；它们都是 SuperType 的实例属性，只不过 现在位于 SubType 的原型中。当调用 SubType 构造函数时，又会调用一次 SuperType 构造函数，这 一次又在新对象上创建了实例属性 name 和 colors。于是，这两个属性就屏蔽了原型中的两个同名属 性。</p>
<p>有两组 name 和 colors 属性：一组在实例上，一组在 SubType 原型中。这就是调 用两次 SuperType 构造函数的结果。好在我们已经找到了解决这个问题方法——寄生组合式继承。</p>
<p>所谓寄生组合式继承，即通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。其背 后的基本思路是：不必为了指定子类型的原型而调用超类型的构造函数，我们所需要的无非就是超类型 原型的一个副本而已。本质上，就是使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型 的原型。</p>
<pre><code class="js">function inheritance(subType,superType){
  subType.prototype = Object.create(superType.prototype)
  subType.prototype.constructor = subType
}</code></pre>
<blockquote>
<p>通过给子类型的原型复制超类型原型的副本，避免调用超类型的构造函数，防止复制构造函数中用于创建实例的属性。直接从超类型的原型链上生成副本，避免与子类型生成的实例属性冲突。</p>
</blockquote>
<p>这个例子的高效率体现在它只调用了一次 SuperType 构造函数，并且因此避免了在 SubType. prototype 上面创建不必要的、多余的属性。与此同时，原型链还能保持不变；因此，还能够正常使用 instanceof 和 isPrototypeOf()。开发人员普遍认为寄生组合式继承是引用类型最理想的继承范式。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>ECMAScript 支持面向对象（OO）编程，但不使用类或者接口。对象可以在代码执行过程中创建和 增强，因此具有动态性而非严格定义的实体。在没有类的情况下，可以采用下列模式创建对象。  工厂模式，使用简单的函数创建对象，为对象添加属性和方法，然后返回对象。这个模式后来 被构造函数模式所取代。 </p>
<ul>
<li><p>构造函数模式，可以创建自定义引用类型，可以像创建内置对象实例一样使用 new 操作符。不 过，构造函数模式也有缺点，即它的每个成员都无法得到复用，包括函数。由于函数可以不局 限于任何对象（即与对象具有松散耦合的特点），因此没有理由不在多个对象间共享函数。  </p>
</li>
<li><p>原型模式，使用构造函数的 prototype 属性来指定那些应该共享的属性和方法。组合使用构造 函数模式和原型模式时，使用构造函数定义实例属性，而使用原型定义共享的属性和方法。 </p>
</li>
</ul>
<blockquote>
<p>JavaScript 主要通过原型链实现继承。原型链的构建是通过将一个类型的实例赋值给另一个构造函 数的原型实现的。这样，子类型就能够访问超类型的所有属性和方法，这一点与基于类的继承很相似。 原型链的问题是对象实例共享所有继承的属性和方法，因此不适宜单独使用。解决这个问题的技术是借 用构造函数，即在子类型构造函数的内部调用超类型构造函数。这样就可以做到每个实例都具有自己的 属性，同时还能保证只使用构造函数模式来定义类型。使用最多的继承模式是组合继承，这种模式使用 原型链继承共享的属性和方法，而通过借用构造函数继承实例属性。 </p>
<p>此外，还存在下列可供选择的继承模式。  </p>
<ul>
<li>原型式继承，可以在不必预先定义构造函数的情况下实现继承，其本质是执行对给定对象的浅 复制。而复制得到的副本还可以得到进一步改造。  </li>
<li>寄生式继承，与原型式继承非常相似，也是基于某个对象或某些信息创建一个对象，然后增强 对象，最后返回对象。为了解决组合继承模式由于多次调用超类型构造函数而导致的低效率问 题，可以将这个模式与组合继承一起使用。 </li>
<li>寄生组合式继承，集寄生式继承和组合继承的优点与一身，是实现基于类型继承的最有效方式。</li>
</ul>
</blockquote>
</div><div class="article-tags size-small is-uppercase mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">JavaScript高级程序设计</a><a class="link-muted mr-2" rel="tag" href="/tags/JS%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/">JS基本概念</a></div><div class="sharethis-inline-share-buttons"></div><script src="https://platform-api.sharethis.com/js/sharethis.js#property=5e880dcb362ea900110ed107&amp;product=inline-share-buttons" defer></script></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/passages/%E3%80%90JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%91%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/"><span class="level-item">【JS高级程序设计】第五章 引用类型</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div class="content" id="valine-thread"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="https://cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js"></script><script>new Valine({
            el: '#valine-thread' ,
            notify: false,
            verify: false,
            appId: 'SeCPf9THzi6bJu0qyj9WSdro-gzGzoHsz',
            appKey: 'n8YuImTKnhgvlQEVT9BuL9AA',
            placeholder: '有问题，请留言',
            avatar: 'mm',
            avatarForce: false,
            meta: ["nick","mail","link"],
            pageSize: 10,
            visitor: false,
            highlight: true,
            recordIP: false
        });</script></div></div></div><!--!--><div class="column column-right is-4-tablet is-4-desktop is-4-widescreen  order-3"><div class="card widget"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="is-rounded" src="https://avatars0.githubusercontent.com/u/29906331?s=460&amp;u=801fa238d3ef38451f6efdb19618e2e6a9125cdc&amp;v=4" alt="麦吹克斯"></figure><p class="title is-size-4 is-block line-height-inherit">麦吹克斯</p><p class="is-size-6 is-block">学习JavaScript，折腾MacOS</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>🌍一个地球</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">20</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">3</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">26</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="http://www.timemachine.top" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/CCYYZZNN"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com/CCYYZZNN"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><!--!--><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/categories/centos/"><span class="level-start"><span class="level-item">centos</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/javascript/"><span class="level-start"><span class="level-item">javascript</span></span><span class="level-end"><span class="level-item tag">17</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/macos/"><span class="level-start"><span class="level-item">macos</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><a class="media-left" href="/passages/%E3%80%90JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%91%E7%AC%AC%E5%85%AD%E7%AB%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"><p class="image is-64x64"><img class="thumbnail" src="https://s2.ax1x.com/2019/08/19/mlQ5rj.jpg" alt="【JS高级程序设计】第六章 面向对象的程序设计"></p></a><div class="media-content size-small"><p><time dateTime="2020-04-06T14:04:03.000Z">2020-04-06</time></p><p class="title is-6"><a class="link-muted" href="/passages/%E3%80%90JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%91%E7%AC%AC%E5%85%AD%E7%AB%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">【JS高级程序设计】第六章 面向对象的程序设计</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/javascript/">javascript</a></p></div></article><article class="media"><a class="media-left" href="/passages/%E3%80%90JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%91%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/"><p class="image is-64x64"><img class="thumbnail" src="https://s2.ax1x.com/2019/08/19/mlQ5rj.jpg" alt="【JS高级程序设计】第五章 引用类型"></p></a><div class="media-content size-small"><p><time dateTime="2020-04-06T14:04:03.000Z">2020-04-06</time></p><p class="title is-6"><a class="link-muted" href="/passages/%E3%80%90JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%91%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/">【JS高级程序设计】第五章 引用类型</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/javascript/">javascript</a></p></div></article><article class="media"><a class="media-left" href="/passages/%E3%80%90JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%91%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%8F%98%E9%87%8F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%86%85%E5%AD%98%E9%97%AE%E9%A2%98/"><p class="image is-64x64"><img class="thumbnail" src="https://s2.ax1x.com/2019/08/19/mlQ5rj.jpg" alt="【JS高级程序设计】第四章 变量、作用域和内存问题"></p></a><div class="media-content size-small"><p><time dateTime="2020-04-05T15:37:18.000Z">2020-04-05</time></p><p class="title is-6"><a class="link-muted" href="/passages/%E3%80%90JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%91%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%8F%98%E9%87%8F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%86%85%E5%AD%98%E9%97%AE%E9%A2%98/">【JS高级程序设计】第四章 变量、作用域和内存问题</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/javascript/">javascript</a></p></div></article><article class="media"><a class="media-left" href="/passages/%E3%80%90JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%91%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"><p class="image is-64x64"><img class="thumbnail" src="https://s2.ax1x.com/2019/08/19/mlQ5rj.jpg" alt="【JS高级程序设计】第三章 基本概念"></p></a><div class="media-content size-small"><p><time dateTime="2020-04-01T13:38:17.000Z">2020-04-01</time></p><p class="title is-6"><a class="link-muted" href="/passages/%E3%80%90JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%91%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/">【JS高级程序设计】第三章 基本概念</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/javascript/">javascript</a></p></div></article><article class="media"><a class="media-left" href="/passages/%E3%80%90JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%91%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%9C%A8HTML%E4%B8%AD%E4%BD%BF%E7%94%A8JavaScript/"><p class="image is-64x64"><img class="thumbnail" src="https://s2.ax1x.com/2019/08/19/mlQ5rj.jpg" alt="【JS高级程序设计】 第二章 使用JavaScript"></p></a><div class="media-content size-small"><p><time dateTime="2020-04-01T09:31:16.000Z">2020-04-01</time></p><p class="title is-6"><a class="link-muted" href="/passages/%E3%80%90JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%91%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%9C%A8HTML%E4%B8%AD%E4%BD%BF%E7%94%A8JavaScript/">【JS高级程序设计】 第二章 使用JavaScript</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/javascript/">javascript</a></p></div></article></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/archives/2020/04/"><span class="level-start"><span class="level-item">四月 2020</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/03/"><span class="level-start"><span class="level-item">三月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/10/"><span class="level-start"><span class="level-item">十月 2019</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/09/"><span class="level-start"><span class="level-item">九月 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/08/"><span class="level-start"><span class="level-item">八月 2019</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Array/"><span class="tag">Array</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CentOS/"><span class="tag">CentOS</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/DOM/"><span class="tag">DOM</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/DOM%E6%93%8D%E4%BD%9C/"><span class="tag">DOM操作</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/DOM%E6%96%87%E6%A1%A3%E5%AF%B9%E8%B1%A1/"><span class="tag">DOM文档对象</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/DOM%E7%BB%93%E6%9E%84/"><span class="tag">DOM结构</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/DOM%E8%8A%82%E7%82%B9%E6%93%8D%E4%BD%9C/"><span class="tag">DOM节点操作</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Function/"><span class="tag">Function</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/HTML%E6%A0%87%E8%AE%B0/"><span class="tag">HTML标记</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/JS%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"><span class="tag">JS基本概念</span><span class="tag is-grey-lightest">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/JavaScript/"><span class="tag">JavaScript</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"><span class="tag">JavaScript高级程序设计</span><span class="tag is-grey-lightest">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Javascript/"><span class="tag">Javascript</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/MacOS-%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/"><span class="tag">MacOS 常用软件</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/TNT-%E7%A0%B4%E8%A7%A3%E7%89%88/"><span class="tag">TNT 破解版</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/javascript-dom-%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/"><span class="tag">javascript-dom-编程艺术</span><span class="tag is-grey-lightest">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/this%E6%8C%87%E9%92%88/"><span class="tag">this指针</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%9B%BE%E7%89%87%E5%BA%93/"><span class="tag">图片库</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%9B%BE%E7%89%87%E5%BA%93%E6%94%B9%E8%BF%9B/"><span class="tag">图片库改进</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%9C%A8HTML%E4%B8%AD%E4%BD%BF%E7%94%A8JavaScript/"><span class="tag">在HTML中使用JavaScript</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/"><span class="tag">快捷键</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%88%E7%8E%87/"><span class="tag">效率</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"><span class="tag">最佳实践</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%9F%A5%E8%AF%86%E7%82%B9/"><span class="tag">知识点</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%AB%AF%E5%8F%A3/"><span class="tag">端口</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%98%B2%E7%81%AB%E5%A2%99/"><span class="tag">防火墙</span><span class="tag is-grey-lightest">1</span></a></div></div></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">订阅更新</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button is-primary" type="submit" value="订阅"></div></div></form></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="Matrix" height="28"></a><p class="size-small"><span>&copy; 2020 CCYYZZNN</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">共<span id="busuanzi_value_site_uv">0</span>个访客</span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            site: {
                url: 'http://timemachine.top',
                external_link: {"enable":true,"exclude":[]}
            },
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>